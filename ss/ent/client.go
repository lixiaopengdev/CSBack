// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"CSBackendTmp/ent/migrate"

	"CSBackendTmp/ent/agora_token"
	"CSBackendTmp/ent/bundle"
	"CSBackendTmp/ent/card"
	"CSBackendTmp/ent/collection"
	"CSBackendTmp/ent/commodity"
	"CSBackendTmp/ent/contact"
	"CSBackendTmp/ent/creation"
	"CSBackendTmp/ent/csfield"
	"CSBackendTmp/ent/device"
	"CSBackendTmp/ent/feedback"
	"CSBackendTmp/ent/friendship"
	"CSBackendTmp/ent/hidden"
	"CSBackendTmp/ent/invite_code"
	"CSBackendTmp/ent/join"
	"CSBackendTmp/ent/mask"
	"CSBackendTmp/ent/message"
	"CSBackendTmp/ent/nft"
	"CSBackendTmp/ent/reaction"
	"CSBackendTmp/ent/rule"
	"CSBackendTmp/ent/setting"
	"CSBackendTmp/ent/stream"
	"CSBackendTmp/ent/timedew"
	"CSBackendTmp/ent/user"
	"CSBackendTmp/ent/user_auth"
	"CSBackendTmp/ent/user_history"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Agora_token is the client for interacting with the Agora_token builders.
	Agora_token *Agora_tokenClient
	// Bundle is the client for interacting with the Bundle builders.
	Bundle *BundleClient
	// CSField is the client for interacting with the CSField builders.
	CSField *CSFieldClient
	// Card is the client for interacting with the Card builders.
	Card *CardClient
	// Collection is the client for interacting with the Collection builders.
	Collection *CollectionClient
	// Commodity is the client for interacting with the Commodity builders.
	Commodity *CommodityClient
	// Contact is the client for interacting with the Contact builders.
	Contact *ContactClient
	// Creation is the client for interacting with the Creation builders.
	Creation *CreationClient
	// Device is the client for interacting with the Device builders.
	Device *DeviceClient
	// Feedback is the client for interacting with the Feedback builders.
	Feedback *FeedbackClient
	// Friendship is the client for interacting with the Friendship builders.
	Friendship *FriendshipClient
	// Hidden is the client for interacting with the Hidden builders.
	Hidden *HiddenClient
	// Invite_Code is the client for interacting with the Invite_Code builders.
	Invite_Code *Invite_CodeClient
	// Join is the client for interacting with the Join builders.
	Join *JoinClient
	// Mask is the client for interacting with the Mask builders.
	Mask *MaskClient
	// Message is the client for interacting with the Message builders.
	Message *MessageClient
	// NFT is the client for interacting with the NFT builders.
	NFT *NFTClient
	// Reaction is the client for interacting with the Reaction builders.
	Reaction *ReactionClient
	// Rule is the client for interacting with the Rule builders.
	Rule *RuleClient
	// Setting is the client for interacting with the Setting builders.
	Setting *SettingClient
	// Stream is the client for interacting with the Stream builders.
	Stream *StreamClient
	// TimeDew is the client for interacting with the TimeDew builders.
	TimeDew *TimeDewClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// User_auth is the client for interacting with the User_auth builders.
	User_auth *User_authClient
	// User_history is the client for interacting with the User_history builders.
	User_history *User_historyClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Agora_token = NewAgora_tokenClient(c.config)
	c.Bundle = NewBundleClient(c.config)
	c.CSField = NewCSFieldClient(c.config)
	c.Card = NewCardClient(c.config)
	c.Collection = NewCollectionClient(c.config)
	c.Commodity = NewCommodityClient(c.config)
	c.Contact = NewContactClient(c.config)
	c.Creation = NewCreationClient(c.config)
	c.Device = NewDeviceClient(c.config)
	c.Feedback = NewFeedbackClient(c.config)
	c.Friendship = NewFriendshipClient(c.config)
	c.Hidden = NewHiddenClient(c.config)
	c.Invite_Code = NewInvite_CodeClient(c.config)
	c.Join = NewJoinClient(c.config)
	c.Mask = NewMaskClient(c.config)
	c.Message = NewMessageClient(c.config)
	c.NFT = NewNFTClient(c.config)
	c.Reaction = NewReactionClient(c.config)
	c.Rule = NewRuleClient(c.config)
	c.Setting = NewSettingClient(c.config)
	c.Stream = NewStreamClient(c.config)
	c.TimeDew = NewTimeDewClient(c.config)
	c.User = NewUserClient(c.config)
	c.User_auth = NewUser_authClient(c.config)
	c.User_history = NewUser_historyClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Agora_token:  NewAgora_tokenClient(cfg),
		Bundle:       NewBundleClient(cfg),
		CSField:      NewCSFieldClient(cfg),
		Card:         NewCardClient(cfg),
		Collection:   NewCollectionClient(cfg),
		Commodity:    NewCommodityClient(cfg),
		Contact:      NewContactClient(cfg),
		Creation:     NewCreationClient(cfg),
		Device:       NewDeviceClient(cfg),
		Feedback:     NewFeedbackClient(cfg),
		Friendship:   NewFriendshipClient(cfg),
		Hidden:       NewHiddenClient(cfg),
		Invite_Code:  NewInvite_CodeClient(cfg),
		Join:         NewJoinClient(cfg),
		Mask:         NewMaskClient(cfg),
		Message:      NewMessageClient(cfg),
		NFT:          NewNFTClient(cfg),
		Reaction:     NewReactionClient(cfg),
		Rule:         NewRuleClient(cfg),
		Setting:      NewSettingClient(cfg),
		Stream:       NewStreamClient(cfg),
		TimeDew:      NewTimeDewClient(cfg),
		User:         NewUserClient(cfg),
		User_auth:    NewUser_authClient(cfg),
		User_history: NewUser_historyClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:          ctx,
		config:       cfg,
		Agora_token:  NewAgora_tokenClient(cfg),
		Bundle:       NewBundleClient(cfg),
		CSField:      NewCSFieldClient(cfg),
		Card:         NewCardClient(cfg),
		Collection:   NewCollectionClient(cfg),
		Commodity:    NewCommodityClient(cfg),
		Contact:      NewContactClient(cfg),
		Creation:     NewCreationClient(cfg),
		Device:       NewDeviceClient(cfg),
		Feedback:     NewFeedbackClient(cfg),
		Friendship:   NewFriendshipClient(cfg),
		Hidden:       NewHiddenClient(cfg),
		Invite_Code:  NewInvite_CodeClient(cfg),
		Join:         NewJoinClient(cfg),
		Mask:         NewMaskClient(cfg),
		Message:      NewMessageClient(cfg),
		NFT:          NewNFTClient(cfg),
		Reaction:     NewReactionClient(cfg),
		Rule:         NewRuleClient(cfg),
		Setting:      NewSettingClient(cfg),
		Stream:       NewStreamClient(cfg),
		TimeDew:      NewTimeDewClient(cfg),
		User:         NewUserClient(cfg),
		User_auth:    NewUser_authClient(cfg),
		User_history: NewUser_historyClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Agora_token.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Agora_token.Use(hooks...)
	c.Bundle.Use(hooks...)
	c.CSField.Use(hooks...)
	c.Card.Use(hooks...)
	c.Collection.Use(hooks...)
	c.Commodity.Use(hooks...)
	c.Contact.Use(hooks...)
	c.Creation.Use(hooks...)
	c.Device.Use(hooks...)
	c.Feedback.Use(hooks...)
	c.Friendship.Use(hooks...)
	c.Hidden.Use(hooks...)
	c.Invite_Code.Use(hooks...)
	c.Join.Use(hooks...)
	c.Mask.Use(hooks...)
	c.Message.Use(hooks...)
	c.NFT.Use(hooks...)
	c.Reaction.Use(hooks...)
	c.Rule.Use(hooks...)
	c.Setting.Use(hooks...)
	c.Stream.Use(hooks...)
	c.TimeDew.Use(hooks...)
	c.User.Use(hooks...)
	c.User_auth.Use(hooks...)
	c.User_history.Use(hooks...)
}

// Agora_tokenClient is a client for the Agora_token schema.
type Agora_tokenClient struct {
	config
}

// NewAgora_tokenClient returns a client for the Agora_token from the given config.
func NewAgora_tokenClient(c config) *Agora_tokenClient {
	return &Agora_tokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `agora_token.Hooks(f(g(h())))`.
func (c *Agora_tokenClient) Use(hooks ...Hook) {
	c.hooks.Agora_token = append(c.hooks.Agora_token, hooks...)
}

// Create returns a builder for creating a Agora_token entity.
func (c *Agora_tokenClient) Create() *AgoraTokenCreate {
	mutation := newAgoraTokenMutation(c.config, OpCreate)
	return &AgoraTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Agora_token entities.
func (c *Agora_tokenClient) CreateBulk(builders ...*AgoraTokenCreate) *AgoraTokenCreateBulk {
	return &AgoraTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Agora_token.
func (c *Agora_tokenClient) Update() *AgoraTokenUpdate {
	mutation := newAgoraTokenMutation(c.config, OpUpdate)
	return &AgoraTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *Agora_tokenClient) UpdateOne(at *Agora_token) *AgoraTokenUpdateOne {
	mutation := newAgoraTokenMutation(c.config, OpUpdateOne, withAgora_token(at))
	return &AgoraTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *Agora_tokenClient) UpdateOneID(id uint64) *AgoraTokenUpdateOne {
	mutation := newAgoraTokenMutation(c.config, OpUpdateOne, withAgora_tokenID(id))
	return &AgoraTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Agora_token.
func (c *Agora_tokenClient) Delete() *AgoraTokenDelete {
	mutation := newAgoraTokenMutation(c.config, OpDelete)
	return &AgoraTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *Agora_tokenClient) DeleteOne(at *Agora_token) *AgoraTokenDeleteOne {
	return c.DeleteOneID(at.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *Agora_tokenClient) DeleteOneID(id uint64) *AgoraTokenDeleteOne {
	builder := c.Delete().Where(agora_token.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AgoraTokenDeleteOne{builder}
}

// Query returns a query builder for Agora_token.
func (c *Agora_tokenClient) Query() *AgoraTokenQuery {
	return &AgoraTokenQuery{
		config: c.config,
	}
}

// Get returns a Agora_token entity by its id.
func (c *Agora_tokenClient) Get(ctx context.Context, id uint64) (*Agora_token, error) {
	return c.Query().Where(agora_token.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *Agora_tokenClient) GetX(ctx context.Context, id uint64) *Agora_token {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Agora_token.
func (c *Agora_tokenClient) QueryOwner(at *Agora_token) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := at.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(agora_token.Table, agora_token.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, agora_token.OwnerTable, agora_token.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(at.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *Agora_tokenClient) Hooks() []Hook {
	return c.hooks.Agora_token
}

// BundleClient is a client for the Bundle schema.
type BundleClient struct {
	config
}

// NewBundleClient returns a client for the Bundle from the given config.
func NewBundleClient(c config) *BundleClient {
	return &BundleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `bundle.Hooks(f(g(h())))`.
func (c *BundleClient) Use(hooks ...Hook) {
	c.hooks.Bundle = append(c.hooks.Bundle, hooks...)
}

// Create returns a builder for creating a Bundle entity.
func (c *BundleClient) Create() *BundleCreate {
	mutation := newBundleMutation(c.config, OpCreate)
	return &BundleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Bundle entities.
func (c *BundleClient) CreateBulk(builders ...*BundleCreate) *BundleCreateBulk {
	return &BundleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Bundle.
func (c *BundleClient) Update() *BundleUpdate {
	mutation := newBundleMutation(c.config, OpUpdate)
	return &BundleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BundleClient) UpdateOne(b *Bundle) *BundleUpdateOne {
	mutation := newBundleMutation(c.config, OpUpdateOne, withBundle(b))
	return &BundleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BundleClient) UpdateOneID(id uint64) *BundleUpdateOne {
	mutation := newBundleMutation(c.config, OpUpdateOne, withBundleID(id))
	return &BundleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Bundle.
func (c *BundleClient) Delete() *BundleDelete {
	mutation := newBundleMutation(c.config, OpDelete)
	return &BundleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BundleClient) DeleteOne(b *Bundle) *BundleDeleteOne {
	return c.DeleteOneID(b.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BundleClient) DeleteOneID(id uint64) *BundleDeleteOne {
	builder := c.Delete().Where(bundle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BundleDeleteOne{builder}
}

// Query returns a query builder for Bundle.
func (c *BundleClient) Query() *BundleQuery {
	return &BundleQuery{
		config: c.config,
	}
}

// Get returns a Bundle entity by its id.
func (c *BundleClient) Get(ctx context.Context, id uint64) (*Bundle, error) {
	return c.Query().Where(bundle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BundleClient) GetX(ctx context.Context, id uint64) *Bundle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Bundle.
func (c *BundleClient) QueryOwner(b *Bundle) *MaskQuery {
	query := &MaskQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := b.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(bundle.Table, bundle.FieldID, id),
			sqlgraph.To(mask.Table, mask.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, bundle.OwnerTable, bundle.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(b.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BundleClient) Hooks() []Hook {
	return c.hooks.Bundle
}

// CSFieldClient is a client for the CSField schema.
type CSFieldClient struct {
	config
}

// NewCSFieldClient returns a client for the CSField from the given config.
func NewCSFieldClient(c config) *CSFieldClient {
	return &CSFieldClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `csfield.Hooks(f(g(h())))`.
func (c *CSFieldClient) Use(hooks ...Hook) {
	c.hooks.CSField = append(c.hooks.CSField, hooks...)
}

// Create returns a builder for creating a CSField entity.
func (c *CSFieldClient) Create() *CSFieldCreate {
	mutation := newCSFieldMutation(c.config, OpCreate)
	return &CSFieldCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CSField entities.
func (c *CSFieldClient) CreateBulk(builders ...*CSFieldCreate) *CSFieldCreateBulk {
	return &CSFieldCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CSField.
func (c *CSFieldClient) Update() *CSFieldUpdate {
	mutation := newCSFieldMutation(c.config, OpUpdate)
	return &CSFieldUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CSFieldClient) UpdateOne(cf *CSField) *CSFieldUpdateOne {
	mutation := newCSFieldMutation(c.config, OpUpdateOne, withCSField(cf))
	return &CSFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CSFieldClient) UpdateOneID(id uint64) *CSFieldUpdateOne {
	mutation := newCSFieldMutation(c.config, OpUpdateOne, withCSFieldID(id))
	return &CSFieldUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CSField.
func (c *CSFieldClient) Delete() *CSFieldDelete {
	mutation := newCSFieldMutation(c.config, OpDelete)
	return &CSFieldDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CSFieldClient) DeleteOne(cf *CSField) *CSFieldDeleteOne {
	return c.DeleteOneID(cf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CSFieldClient) DeleteOneID(id uint64) *CSFieldDeleteOne {
	builder := c.Delete().Where(csfield.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CSFieldDeleteOne{builder}
}

// Query returns a query builder for CSField.
func (c *CSFieldClient) Query() *CSFieldQuery {
	return &CSFieldQuery{
		config: c.config,
	}
}

// Get returns a CSField entity by its id.
func (c *CSFieldClient) Get(ctx context.Context, id uint64) (*CSField, error) {
	return c.Query().Where(csfield.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CSFieldClient) GetX(ctx context.Context, id uint64) *CSField {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryJoinedUser queries the joined_user edge of a CSField.
func (c *CSFieldClient) QueryJoinedUser(cf *CSField) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(csfield.Table, csfield.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, csfield.JoinedUserTable, csfield.JoinedUserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(cf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJoins queries the joins edge of a CSField.
func (c *CSFieldClient) QueryJoins(cf *CSField) *JoinQuery {
	query := &JoinQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(csfield.Table, csfield.FieldID, id),
			sqlgraph.To(join.Table, join.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, csfield.JoinsTable, csfield.JoinsColumn),
		)
		fromV = sqlgraph.Neighbors(cf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CSFieldClient) Hooks() []Hook {
	return c.hooks.CSField
}

// CardClient is a client for the Card schema.
type CardClient struct {
	config
}

// NewCardClient returns a client for the Card from the given config.
func NewCardClient(c config) *CardClient {
	return &CardClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `card.Hooks(f(g(h())))`.
func (c *CardClient) Use(hooks ...Hook) {
	c.hooks.Card = append(c.hooks.Card, hooks...)
}

// Create returns a builder for creating a Card entity.
func (c *CardClient) Create() *CardCreate {
	mutation := newCardMutation(c.config, OpCreate)
	return &CardCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Card entities.
func (c *CardClient) CreateBulk(builders ...*CardCreate) *CardCreateBulk {
	return &CardCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Card.
func (c *CardClient) Update() *CardUpdate {
	mutation := newCardMutation(c.config, OpUpdate)
	return &CardUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CardClient) UpdateOne(ca *Card) *CardUpdateOne {
	mutation := newCardMutation(c.config, OpUpdateOne, withCard(ca))
	return &CardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CardClient) UpdateOneID(id uint64) *CardUpdateOne {
	mutation := newCardMutation(c.config, OpUpdateOne, withCardID(id))
	return &CardUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Card.
func (c *CardClient) Delete() *CardDelete {
	mutation := newCardMutation(c.config, OpDelete)
	return &CardDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CardClient) DeleteOne(ca *Card) *CardDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CardClient) DeleteOneID(id uint64) *CardDeleteOne {
	builder := c.Delete().Where(card.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CardDeleteOne{builder}
}

// Query returns a query builder for Card.
func (c *CardClient) Query() *CardQuery {
	return &CardQuery{
		config: c.config,
	}
}

// Get returns a Card entity by its id.
func (c *CardClient) Get(ctx context.Context, id uint64) (*Card, error) {
	return c.Query().Where(card.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CardClient) GetX(ctx context.Context, id uint64) *Card {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRule queries the rule edge of a Card.
func (c *CardClient) QueryRule(ca *Card) *RuleQuery {
	query := &RuleQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(card.Table, card.FieldID, id),
			sqlgraph.To(rule.Table, rule.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, card.RuleTable, card.RulePrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Card.
func (c *CardClient) QueryOwner(ca *Card) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(card.Table, card.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, card.OwnerTable, card.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CardClient) Hooks() []Hook {
	return c.hooks.Card
}

// CollectionClient is a client for the Collection schema.
type CollectionClient struct {
	config
}

// NewCollectionClient returns a client for the Collection from the given config.
func NewCollectionClient(c config) *CollectionClient {
	return &CollectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `collection.Hooks(f(g(h())))`.
func (c *CollectionClient) Use(hooks ...Hook) {
	c.hooks.Collection = append(c.hooks.Collection, hooks...)
}

// Create returns a builder for creating a Collection entity.
func (c *CollectionClient) Create() *CollectionCreate {
	mutation := newCollectionMutation(c.config, OpCreate)
	return &CollectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Collection entities.
func (c *CollectionClient) CreateBulk(builders ...*CollectionCreate) *CollectionCreateBulk {
	return &CollectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Collection.
func (c *CollectionClient) Update() *CollectionUpdate {
	mutation := newCollectionMutation(c.config, OpUpdate)
	return &CollectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CollectionClient) UpdateOne(co *Collection) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollection(co))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CollectionClient) UpdateOneID(id uint64) *CollectionUpdateOne {
	mutation := newCollectionMutation(c.config, OpUpdateOne, withCollectionID(id))
	return &CollectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Collection.
func (c *CollectionClient) Delete() *CollectionDelete {
	mutation := newCollectionMutation(c.config, OpDelete)
	return &CollectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CollectionClient) DeleteOne(co *Collection) *CollectionDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CollectionClient) DeleteOneID(id uint64) *CollectionDeleteOne {
	builder := c.Delete().Where(collection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CollectionDeleteOne{builder}
}

// Query returns a query builder for Collection.
func (c *CollectionClient) Query() *CollectionQuery {
	return &CollectionQuery{
		config: c.config,
	}
}

// Get returns a Collection entity by its id.
func (c *CollectionClient) Get(ctx context.Context, id uint64) (*Collection, error) {
	return c.Query().Where(collection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CollectionClient) GetX(ctx context.Context, id uint64) *Collection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Collection.
func (c *CollectionClient) QueryOwner(co *Collection) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(collection.Table, collection.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, collection.OwnerTable, collection.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CollectionClient) Hooks() []Hook {
	return c.hooks.Collection
}

// CommodityClient is a client for the Commodity schema.
type CommodityClient struct {
	config
}

// NewCommodityClient returns a client for the Commodity from the given config.
func NewCommodityClient(c config) *CommodityClient {
	return &CommodityClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `commodity.Hooks(f(g(h())))`.
func (c *CommodityClient) Use(hooks ...Hook) {
	c.hooks.Commodity = append(c.hooks.Commodity, hooks...)
}

// Create returns a builder for creating a Commodity entity.
func (c *CommodityClient) Create() *CommodityCreate {
	mutation := newCommodityMutation(c.config, OpCreate)
	return &CommodityCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Commodity entities.
func (c *CommodityClient) CreateBulk(builders ...*CommodityCreate) *CommodityCreateBulk {
	return &CommodityCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Commodity.
func (c *CommodityClient) Update() *CommodityUpdate {
	mutation := newCommodityMutation(c.config, OpUpdate)
	return &CommodityUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CommodityClient) UpdateOne(co *Commodity) *CommodityUpdateOne {
	mutation := newCommodityMutation(c.config, OpUpdateOne, withCommodity(co))
	return &CommodityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CommodityClient) UpdateOneID(id uint64) *CommodityUpdateOne {
	mutation := newCommodityMutation(c.config, OpUpdateOne, withCommodityID(id))
	return &CommodityUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Commodity.
func (c *CommodityClient) Delete() *CommodityDelete {
	mutation := newCommodityMutation(c.config, OpDelete)
	return &CommodityDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CommodityClient) DeleteOne(co *Commodity) *CommodityDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CommodityClient) DeleteOneID(id uint64) *CommodityDeleteOne {
	builder := c.Delete().Where(commodity.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CommodityDeleteOne{builder}
}

// Query returns a query builder for Commodity.
func (c *CommodityClient) Query() *CommodityQuery {
	return &CommodityQuery{
		config: c.config,
	}
}

// Get returns a Commodity entity by its id.
func (c *CommodityClient) Get(ctx context.Context, id uint64) (*Commodity, error) {
	return c.Query().Where(commodity.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CommodityClient) GetX(ctx context.Context, id uint64) *Commodity {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCard queries the card edge of a Commodity.
func (c *CommodityClient) QueryCard(co *Commodity) *CardQuery {
	query := &CardQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(commodity.Table, commodity.FieldID, id),
			sqlgraph.To(card.Table, card.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, commodity.CardTable, commodity.CardColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNFT queries the NFT edge of a Commodity.
func (c *CommodityClient) QueryNFT(co *Commodity) *NFTQuery {
	query := &NFTQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(commodity.Table, commodity.FieldID, id),
			sqlgraph.To(nft.Table, nft.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, commodity.NFTTable, commodity.NFTColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CommodityClient) Hooks() []Hook {
	return c.hooks.Commodity
}

// ContactClient is a client for the Contact schema.
type ContactClient struct {
	config
}

// NewContactClient returns a client for the Contact from the given config.
func NewContactClient(c config) *ContactClient {
	return &ContactClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `contact.Hooks(f(g(h())))`.
func (c *ContactClient) Use(hooks ...Hook) {
	c.hooks.Contact = append(c.hooks.Contact, hooks...)
}

// Create returns a builder for creating a Contact entity.
func (c *ContactClient) Create() *ContactCreate {
	mutation := newContactMutation(c.config, OpCreate)
	return &ContactCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Contact entities.
func (c *ContactClient) CreateBulk(builders ...*ContactCreate) *ContactCreateBulk {
	return &ContactCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Contact.
func (c *ContactClient) Update() *ContactUpdate {
	mutation := newContactMutation(c.config, OpUpdate)
	return &ContactUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ContactClient) UpdateOne(co *Contact) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContact(co))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ContactClient) UpdateOneID(id uint64) *ContactUpdateOne {
	mutation := newContactMutation(c.config, OpUpdateOne, withContactID(id))
	return &ContactUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Contact.
func (c *ContactClient) Delete() *ContactDelete {
	mutation := newContactMutation(c.config, OpDelete)
	return &ContactDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ContactClient) DeleteOne(co *Contact) *ContactDeleteOne {
	return c.DeleteOneID(co.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ContactClient) DeleteOneID(id uint64) *ContactDeleteOne {
	builder := c.Delete().Where(contact.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ContactDeleteOne{builder}
}

// Query returns a query builder for Contact.
func (c *ContactClient) Query() *ContactQuery {
	return &ContactQuery{
		config: c.config,
	}
}

// Get returns a Contact entity by its id.
func (c *ContactClient) Get(ctx context.Context, id uint64) (*Contact, error) {
	return c.Query().Where(contact.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ContactClient) GetX(ctx context.Context, id uint64) *Contact {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Contact.
func (c *ContactClient) QueryOwner(co *Contact) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := co.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(contact.Table, contact.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, contact.OwnerTable, contact.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(co.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ContactClient) Hooks() []Hook {
	return c.hooks.Contact
}

// CreationClient is a client for the Creation schema.
type CreationClient struct {
	config
}

// NewCreationClient returns a client for the Creation from the given config.
func NewCreationClient(c config) *CreationClient {
	return &CreationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `creation.Hooks(f(g(h())))`.
func (c *CreationClient) Use(hooks ...Hook) {
	c.hooks.Creation = append(c.hooks.Creation, hooks...)
}

// Create returns a builder for creating a Creation entity.
func (c *CreationClient) Create() *CreationCreate {
	mutation := newCreationMutation(c.config, OpCreate)
	return &CreationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Creation entities.
func (c *CreationClient) CreateBulk(builders ...*CreationCreate) *CreationCreateBulk {
	return &CreationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Creation.
func (c *CreationClient) Update() *CreationUpdate {
	mutation := newCreationMutation(c.config, OpUpdate)
	return &CreationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CreationClient) UpdateOne(cr *Creation) *CreationUpdateOne {
	mutation := newCreationMutation(c.config, OpUpdateOne, withCreation(cr))
	return &CreationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CreationClient) UpdateOneID(id uint64) *CreationUpdateOne {
	mutation := newCreationMutation(c.config, OpUpdateOne, withCreationID(id))
	return &CreationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Creation.
func (c *CreationClient) Delete() *CreationDelete {
	mutation := newCreationMutation(c.config, OpDelete)
	return &CreationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CreationClient) DeleteOne(cr *Creation) *CreationDeleteOne {
	return c.DeleteOneID(cr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CreationClient) DeleteOneID(id uint64) *CreationDeleteOne {
	builder := c.Delete().Where(creation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CreationDeleteOne{builder}
}

// Query returns a query builder for Creation.
func (c *CreationClient) Query() *CreationQuery {
	return &CreationQuery{
		config: c.config,
	}
}

// Get returns a Creation entity by its id.
func (c *CreationClient) Get(ctx context.Context, id uint64) (*Creation, error) {
	return c.Query().Where(creation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CreationClient) GetX(ctx context.Context, id uint64) *Creation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Creation.
func (c *CreationClient) QueryOwner(cr *Creation) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(creation.Table, creation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, creation.OwnerTable, creation.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(cr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CreationClient) Hooks() []Hook {
	return c.hooks.Creation
}

// DeviceClient is a client for the Device schema.
type DeviceClient struct {
	config
}

// NewDeviceClient returns a client for the Device from the given config.
func NewDeviceClient(c config) *DeviceClient {
	return &DeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `device.Hooks(f(g(h())))`.
func (c *DeviceClient) Use(hooks ...Hook) {
	c.hooks.Device = append(c.hooks.Device, hooks...)
}

// Create returns a builder for creating a Device entity.
func (c *DeviceClient) Create() *DeviceCreate {
	mutation := newDeviceMutation(c.config, OpCreate)
	return &DeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Device entities.
func (c *DeviceClient) CreateBulk(builders ...*DeviceCreate) *DeviceCreateBulk {
	return &DeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Device.
func (c *DeviceClient) Update() *DeviceUpdate {
	mutation := newDeviceMutation(c.config, OpUpdate)
	return &DeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DeviceClient) UpdateOne(d *Device) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDevice(d))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DeviceClient) UpdateOneID(id uint64) *DeviceUpdateOne {
	mutation := newDeviceMutation(c.config, OpUpdateOne, withDeviceID(id))
	return &DeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Device.
func (c *DeviceClient) Delete() *DeviceDelete {
	mutation := newDeviceMutation(c.config, OpDelete)
	return &DeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DeviceClient) DeleteOne(d *Device) *DeviceDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DeviceClient) DeleteOneID(id uint64) *DeviceDeleteOne {
	builder := c.Delete().Where(device.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DeviceDeleteOne{builder}
}

// Query returns a query builder for Device.
func (c *DeviceClient) Query() *DeviceQuery {
	return &DeviceQuery{
		config: c.config,
	}
}

// Get returns a Device entity by its id.
func (c *DeviceClient) Get(ctx context.Context, id uint64) (*Device, error) {
	return c.Query().Where(device.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DeviceClient) GetX(ctx context.Context, id uint64) *Device {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Device.
func (c *DeviceClient) QueryOwner(d *Device) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(device.Table, device.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, device.OwnerTable, device.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DeviceClient) Hooks() []Hook {
	return c.hooks.Device
}

// FeedbackClient is a client for the Feedback schema.
type FeedbackClient struct {
	config
}

// NewFeedbackClient returns a client for the Feedback from the given config.
func NewFeedbackClient(c config) *FeedbackClient {
	return &FeedbackClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `feedback.Hooks(f(g(h())))`.
func (c *FeedbackClient) Use(hooks ...Hook) {
	c.hooks.Feedback = append(c.hooks.Feedback, hooks...)
}

// Create returns a builder for creating a Feedback entity.
func (c *FeedbackClient) Create() *FeedbackCreate {
	mutation := newFeedbackMutation(c.config, OpCreate)
	return &FeedbackCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Feedback entities.
func (c *FeedbackClient) CreateBulk(builders ...*FeedbackCreate) *FeedbackCreateBulk {
	return &FeedbackCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Feedback.
func (c *FeedbackClient) Update() *FeedbackUpdate {
	mutation := newFeedbackMutation(c.config, OpUpdate)
	return &FeedbackUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FeedbackClient) UpdateOne(f *Feedback) *FeedbackUpdateOne {
	mutation := newFeedbackMutation(c.config, OpUpdateOne, withFeedback(f))
	return &FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FeedbackClient) UpdateOneID(id int) *FeedbackUpdateOne {
	mutation := newFeedbackMutation(c.config, OpUpdateOne, withFeedbackID(id))
	return &FeedbackUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Feedback.
func (c *FeedbackClient) Delete() *FeedbackDelete {
	mutation := newFeedbackMutation(c.config, OpDelete)
	return &FeedbackDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FeedbackClient) DeleteOne(f *Feedback) *FeedbackDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FeedbackClient) DeleteOneID(id int) *FeedbackDeleteOne {
	builder := c.Delete().Where(feedback.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FeedbackDeleteOne{builder}
}

// Query returns a query builder for Feedback.
func (c *FeedbackClient) Query() *FeedbackQuery {
	return &FeedbackQuery{
		config: c.config,
	}
}

// Get returns a Feedback entity by its id.
func (c *FeedbackClient) Get(ctx context.Context, id int) (*Feedback, error) {
	return c.Query().Where(feedback.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FeedbackClient) GetX(ctx context.Context, id int) *Feedback {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Feedback.
func (c *FeedbackClient) QueryOwner(f *Feedback) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(feedback.Table, feedback.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, feedback.OwnerTable, feedback.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FeedbackClient) Hooks() []Hook {
	return c.hooks.Feedback
}

// FriendshipClient is a client for the Friendship schema.
type FriendshipClient struct {
	config
}

// NewFriendshipClient returns a client for the Friendship from the given config.
func NewFriendshipClient(c config) *FriendshipClient {
	return &FriendshipClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `friendship.Hooks(f(g(h())))`.
func (c *FriendshipClient) Use(hooks ...Hook) {
	c.hooks.Friendship = append(c.hooks.Friendship, hooks...)
}

// Create returns a builder for creating a Friendship entity.
func (c *FriendshipClient) Create() *FriendshipCreate {
	mutation := newFriendshipMutation(c.config, OpCreate)
	return &FriendshipCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Friendship entities.
func (c *FriendshipClient) CreateBulk(builders ...*FriendshipCreate) *FriendshipCreateBulk {
	return &FriendshipCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Friendship.
func (c *FriendshipClient) Update() *FriendshipUpdate {
	mutation := newFriendshipMutation(c.config, OpUpdate)
	return &FriendshipUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FriendshipClient) UpdateOne(f *Friendship) *FriendshipUpdateOne {
	mutation := newFriendshipMutation(c.config, OpUpdateOne, withFriendship(f))
	return &FriendshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FriendshipClient) UpdateOneID(id int) *FriendshipUpdateOne {
	mutation := newFriendshipMutation(c.config, OpUpdateOne, withFriendshipID(id))
	return &FriendshipUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Friendship.
func (c *FriendshipClient) Delete() *FriendshipDelete {
	mutation := newFriendshipMutation(c.config, OpDelete)
	return &FriendshipDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FriendshipClient) DeleteOne(f *Friendship) *FriendshipDeleteOne {
	return c.DeleteOneID(f.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *FriendshipClient) DeleteOneID(id int) *FriendshipDeleteOne {
	builder := c.Delete().Where(friendship.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FriendshipDeleteOne{builder}
}

// Query returns a query builder for Friendship.
func (c *FriendshipClient) Query() *FriendshipQuery {
	return &FriendshipQuery{
		config: c.config,
	}
}

// Get returns a Friendship entity by its id.
func (c *FriendshipClient) Get(ctx context.Context, id int) (*Friendship, error) {
	return c.Query().Where(friendship.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FriendshipClient) GetX(ctx context.Context, id int) *Friendship {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Friendship.
func (c *FriendshipClient) QueryUser(f *Friendship) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(friendship.Table, friendship.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, friendship.UserTable, friendship.UserColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFriend queries the friend edge of a Friendship.
func (c *FriendshipClient) QueryFriend(f *Friendship) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := f.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(friendship.Table, friendship.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, friendship.FriendTable, friendship.FriendColumn),
		)
		fromV = sqlgraph.Neighbors(f.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *FriendshipClient) Hooks() []Hook {
	return c.hooks.Friendship
}

// HiddenClient is a client for the Hidden schema.
type HiddenClient struct {
	config
}

// NewHiddenClient returns a client for the Hidden from the given config.
func NewHiddenClient(c config) *HiddenClient {
	return &HiddenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `hidden.Hooks(f(g(h())))`.
func (c *HiddenClient) Use(hooks ...Hook) {
	c.hooks.Hidden = append(c.hooks.Hidden, hooks...)
}

// Create returns a builder for creating a Hidden entity.
func (c *HiddenClient) Create() *HiddenCreate {
	mutation := newHiddenMutation(c.config, OpCreate)
	return &HiddenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Hidden entities.
func (c *HiddenClient) CreateBulk(builders ...*HiddenCreate) *HiddenCreateBulk {
	return &HiddenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Hidden.
func (c *HiddenClient) Update() *HiddenUpdate {
	mutation := newHiddenMutation(c.config, OpUpdate)
	return &HiddenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *HiddenClient) UpdateOne(h *Hidden) *HiddenUpdateOne {
	mutation := newHiddenMutation(c.config, OpUpdateOne, withHidden(h))
	return &HiddenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *HiddenClient) UpdateOneID(id int) *HiddenUpdateOne {
	mutation := newHiddenMutation(c.config, OpUpdateOne, withHiddenID(id))
	return &HiddenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Hidden.
func (c *HiddenClient) Delete() *HiddenDelete {
	mutation := newHiddenMutation(c.config, OpDelete)
	return &HiddenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *HiddenClient) DeleteOne(h *Hidden) *HiddenDeleteOne {
	return c.DeleteOneID(h.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *HiddenClient) DeleteOneID(id int) *HiddenDeleteOne {
	builder := c.Delete().Where(hidden.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &HiddenDeleteOne{builder}
}

// Query returns a query builder for Hidden.
func (c *HiddenClient) Query() *HiddenQuery {
	return &HiddenQuery{
		config: c.config,
	}
}

// Get returns a Hidden entity by its id.
func (c *HiddenClient) Get(ctx context.Context, id int) (*Hidden, error) {
	return c.Query().Where(hidden.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *HiddenClient) GetX(ctx context.Context, id int) *Hidden {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Hidden.
func (c *HiddenClient) QueryOwner(h *Hidden) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := h.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(hidden.Table, hidden.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, hidden.OwnerTable, hidden.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(h.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *HiddenClient) Hooks() []Hook {
	return c.hooks.Hidden
}

// Invite_CodeClient is a client for the Invite_Code schema.
type Invite_CodeClient struct {
	config
}

// NewInvite_CodeClient returns a client for the Invite_Code from the given config.
func NewInvite_CodeClient(c config) *Invite_CodeClient {
	return &Invite_CodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invite_code.Hooks(f(g(h())))`.
func (c *Invite_CodeClient) Use(hooks ...Hook) {
	c.hooks.Invite_Code = append(c.hooks.Invite_Code, hooks...)
}

// Create returns a builder for creating a Invite_Code entity.
func (c *Invite_CodeClient) Create() *InviteCodeCreate {
	mutation := newInviteCodeMutation(c.config, OpCreate)
	return &InviteCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invite_Code entities.
func (c *Invite_CodeClient) CreateBulk(builders ...*InviteCodeCreate) *InviteCodeCreateBulk {
	return &InviteCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invite_Code.
func (c *Invite_CodeClient) Update() *InviteCodeUpdate {
	mutation := newInviteCodeMutation(c.config, OpUpdate)
	return &InviteCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *Invite_CodeClient) UpdateOne(ic *Invite_Code) *InviteCodeUpdateOne {
	mutation := newInviteCodeMutation(c.config, OpUpdateOne, withInvite_Code(ic))
	return &InviteCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *Invite_CodeClient) UpdateOneID(id int) *InviteCodeUpdateOne {
	mutation := newInviteCodeMutation(c.config, OpUpdateOne, withInvite_CodeID(id))
	return &InviteCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invite_Code.
func (c *Invite_CodeClient) Delete() *InviteCodeDelete {
	mutation := newInviteCodeMutation(c.config, OpDelete)
	return &InviteCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *Invite_CodeClient) DeleteOne(ic *Invite_Code) *InviteCodeDeleteOne {
	return c.DeleteOneID(ic.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *Invite_CodeClient) DeleteOneID(id int) *InviteCodeDeleteOne {
	builder := c.Delete().Where(invite_code.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InviteCodeDeleteOne{builder}
}

// Query returns a query builder for Invite_Code.
func (c *Invite_CodeClient) Query() *InviteCodeQuery {
	return &InviteCodeQuery{
		config: c.config,
	}
}

// Get returns a Invite_Code entity by its id.
func (c *Invite_CodeClient) Get(ctx context.Context, id int) (*Invite_Code, error) {
	return c.Query().Where(invite_code.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *Invite_CodeClient) GetX(ctx context.Context, id int) *Invite_Code {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Invite_Code.
func (c *Invite_CodeClient) QueryOwner(ic *Invite_Code) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ic.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invite_code.Table, invite_code.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invite_code.OwnerTable, invite_code.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ic.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *Invite_CodeClient) Hooks() []Hook {
	return c.hooks.Invite_Code
}

// JoinClient is a client for the Join schema.
type JoinClient struct {
	config
}

// NewJoinClient returns a client for the Join from the given config.
func NewJoinClient(c config) *JoinClient {
	return &JoinClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `join.Hooks(f(g(h())))`.
func (c *JoinClient) Use(hooks ...Hook) {
	c.hooks.Join = append(c.hooks.Join, hooks...)
}

// Create returns a builder for creating a Join entity.
func (c *JoinClient) Create() *JoinCreate {
	mutation := newJoinMutation(c.config, OpCreate)
	return &JoinCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Join entities.
func (c *JoinClient) CreateBulk(builders ...*JoinCreate) *JoinCreateBulk {
	return &JoinCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Join.
func (c *JoinClient) Update() *JoinUpdate {
	mutation := newJoinMutation(c.config, OpUpdate)
	return &JoinUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *JoinClient) UpdateOne(j *Join) *JoinUpdateOne {
	mutation := newJoinMutation(c.config, OpUpdateOne, withJoin(j))
	return &JoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *JoinClient) UpdateOneID(id int) *JoinUpdateOne {
	mutation := newJoinMutation(c.config, OpUpdateOne, withJoinID(id))
	return &JoinUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Join.
func (c *JoinClient) Delete() *JoinDelete {
	mutation := newJoinMutation(c.config, OpDelete)
	return &JoinDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *JoinClient) DeleteOne(j *Join) *JoinDeleteOne {
	return c.DeleteOneID(j.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *JoinClient) DeleteOneID(id int) *JoinDeleteOne {
	builder := c.Delete().Where(join.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &JoinDeleteOne{builder}
}

// Query returns a query builder for Join.
func (c *JoinClient) Query() *JoinQuery {
	return &JoinQuery{
		config: c.config,
	}
}

// Get returns a Join entity by its id.
func (c *JoinClient) Get(ctx context.Context, id int) (*Join, error) {
	return c.Query().Where(join.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *JoinClient) GetX(ctx context.Context, id int) *Join {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Join.
func (c *JoinClient) QueryUser(j *Join) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := j.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(join.Table, join.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, join.UserTable, join.UserColumn),
		)
		fromV = sqlgraph.Neighbors(j.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCsField queries the cs_field edge of a Join.
func (c *JoinClient) QueryCsField(j *Join) *CSFieldQuery {
	query := &CSFieldQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := j.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(join.Table, join.FieldID, id),
			sqlgraph.To(csfield.Table, csfield.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, join.CsFieldTable, join.CsFieldColumn),
		)
		fromV = sqlgraph.Neighbors(j.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *JoinClient) Hooks() []Hook {
	return c.hooks.Join
}

// MaskClient is a client for the Mask schema.
type MaskClient struct {
	config
}

// NewMaskClient returns a client for the Mask from the given config.
func NewMaskClient(c config) *MaskClient {
	return &MaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mask.Hooks(f(g(h())))`.
func (c *MaskClient) Use(hooks ...Hook) {
	c.hooks.Mask = append(c.hooks.Mask, hooks...)
}

// Create returns a builder for creating a Mask entity.
func (c *MaskClient) Create() *MaskCreate {
	mutation := newMaskMutation(c.config, OpCreate)
	return &MaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Mask entities.
func (c *MaskClient) CreateBulk(builders ...*MaskCreate) *MaskCreateBulk {
	return &MaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Mask.
func (c *MaskClient) Update() *MaskUpdate {
	mutation := newMaskMutation(c.config, OpUpdate)
	return &MaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MaskClient) UpdateOne(m *Mask) *MaskUpdateOne {
	mutation := newMaskMutation(c.config, OpUpdateOne, withMask(m))
	return &MaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MaskClient) UpdateOneID(id uint64) *MaskUpdateOne {
	mutation := newMaskMutation(c.config, OpUpdateOne, withMaskID(id))
	return &MaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Mask.
func (c *MaskClient) Delete() *MaskDelete {
	mutation := newMaskMutation(c.config, OpDelete)
	return &MaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MaskClient) DeleteOne(m *Mask) *MaskDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MaskClient) DeleteOneID(id uint64) *MaskDeleteOne {
	builder := c.Delete().Where(mask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MaskDeleteOne{builder}
}

// Query returns a query builder for Mask.
func (c *MaskClient) Query() *MaskQuery {
	return &MaskQuery{
		config: c.config,
	}
}

// Get returns a Mask entity by its id.
func (c *MaskClient) Get(ctx context.Context, id uint64) (*Mask, error) {
	return c.Query().Where(mask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MaskClient) GetX(ctx context.Context, id uint64) *Mask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBundle queries the bundle edge of a Mask.
func (c *MaskClient) QueryBundle(m *Mask) *BundleQuery {
	query := &BundleQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mask.Table, mask.FieldID, id),
			sqlgraph.To(bundle.Table, bundle.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, mask.BundleTable, mask.BundleColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOwner queries the owner edge of a Mask.
func (c *MaskClient) QueryOwner(m *Mask) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(mask.Table, mask.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, mask.OwnerTable, mask.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MaskClient) Hooks() []Hook {
	return c.hooks.Mask
}

// MessageClient is a client for the Message schema.
type MessageClient struct {
	config
}

// NewMessageClient returns a client for the Message from the given config.
func NewMessageClient(c config) *MessageClient {
	return &MessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `message.Hooks(f(g(h())))`.
func (c *MessageClient) Use(hooks ...Hook) {
	c.hooks.Message = append(c.hooks.Message, hooks...)
}

// Create returns a builder for creating a Message entity.
func (c *MessageClient) Create() *MessageCreate {
	mutation := newMessageMutation(c.config, OpCreate)
	return &MessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Message entities.
func (c *MessageClient) CreateBulk(builders ...*MessageCreate) *MessageCreateBulk {
	return &MessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Message.
func (c *MessageClient) Update() *MessageUpdate {
	mutation := newMessageMutation(c.config, OpUpdate)
	return &MessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageClient) UpdateOne(m *Message) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessage(m))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageClient) UpdateOneID(id uint64) *MessageUpdateOne {
	mutation := newMessageMutation(c.config, OpUpdateOne, withMessageID(id))
	return &MessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Message.
func (c *MessageClient) Delete() *MessageDelete {
	mutation := newMessageMutation(c.config, OpDelete)
	return &MessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageClient) DeleteOne(m *Message) *MessageDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageClient) DeleteOneID(id uint64) *MessageDeleteOne {
	builder := c.Delete().Where(message.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageDeleteOne{builder}
}

// Query returns a query builder for Message.
func (c *MessageClient) Query() *MessageQuery {
	return &MessageQuery{
		config: c.config,
	}
}

// Get returns a Message entity by its id.
func (c *MessageClient) Get(ctx context.Context, id uint64) (*Message, error) {
	return c.Query().Where(message.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageClient) GetX(ctx context.Context, id uint64) *Message {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Message.
func (c *MessageClient) QueryOwner(m *Message) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(message.Table, message.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, message.OwnerTable, message.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MessageClient) Hooks() []Hook {
	return c.hooks.Message
}

// NFTClient is a client for the NFT schema.
type NFTClient struct {
	config
}

// NewNFTClient returns a client for the NFT from the given config.
func NewNFTClient(c config) *NFTClient {
	return &NFTClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nft.Hooks(f(g(h())))`.
func (c *NFTClient) Use(hooks ...Hook) {
	c.hooks.NFT = append(c.hooks.NFT, hooks...)
}

// Create returns a builder for creating a NFT entity.
func (c *NFTClient) Create() *NFTCreate {
	mutation := newNFTMutation(c.config, OpCreate)
	return &NFTCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NFT entities.
func (c *NFTClient) CreateBulk(builders ...*NFTCreate) *NFTCreateBulk {
	return &NFTCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NFT.
func (c *NFTClient) Update() *NFTUpdate {
	mutation := newNFTMutation(c.config, OpUpdate)
	return &NFTUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NFTClient) UpdateOne(n *NFT) *NFTUpdateOne {
	mutation := newNFTMutation(c.config, OpUpdateOne, withNFT(n))
	return &NFTUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NFTClient) UpdateOneID(id uint64) *NFTUpdateOne {
	mutation := newNFTMutation(c.config, OpUpdateOne, withNFTID(id))
	return &NFTUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NFT.
func (c *NFTClient) Delete() *NFTDelete {
	mutation := newNFTMutation(c.config, OpDelete)
	return &NFTDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NFTClient) DeleteOne(n *NFT) *NFTDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NFTClient) DeleteOneID(id uint64) *NFTDeleteOne {
	builder := c.Delete().Where(nft.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NFTDeleteOne{builder}
}

// Query returns a query builder for NFT.
func (c *NFTClient) Query() *NFTQuery {
	return &NFTQuery{
		config: c.config,
	}
}

// Get returns a NFT entity by its id.
func (c *NFTClient) Get(ctx context.Context, id uint64) (*NFT, error) {
	return c.Query().Where(nft.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NFTClient) GetX(ctx context.Context, id uint64) *NFT {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a NFT.
func (c *NFTClient) QueryOwner(n *NFT) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nft.Table, nft.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, nft.OwnerTable, nft.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NFTClient) Hooks() []Hook {
	return c.hooks.NFT
}

// ReactionClient is a client for the Reaction schema.
type ReactionClient struct {
	config
}

// NewReactionClient returns a client for the Reaction from the given config.
func NewReactionClient(c config) *ReactionClient {
	return &ReactionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `reaction.Hooks(f(g(h())))`.
func (c *ReactionClient) Use(hooks ...Hook) {
	c.hooks.Reaction = append(c.hooks.Reaction, hooks...)
}

// Create returns a builder for creating a Reaction entity.
func (c *ReactionClient) Create() *ReactionCreate {
	mutation := newReactionMutation(c.config, OpCreate)
	return &ReactionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Reaction entities.
func (c *ReactionClient) CreateBulk(builders ...*ReactionCreate) *ReactionCreateBulk {
	return &ReactionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Reaction.
func (c *ReactionClient) Update() *ReactionUpdate {
	mutation := newReactionMutation(c.config, OpUpdate)
	return &ReactionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ReactionClient) UpdateOne(r *Reaction) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReaction(r))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ReactionClient) UpdateOneID(id int) *ReactionUpdateOne {
	mutation := newReactionMutation(c.config, OpUpdateOne, withReactionID(id))
	return &ReactionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Reaction.
func (c *ReactionClient) Delete() *ReactionDelete {
	mutation := newReactionMutation(c.config, OpDelete)
	return &ReactionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ReactionClient) DeleteOne(r *Reaction) *ReactionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ReactionClient) DeleteOneID(id int) *ReactionDeleteOne {
	builder := c.Delete().Where(reaction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ReactionDeleteOne{builder}
}

// Query returns a query builder for Reaction.
func (c *ReactionClient) Query() *ReactionQuery {
	return &ReactionQuery{
		config: c.config,
	}
}

// Get returns a Reaction entity by its id.
func (c *ReactionClient) Get(ctx context.Context, id int) (*Reaction, error) {
	return c.Query().Where(reaction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ReactionClient) GetX(ctx context.Context, id int) *Reaction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTimedew queries the timedew edge of a Reaction.
func (c *ReactionClient) QueryTimedew(r *Reaction) *TimeDewQuery {
	query := &TimeDewQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reaction.Table, reaction.FieldID, id),
			sqlgraph.To(timedew.Table, timedew.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, reaction.TimedewTable, reaction.TimedewColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Reaction.
func (c *ReactionClient) QueryUser(r *Reaction) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(reaction.Table, reaction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, reaction.UserTable, reaction.UserColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ReactionClient) Hooks() []Hook {
	return c.hooks.Reaction
}

// RuleClient is a client for the Rule schema.
type RuleClient struct {
	config
}

// NewRuleClient returns a client for the Rule from the given config.
func NewRuleClient(c config) *RuleClient {
	return &RuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rule.Hooks(f(g(h())))`.
func (c *RuleClient) Use(hooks ...Hook) {
	c.hooks.Rule = append(c.hooks.Rule, hooks...)
}

// Create returns a builder for creating a Rule entity.
func (c *RuleClient) Create() *RuleCreate {
	mutation := newRuleMutation(c.config, OpCreate)
	return &RuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Rule entities.
func (c *RuleClient) CreateBulk(builders ...*RuleCreate) *RuleCreateBulk {
	return &RuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Rule.
func (c *RuleClient) Update() *RuleUpdate {
	mutation := newRuleMutation(c.config, OpUpdate)
	return &RuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RuleClient) UpdateOne(r *Rule) *RuleUpdateOne {
	mutation := newRuleMutation(c.config, OpUpdateOne, withRule(r))
	return &RuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RuleClient) UpdateOneID(id uint64) *RuleUpdateOne {
	mutation := newRuleMutation(c.config, OpUpdateOne, withRuleID(id))
	return &RuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Rule.
func (c *RuleClient) Delete() *RuleDelete {
	mutation := newRuleMutation(c.config, OpDelete)
	return &RuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RuleClient) DeleteOne(r *Rule) *RuleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RuleClient) DeleteOneID(id uint64) *RuleDeleteOne {
	builder := c.Delete().Where(rule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RuleDeleteOne{builder}
}

// Query returns a query builder for Rule.
func (c *RuleClient) Query() *RuleQuery {
	return &RuleQuery{
		config: c.config,
	}
}

// Get returns a Rule entity by its id.
func (c *RuleClient) Get(ctx context.Context, id uint64) (*Rule, error) {
	return c.Query().Where(rule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RuleClient) GetX(ctx context.Context, id uint64) *Rule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsed queries the used edge of a Rule.
func (c *RuleClient) QueryUsed(r *Rule) *CardQuery {
	query := &CardQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rule.Table, rule.FieldID, id),
			sqlgraph.To(card.Table, card.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, rule.UsedTable, rule.UsedPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RuleClient) Hooks() []Hook {
	return c.hooks.Rule
}

// SettingClient is a client for the Setting schema.
type SettingClient struct {
	config
}

// NewSettingClient returns a client for the Setting from the given config.
func NewSettingClient(c config) *SettingClient {
	return &SettingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `setting.Hooks(f(g(h())))`.
func (c *SettingClient) Use(hooks ...Hook) {
	c.hooks.Setting = append(c.hooks.Setting, hooks...)
}

// Create returns a builder for creating a Setting entity.
func (c *SettingClient) Create() *SettingCreate {
	mutation := newSettingMutation(c.config, OpCreate)
	return &SettingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Setting entities.
func (c *SettingClient) CreateBulk(builders ...*SettingCreate) *SettingCreateBulk {
	return &SettingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Setting.
func (c *SettingClient) Update() *SettingUpdate {
	mutation := newSettingMutation(c.config, OpUpdate)
	return &SettingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SettingClient) UpdateOne(s *Setting) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSetting(s))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SettingClient) UpdateOneID(id uint64) *SettingUpdateOne {
	mutation := newSettingMutation(c.config, OpUpdateOne, withSettingID(id))
	return &SettingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Setting.
func (c *SettingClient) Delete() *SettingDelete {
	mutation := newSettingMutation(c.config, OpDelete)
	return &SettingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SettingClient) DeleteOne(s *Setting) *SettingDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SettingClient) DeleteOneID(id uint64) *SettingDeleteOne {
	builder := c.Delete().Where(setting.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SettingDeleteOne{builder}
}

// Query returns a query builder for Setting.
func (c *SettingClient) Query() *SettingQuery {
	return &SettingQuery{
		config: c.config,
	}
}

// Get returns a Setting entity by its id.
func (c *SettingClient) Get(ctx context.Context, id uint64) (*Setting, error) {
	return c.Query().Where(setting.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SettingClient) GetX(ctx context.Context, id uint64) *Setting {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Setting.
func (c *SettingClient) QueryOwner(s *Setting) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(setting.Table, setting.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, setting.OwnerTable, setting.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SettingClient) Hooks() []Hook {
	return c.hooks.Setting
}

// StreamClient is a client for the Stream schema.
type StreamClient struct {
	config
}

// NewStreamClient returns a client for the Stream from the given config.
func NewStreamClient(c config) *StreamClient {
	return &StreamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `stream.Hooks(f(g(h())))`.
func (c *StreamClient) Use(hooks ...Hook) {
	c.hooks.Stream = append(c.hooks.Stream, hooks...)
}

// Create returns a builder for creating a Stream entity.
func (c *StreamClient) Create() *StreamCreate {
	mutation := newStreamMutation(c.config, OpCreate)
	return &StreamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Stream entities.
func (c *StreamClient) CreateBulk(builders ...*StreamCreate) *StreamCreateBulk {
	return &StreamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Stream.
func (c *StreamClient) Update() *StreamUpdate {
	mutation := newStreamMutation(c.config, OpUpdate)
	return &StreamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StreamClient) UpdateOne(s *Stream) *StreamUpdateOne {
	mutation := newStreamMutation(c.config, OpUpdateOne, withStream(s))
	return &StreamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StreamClient) UpdateOneID(id uint64) *StreamUpdateOne {
	mutation := newStreamMutation(c.config, OpUpdateOne, withStreamID(id))
	return &StreamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Stream.
func (c *StreamClient) Delete() *StreamDelete {
	mutation := newStreamMutation(c.config, OpDelete)
	return &StreamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StreamClient) DeleteOne(s *Stream) *StreamDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StreamClient) DeleteOneID(id uint64) *StreamDeleteOne {
	builder := c.Delete().Where(stream.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StreamDeleteOne{builder}
}

// Query returns a query builder for Stream.
func (c *StreamClient) Query() *StreamQuery {
	return &StreamQuery{
		config: c.config,
	}
}

// Get returns a Stream entity by its id.
func (c *StreamClient) Get(ctx context.Context, id uint64) (*Stream, error) {
	return c.Query().Where(stream.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StreamClient) GetX(ctx context.Context, id uint64) *Stream {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a Stream.
func (c *StreamClient) QueryOwner(s *Stream) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(stream.Table, stream.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, stream.OwnerTable, stream.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StreamClient) Hooks() []Hook {
	return c.hooks.Stream
}

// TimeDewClient is a client for the TimeDew schema.
type TimeDewClient struct {
	config
}

// NewTimeDewClient returns a client for the TimeDew from the given config.
func NewTimeDewClient(c config) *TimeDewClient {
	return &TimeDewClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timedew.Hooks(f(g(h())))`.
func (c *TimeDewClient) Use(hooks ...Hook) {
	c.hooks.TimeDew = append(c.hooks.TimeDew, hooks...)
}

// Create returns a builder for creating a TimeDew entity.
func (c *TimeDewClient) Create() *TimeDewCreate {
	mutation := newTimeDewMutation(c.config, OpCreate)
	return &TimeDewCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TimeDew entities.
func (c *TimeDewClient) CreateBulk(builders ...*TimeDewCreate) *TimeDewCreateBulk {
	return &TimeDewCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TimeDew.
func (c *TimeDewClient) Update() *TimeDewUpdate {
	mutation := newTimeDewMutation(c.config, OpUpdate)
	return &TimeDewUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimeDewClient) UpdateOne(td *TimeDew) *TimeDewUpdateOne {
	mutation := newTimeDewMutation(c.config, OpUpdateOne, withTimeDew(td))
	return &TimeDewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimeDewClient) UpdateOneID(id uint64) *TimeDewUpdateOne {
	mutation := newTimeDewMutation(c.config, OpUpdateOne, withTimeDewID(id))
	return &TimeDewUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TimeDew.
func (c *TimeDewClient) Delete() *TimeDewDelete {
	mutation := newTimeDewMutation(c.config, OpDelete)
	return &TimeDewDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TimeDewClient) DeleteOne(td *TimeDew) *TimeDewDeleteOne {
	return c.DeleteOneID(td.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TimeDewClient) DeleteOneID(id uint64) *TimeDewDeleteOne {
	builder := c.Delete().Where(timedew.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimeDewDeleteOne{builder}
}

// Query returns a query builder for TimeDew.
func (c *TimeDewClient) Query() *TimeDewQuery {
	return &TimeDewQuery{
		config: c.config,
	}
}

// Get returns a TimeDew entity by its id.
func (c *TimeDewClient) Get(ctx context.Context, id uint64) (*TimeDew, error) {
	return c.Query().Where(timedew.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimeDewClient) GetX(ctx context.Context, id uint64) *TimeDew {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a TimeDew.
func (c *TimeDewClient) QueryOwner(td *TimeDew) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timedew.Table, timedew.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, timedew.OwnerTable, timedew.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReactionUser queries the reaction_user edge of a TimeDew.
func (c *TimeDewClient) QueryReactionUser(td *TimeDew) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timedew.Table, timedew.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, timedew.ReactionUserTable, timedew.ReactionUserPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReactions queries the reactions edge of a TimeDew.
func (c *TimeDewClient) QueryReactions(td *TimeDew) *ReactionQuery {
	query := &ReactionQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := td.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(timedew.Table, timedew.FieldID, id),
			sqlgraph.To(reaction.Table, reaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, timedew.ReactionsTable, timedew.ReactionsColumn),
		)
		fromV = sqlgraph.Neighbors(td.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TimeDewClient) Hooks() []Hook {
	return c.hooks.TimeDew
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id uint64) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id uint64) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id uint64) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id uint64) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserAuth queries the user_auth edge of a User.
func (c *UserClient) QueryUserAuth(u *User) *UserAuthQuery {
	query := &UserAuthQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user_auth.Table, user_auth.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserAuthTable, user.UserAuthColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCard queries the card edge of a User.
func (c *UserClient) QueryCard(u *User) *CardQuery {
	query := &CardQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(card.Table, card.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CardTable, user.CardColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMessage queries the message edge of a User.
func (c *UserClient) QueryMessage(u *User) *MessageQuery {
	query := &MessageQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(message.Table, message.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MessageTable, user.MessageColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryDevice queries the device edge of a User.
func (c *UserClient) QueryDevice(u *User) *DeviceQuery {
	query := &DeviceQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(device.Table, device.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DeviceTable, user.DeviceColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJoinedCsfield queries the joined_csfield edge of a User.
func (c *UserClient) QueryJoinedCsfield(u *User) *CSFieldQuery {
	query := &CSFieldQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(csfield.Table, csfield.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.JoinedCsfieldTable, user.JoinedCsfieldPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFriends queries the friends edge of a User.
func (c *UserClient) QueryFriends(u *User) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, user.FriendsTable, user.FriendsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHidden queries the hidden edge of a User.
func (c *UserClient) QueryHidden(u *User) *HiddenQuery {
	query := &HiddenQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(hidden.Table, hidden.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.HiddenTable, user.HiddenColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryHistory queries the history edge of a User.
func (c *UserClient) QueryHistory(u *User) *UserHistoryQuery {
	query := &UserHistoryQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(user_history.Table, user_history.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.HistoryTable, user.HistoryColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryToken queries the token edge of a User.
func (c *UserClient) QueryToken(u *User) *AgoraTokenQuery {
	query := &AgoraTokenQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(agora_token.Table, agora_token.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TokenTable, user.TokenColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreation queries the creation edge of a User.
func (c *UserClient) QueryCreation(u *User) *CreationQuery {
	query := &CreationQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(creation.Table, creation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreationTable, user.CreationColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContact queries the contact edge of a User.
func (c *UserClient) QueryContact(u *User) *ContactQuery {
	query := &ContactQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(contact.Table, contact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ContactTable, user.ContactColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySetting queries the setting edge of a User.
func (c *UserClient) QuerySetting(u *User) *SettingQuery {
	query := &SettingQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(setting.Table, setting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SettingTable, user.SettingColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNft queries the nft edge of a User.
func (c *UserClient) QueryNft(u *User) *NFTQuery {
	query := &NFTQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(nft.Table, nft.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.NftTable, user.NftColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStream queries the stream edge of a User.
func (c *UserClient) QueryStream(u *User) *StreamQuery {
	query := &StreamQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(stream.Table, stream.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.StreamTable, user.StreamColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMask queries the mask edge of a User.
func (c *UserClient) QueryMask(u *User) *MaskQuery {
	query := &MaskQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(mask.Table, mask.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.MaskTable, user.MaskColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTimedew queries the timedew edge of a User.
func (c *UserClient) QueryTimedew(u *User) *TimeDewQuery {
	query := &TimeDewQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(timedew.Table, timedew.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TimedewTable, user.TimedewColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCollection queries the collection edge of a User.
func (c *UserClient) QueryCollection(u *User) *CollectionQuery {
	query := &CollectionQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(collection.Table, collection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CollectionTable, user.CollectionColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInviteCode queries the invite_code edge of a User.
func (c *UserClient) QueryInviteCode(u *User) *InviteCodeQuery {
	query := &InviteCodeQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(invite_code.Table, invite_code.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InviteCodeTable, user.InviteCodeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFeedback queries the feedback edge of a User.
func (c *UserClient) QueryFeedback(u *User) *FeedbackQuery {
	query := &FeedbackQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(feedback.Table, feedback.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.FeedbackTable, user.FeedbackColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReactionTimedew queries the reaction_timedew edge of a User.
func (c *UserClient) QueryReactionTimedew(u *User) *TimeDewQuery {
	query := &TimeDewQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(timedew.Table, timedew.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.ReactionTimedewTable, user.ReactionTimedewPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryJoins queries the joins edge of a User.
func (c *UserClient) QueryJoins(u *User) *JoinQuery {
	query := &JoinQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(join.Table, join.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.JoinsTable, user.JoinsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryFriendships queries the friendships edge of a User.
func (c *UserClient) QueryFriendships(u *User) *FriendshipQuery {
	query := &FriendshipQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(friendship.Table, friendship.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.FriendshipsTable, user.FriendshipsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReactions queries the reactions edge of a User.
func (c *UserClient) QueryReactions(u *User) *ReactionQuery {
	query := &ReactionQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(reaction.Table, reaction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.ReactionsTable, user.ReactionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// User_authClient is a client for the User_auth schema.
type User_authClient struct {
	config
}

// NewUser_authClient returns a client for the User_auth from the given config.
func NewUser_authClient(c config) *User_authClient {
	return &User_authClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user_auth.Hooks(f(g(h())))`.
func (c *User_authClient) Use(hooks ...Hook) {
	c.hooks.User_auth = append(c.hooks.User_auth, hooks...)
}

// Create returns a builder for creating a User_auth entity.
func (c *User_authClient) Create() *UserAuthCreate {
	mutation := newUserAuthMutation(c.config, OpCreate)
	return &UserAuthCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User_auth entities.
func (c *User_authClient) CreateBulk(builders ...*UserAuthCreate) *UserAuthCreateBulk {
	return &UserAuthCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User_auth.
func (c *User_authClient) Update() *UserAuthUpdate {
	mutation := newUserAuthMutation(c.config, OpUpdate)
	return &UserAuthUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *User_authClient) UpdateOne(ua *User_auth) *UserAuthUpdateOne {
	mutation := newUserAuthMutation(c.config, OpUpdateOne, withUser_auth(ua))
	return &UserAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *User_authClient) UpdateOneID(id int) *UserAuthUpdateOne {
	mutation := newUserAuthMutation(c.config, OpUpdateOne, withUser_authID(id))
	return &UserAuthUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User_auth.
func (c *User_authClient) Delete() *UserAuthDelete {
	mutation := newUserAuthMutation(c.config, OpDelete)
	return &UserAuthDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *User_authClient) DeleteOne(ua *User_auth) *UserAuthDeleteOne {
	return c.DeleteOneID(ua.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *User_authClient) DeleteOneID(id int) *UserAuthDeleteOne {
	builder := c.Delete().Where(user_auth.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserAuthDeleteOne{builder}
}

// Query returns a query builder for User_auth.
func (c *User_authClient) Query() *UserAuthQuery {
	return &UserAuthQuery{
		config: c.config,
	}
}

// Get returns a User_auth entity by its id.
func (c *User_authClient) Get(ctx context.Context, id int) (*User_auth, error) {
	return c.Query().Where(user_auth.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *User_authClient) GetX(ctx context.Context, id int) *User_auth {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a User_auth.
func (c *User_authClient) QueryOwner(ua *User_auth) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ua.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user_auth.Table, user_auth.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user_auth.OwnerTable, user_auth.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(ua.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *User_authClient) Hooks() []Hook {
	return c.hooks.User_auth
}

// User_historyClient is a client for the User_history schema.
type User_historyClient struct {
	config
}

// NewUser_historyClient returns a client for the User_history from the given config.
func NewUser_historyClient(c config) *User_historyClient {
	return &User_historyClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user_history.Hooks(f(g(h())))`.
func (c *User_historyClient) Use(hooks ...Hook) {
	c.hooks.User_history = append(c.hooks.User_history, hooks...)
}

// Create returns a builder for creating a User_history entity.
func (c *User_historyClient) Create() *UserHistoryCreate {
	mutation := newUserHistoryMutation(c.config, OpCreate)
	return &UserHistoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User_history entities.
func (c *User_historyClient) CreateBulk(builders ...*UserHistoryCreate) *UserHistoryCreateBulk {
	return &UserHistoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User_history.
func (c *User_historyClient) Update() *UserHistoryUpdate {
	mutation := newUserHistoryMutation(c.config, OpUpdate)
	return &UserHistoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *User_historyClient) UpdateOne(uh *User_history) *UserHistoryUpdateOne {
	mutation := newUserHistoryMutation(c.config, OpUpdateOne, withUser_history(uh))
	return &UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *User_historyClient) UpdateOneID(id uint64) *UserHistoryUpdateOne {
	mutation := newUserHistoryMutation(c.config, OpUpdateOne, withUser_historyID(id))
	return &UserHistoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User_history.
func (c *User_historyClient) Delete() *UserHistoryDelete {
	mutation := newUserHistoryMutation(c.config, OpDelete)
	return &UserHistoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *User_historyClient) DeleteOne(uh *User_history) *UserHistoryDeleteOne {
	return c.DeleteOneID(uh.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *User_historyClient) DeleteOneID(id uint64) *UserHistoryDeleteOne {
	builder := c.Delete().Where(user_history.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserHistoryDeleteOne{builder}
}

// Query returns a query builder for User_history.
func (c *User_historyClient) Query() *UserHistoryQuery {
	return &UserHistoryQuery{
		config: c.config,
	}
}

// Get returns a User_history entity by its id.
func (c *User_historyClient) Get(ctx context.Context, id uint64) (*User_history, error) {
	return c.Query().Where(user_history.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *User_historyClient) GetX(ctx context.Context, id uint64) *User_history {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a User_history.
func (c *User_historyClient) QueryOwner(uh *User_history) *UserQuery {
	query := &UserQuery{config: c.config}
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uh.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user_history.Table, user_history.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, user_history.OwnerTable, user_history.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(uh.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *User_historyClient) Hooks() []Hook {
	return c.hooks.User_history
}
