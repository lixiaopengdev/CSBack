// Code generated by ent, DO NOT EDIT.

package ent

import (
	"CSBackendTmp/ent/agora_token"
	"CSBackendTmp/ent/bundle"
	"CSBackendTmp/ent/card"
	"CSBackendTmp/ent/collection"
	"CSBackendTmp/ent/commodity"
	"CSBackendTmp/ent/contact"
	"CSBackendTmp/ent/creation"
	"CSBackendTmp/ent/csfield"
	"CSBackendTmp/ent/device"
	"CSBackendTmp/ent/feedback"
	"CSBackendTmp/ent/friendship"
	"CSBackendTmp/ent/hidden"
	"CSBackendTmp/ent/invite_code"
	"CSBackendTmp/ent/join"
	"CSBackendTmp/ent/mask"
	"CSBackendTmp/ent/message"
	"CSBackendTmp/ent/nft"
	"CSBackendTmp/ent/predicate"
	"CSBackendTmp/ent/reaction"
	"CSBackendTmp/ent/rule"
	"CSBackendTmp/ent/setting"
	"CSBackendTmp/ent/stream"
	"CSBackendTmp/ent/timedew"
	"CSBackendTmp/ent/user"
	"CSBackendTmp/ent/user_auth"
	"CSBackendTmp/ent/user_history"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgora_token  = "Agora_token"
	TypeBundle       = "Bundle"
	TypeCSField      = "CSField"
	TypeCard         = "Card"
	TypeCollection   = "Collection"
	TypeCommodity    = "Commodity"
	TypeContact      = "Contact"
	TypeCreation     = "Creation"
	TypeDevice       = "Device"
	TypeFeedback     = "Feedback"
	TypeFriendship   = "Friendship"
	TypeHidden       = "Hidden"
	TypeInvite_Code  = "Invite_Code"
	TypeJoin         = "Join"
	TypeMask         = "Mask"
	TypeMessage      = "Message"
	TypeNFT          = "NFT"
	TypeReaction     = "Reaction"
	TypeRule         = "Rule"
	TypeSetting      = "Setting"
	TypeStream       = "Stream"
	TypeTimeDew      = "TimeDew"
	TypeUser         = "User"
	TypeUser_auth    = "User_auth"
	TypeUser_history = "User_history"
)

// AgoraTokenMutation represents an operation that mutates the Agora_token nodes in the graph.
type AgoraTokenMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	token         *string
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Agora_token, error)
	predicates    []predicate.Agora_token
}

var _ ent.Mutation = (*AgoraTokenMutation)(nil)

// agoraTokenOption allows management of the mutation configuration using functional options.
type agoraTokenOption func(*AgoraTokenMutation)

// newAgoraTokenMutation creates new mutation for the Agora_token entity.
func newAgoraTokenMutation(c config, op Op, opts ...agoraTokenOption) *AgoraTokenMutation {
	m := &AgoraTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAgora_token,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgora_tokenID sets the ID field of the mutation.
func withAgora_tokenID(id uint64) agoraTokenOption {
	return func(m *AgoraTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Agora_token
		)
		m.oldValue = func(ctx context.Context) (*Agora_token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agora_token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgora_token sets the old Agora_token of the mutation.
func withAgora_token(node *Agora_token) agoraTokenOption {
	return func(m *AgoraTokenMutation) {
		m.oldValue = func(context.Context) (*Agora_token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgoraTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgoraTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agora_token entities.
func (m *AgoraTokenMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgoraTokenMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgoraTokenMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agora_token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *AgoraTokenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AgoraTokenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Agora_token entity.
// If the Agora_token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgoraTokenMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AgoraTokenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AgoraTokenMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AgoraTokenMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Agora_token entity.
// If the Agora_token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgoraTokenMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AgoraTokenMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetToken sets the "token" field.
func (m *AgoraTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *AgoraTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Agora_token entity.
// If the Agora_token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgoraTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *AgoraTokenMutation) ResetToken() {
	m.token = nil
}

// SetUserID sets the "user_id" field.
func (m *AgoraTokenMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AgoraTokenMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Agora_token entity.
// If the Agora_token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgoraTokenMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AgoraTokenMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AgoraTokenMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AgoraTokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AgoraTokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AgoraTokenMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AgoraTokenMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AgoraTokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the AgoraTokenMutation builder.
func (m *AgoraTokenMutation) Where(ps ...predicate.Agora_token) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AgoraTokenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agora_token).
func (m *AgoraTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgoraTokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, agora_token.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, agora_token.FieldUpdateTime)
	}
	if m.token != nil {
		fields = append(fields, agora_token.FieldToken)
	}
	if m.owner != nil {
		fields = append(fields, agora_token.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgoraTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agora_token.FieldCreateTime:
		return m.CreateTime()
	case agora_token.FieldUpdateTime:
		return m.UpdateTime()
	case agora_token.FieldToken:
		return m.Token()
	case agora_token.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgoraTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agora_token.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case agora_token.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case agora_token.FieldToken:
		return m.OldToken(ctx)
	case agora_token.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Agora_token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgoraTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agora_token.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case agora_token.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case agora_token.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case agora_token.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Agora_token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgoraTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgoraTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgoraTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agora_token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgoraTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgoraTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgoraTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Agora_token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgoraTokenMutation) ResetField(name string) error {
	switch name {
	case agora_token.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case agora_token.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case agora_token.FieldToken:
		m.ResetToken()
		return nil
	case agora_token.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Agora_token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgoraTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, agora_token.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgoraTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agora_token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgoraTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgoraTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgoraTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, agora_token.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgoraTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case agora_token.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgoraTokenMutation) ClearEdge(name string) error {
	switch name {
	case agora_token.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Agora_token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgoraTokenMutation) ResetEdge(name string) error {
	switch name {
	case agora_token.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Agora_token edge %s", name)
}

// BundleMutation represents an operation that mutates the Bundle nodes in the graph.
type BundleMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	verionID      *uint64
	addverionID   *int64
	bundle_url    *string
	status        *bundle.Status
	platform      *bundle.Platform
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Bundle, error)
	predicates    []predicate.Bundle
}

var _ ent.Mutation = (*BundleMutation)(nil)

// bundleOption allows management of the mutation configuration using functional options.
type bundleOption func(*BundleMutation)

// newBundleMutation creates new mutation for the Bundle entity.
func newBundleMutation(c config, op Op, opts ...bundleOption) *BundleMutation {
	m := &BundleMutation{
		config:        c,
		op:            op,
		typ:           TypeBundle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBundleID sets the ID field of the mutation.
func withBundleID(id uint64) bundleOption {
	return func(m *BundleMutation) {
		var (
			err   error
			once  sync.Once
			value *Bundle
		)
		m.oldValue = func(ctx context.Context) (*Bundle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bundle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBundle sets the old Bundle of the mutation.
func withBundle(node *Bundle) bundleOption {
	return func(m *BundleMutation) {
		m.oldValue = func(context.Context) (*Bundle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BundleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BundleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bundle entities.
func (m *BundleMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BundleMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BundleMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Bundle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *BundleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BundleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Bundle entity.
// If the Bundle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BundleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BundleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BundleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BundleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Bundle entity.
// If the Bundle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BundleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BundleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetVerionID sets the "verionID" field.
func (m *BundleMutation) SetVerionID(u uint64) {
	m.verionID = &u
	m.addverionID = nil
}

// VerionID returns the value of the "verionID" field in the mutation.
func (m *BundleMutation) VerionID() (r uint64, exists bool) {
	v := m.verionID
	if v == nil {
		return
	}
	return *v, true
}

// OldVerionID returns the old "verionID" field's value of the Bundle entity.
// If the Bundle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BundleMutation) OldVerionID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerionID: %w", err)
	}
	return oldValue.VerionID, nil
}

// AddVerionID adds u to the "verionID" field.
func (m *BundleMutation) AddVerionID(u int64) {
	if m.addverionID != nil {
		*m.addverionID += u
	} else {
		m.addverionID = &u
	}
}

// AddedVerionID returns the value that was added to the "verionID" field in this mutation.
func (m *BundleMutation) AddedVerionID() (r int64, exists bool) {
	v := m.addverionID
	if v == nil {
		return
	}
	return *v, true
}

// ClearVerionID clears the value of the "verionID" field.
func (m *BundleMutation) ClearVerionID() {
	m.verionID = nil
	m.addverionID = nil
	m.clearedFields[bundle.FieldVerionID] = struct{}{}
}

// VerionIDCleared returns if the "verionID" field was cleared in this mutation.
func (m *BundleMutation) VerionIDCleared() bool {
	_, ok := m.clearedFields[bundle.FieldVerionID]
	return ok
}

// ResetVerionID resets all changes to the "verionID" field.
func (m *BundleMutation) ResetVerionID() {
	m.verionID = nil
	m.addverionID = nil
	delete(m.clearedFields, bundle.FieldVerionID)
}

// SetBundleURL sets the "bundle_url" field.
func (m *BundleMutation) SetBundleURL(s string) {
	m.bundle_url = &s
}

// BundleURL returns the value of the "bundle_url" field in the mutation.
func (m *BundleMutation) BundleURL() (r string, exists bool) {
	v := m.bundle_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBundleURL returns the old "bundle_url" field's value of the Bundle entity.
// If the Bundle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BundleMutation) OldBundleURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBundleURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBundleURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBundleURL: %w", err)
	}
	return oldValue.BundleURL, nil
}

// ClearBundleURL clears the value of the "bundle_url" field.
func (m *BundleMutation) ClearBundleURL() {
	m.bundle_url = nil
	m.clearedFields[bundle.FieldBundleURL] = struct{}{}
}

// BundleURLCleared returns if the "bundle_url" field was cleared in this mutation.
func (m *BundleMutation) BundleURLCleared() bool {
	_, ok := m.clearedFields[bundle.FieldBundleURL]
	return ok
}

// ResetBundleURL resets all changes to the "bundle_url" field.
func (m *BundleMutation) ResetBundleURL() {
	m.bundle_url = nil
	delete(m.clearedFields, bundle.FieldBundleURL)
}

// SetStatus sets the "status" field.
func (m *BundleMutation) SetStatus(b bundle.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BundleMutation) Status() (r bundle.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Bundle entity.
// If the Bundle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BundleMutation) OldStatus(ctx context.Context) (v bundle.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BundleMutation) ResetStatus() {
	m.status = nil
}

// SetPlatform sets the "platform" field.
func (m *BundleMutation) SetPlatform(b bundle.Platform) {
	m.platform = &b
}

// Platform returns the value of the "platform" field in the mutation.
func (m *BundleMutation) Platform() (r bundle.Platform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Bundle entity.
// If the Bundle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BundleMutation) OldPlatform(ctx context.Context) (v bundle.Platform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *BundleMutation) ResetPlatform() {
	m.platform = nil
}

// SetMaskID sets the "mask_id" field.
func (m *BundleMutation) SetMaskID(u uint64) {
	m.owner = &u
}

// MaskID returns the value of the "mask_id" field in the mutation.
func (m *BundleMutation) MaskID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldMaskID returns the old "mask_id" field's value of the Bundle entity.
// If the Bundle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BundleMutation) OldMaskID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaskID: %w", err)
	}
	return oldValue.MaskID, nil
}

// ClearMaskID clears the value of the "mask_id" field.
func (m *BundleMutation) ClearMaskID() {
	m.owner = nil
	m.clearedFields[bundle.FieldMaskID] = struct{}{}
}

// MaskIDCleared returns if the "mask_id" field was cleared in this mutation.
func (m *BundleMutation) MaskIDCleared() bool {
	_, ok := m.clearedFields[bundle.FieldMaskID]
	return ok
}

// ResetMaskID resets all changes to the "mask_id" field.
func (m *BundleMutation) ResetMaskID() {
	m.owner = nil
	delete(m.clearedFields, bundle.FieldMaskID)
}

// SetOwnerID sets the "owner" edge to the Mask entity by id.
func (m *BundleMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Mask entity.
func (m *BundleMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Mask entity was cleared.
func (m *BundleMutation) OwnerCleared() bool {
	return m.MaskIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *BundleMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *BundleMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *BundleMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the BundleMutation builder.
func (m *BundleMutation) Where(ps ...predicate.Bundle) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BundleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bundle).
func (m *BundleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BundleMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, bundle.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, bundle.FieldUpdateTime)
	}
	if m.verionID != nil {
		fields = append(fields, bundle.FieldVerionID)
	}
	if m.bundle_url != nil {
		fields = append(fields, bundle.FieldBundleURL)
	}
	if m.status != nil {
		fields = append(fields, bundle.FieldStatus)
	}
	if m.platform != nil {
		fields = append(fields, bundle.FieldPlatform)
	}
	if m.owner != nil {
		fields = append(fields, bundle.FieldMaskID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BundleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bundle.FieldCreateTime:
		return m.CreateTime()
	case bundle.FieldUpdateTime:
		return m.UpdateTime()
	case bundle.FieldVerionID:
		return m.VerionID()
	case bundle.FieldBundleURL:
		return m.BundleURL()
	case bundle.FieldStatus:
		return m.Status()
	case bundle.FieldPlatform:
		return m.Platform()
	case bundle.FieldMaskID:
		return m.MaskID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BundleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bundle.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case bundle.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case bundle.FieldVerionID:
		return m.OldVerionID(ctx)
	case bundle.FieldBundleURL:
		return m.OldBundleURL(ctx)
	case bundle.FieldStatus:
		return m.OldStatus(ctx)
	case bundle.FieldPlatform:
		return m.OldPlatform(ctx)
	case bundle.FieldMaskID:
		return m.OldMaskID(ctx)
	}
	return nil, fmt.Errorf("unknown Bundle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BundleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bundle.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case bundle.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case bundle.FieldVerionID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerionID(v)
		return nil
	case bundle.FieldBundleURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBundleURL(v)
		return nil
	case bundle.FieldStatus:
		v, ok := value.(bundle.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case bundle.FieldPlatform:
		v, ok := value.(bundle.Platform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case bundle.FieldMaskID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaskID(v)
		return nil
	}
	return fmt.Errorf("unknown Bundle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BundleMutation) AddedFields() []string {
	var fields []string
	if m.addverionID != nil {
		fields = append(fields, bundle.FieldVerionID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BundleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bundle.FieldVerionID:
		return m.AddedVerionID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BundleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bundle.FieldVerionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVerionID(v)
		return nil
	}
	return fmt.Errorf("unknown Bundle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BundleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bundle.FieldVerionID) {
		fields = append(fields, bundle.FieldVerionID)
	}
	if m.FieldCleared(bundle.FieldBundleURL) {
		fields = append(fields, bundle.FieldBundleURL)
	}
	if m.FieldCleared(bundle.FieldMaskID) {
		fields = append(fields, bundle.FieldMaskID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BundleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BundleMutation) ClearField(name string) error {
	switch name {
	case bundle.FieldVerionID:
		m.ClearVerionID()
		return nil
	case bundle.FieldBundleURL:
		m.ClearBundleURL()
		return nil
	case bundle.FieldMaskID:
		m.ClearMaskID()
		return nil
	}
	return fmt.Errorf("unknown Bundle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BundleMutation) ResetField(name string) error {
	switch name {
	case bundle.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case bundle.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case bundle.FieldVerionID:
		m.ResetVerionID()
		return nil
	case bundle.FieldBundleURL:
		m.ResetBundleURL()
		return nil
	case bundle.FieldStatus:
		m.ResetStatus()
		return nil
	case bundle.FieldPlatform:
		m.ResetPlatform()
		return nil
	case bundle.FieldMaskID:
		m.ResetMaskID()
		return nil
	}
	return fmt.Errorf("unknown Bundle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BundleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, bundle.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BundleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bundle.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BundleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BundleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BundleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, bundle.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BundleMutation) EdgeCleared(name string) bool {
	switch name {
	case bundle.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BundleMutation) ClearEdge(name string) error {
	switch name {
	case bundle.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Bundle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BundleMutation) ResetEdge(name string) error {
	switch name {
	case bundle.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Bundle edge %s", name)
}

// CSFieldMutation represents an operation that mutates the CSField nodes in the graph.
type CSFieldMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	create_time        *time.Time
	update_time        *time.Time
	name               *string
	status             *csfield.Status
	_type              *csfield.Type
	mode               *csfield.Mode
	private_level      *csfield.PrivateLevel
	user_id            *uint64
	adduser_id         *int64
	master_id          *uint64
	addmaster_id       *int64
	clearedFields      map[string]struct{}
	joined_user        map[uint64]struct{}
	removedjoined_user map[uint64]struct{}
	clearedjoined_user bool
	joins              map[int]struct{}
	removedjoins       map[int]struct{}
	clearedjoins       bool
	done               bool
	oldValue           func(context.Context) (*CSField, error)
	predicates         []predicate.CSField
}

var _ ent.Mutation = (*CSFieldMutation)(nil)

// csfieldOption allows management of the mutation configuration using functional options.
type csfieldOption func(*CSFieldMutation)

// newCSFieldMutation creates new mutation for the CSField entity.
func newCSFieldMutation(c config, op Op, opts ...csfieldOption) *CSFieldMutation {
	m := &CSFieldMutation{
		config:        c,
		op:            op,
		typ:           TypeCSField,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCSFieldID sets the ID field of the mutation.
func withCSFieldID(id uint64) csfieldOption {
	return func(m *CSFieldMutation) {
		var (
			err   error
			once  sync.Once
			value *CSField
		)
		m.oldValue = func(ctx context.Context) (*CSField, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CSField.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCSField sets the old CSField of the mutation.
func withCSField(node *CSField) csfieldOption {
	return func(m *CSFieldMutation) {
		m.oldValue = func(context.Context) (*CSField, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CSFieldMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CSFieldMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CSField entities.
func (m *CSFieldMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CSFieldMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CSFieldMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CSField.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CSFieldMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CSFieldMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CSFieldMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CSFieldMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CSFieldMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CSFieldMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CSFieldMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CSFieldMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CSFieldMutation) ClearName() {
	m.name = nil
	m.clearedFields[csfield.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CSFieldMutation) NameCleared() bool {
	_, ok := m.clearedFields[csfield.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CSFieldMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, csfield.FieldName)
}

// SetStatus sets the "status" field.
func (m *CSFieldMutation) SetStatus(c csfield.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CSFieldMutation) Status() (r csfield.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldStatus(ctx context.Context) (v csfield.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CSFieldMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *CSFieldMutation) SetType(c csfield.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CSFieldMutation) GetType() (r csfield.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldType(ctx context.Context) (v csfield.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CSFieldMutation) ResetType() {
	m._type = nil
}

// SetMode sets the "mode" field.
func (m *CSFieldMutation) SetMode(c csfield.Mode) {
	m.mode = &c
}

// Mode returns the value of the "mode" field in the mutation.
func (m *CSFieldMutation) Mode() (r csfield.Mode, exists bool) {
	v := m.mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMode returns the old "mode" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldMode(ctx context.Context) (v csfield.Mode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMode: %w", err)
	}
	return oldValue.Mode, nil
}

// ResetMode resets all changes to the "mode" field.
func (m *CSFieldMutation) ResetMode() {
	m.mode = nil
}

// SetPrivateLevel sets the "private_level" field.
func (m *CSFieldMutation) SetPrivateLevel(cl csfield.PrivateLevel) {
	m.private_level = &cl
}

// PrivateLevel returns the value of the "private_level" field in the mutation.
func (m *CSFieldMutation) PrivateLevel() (r csfield.PrivateLevel, exists bool) {
	v := m.private_level
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateLevel returns the old "private_level" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldPrivateLevel(ctx context.Context) (v csfield.PrivateLevel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateLevel: %w", err)
	}
	return oldValue.PrivateLevel, nil
}

// ResetPrivateLevel resets all changes to the "private_level" field.
func (m *CSFieldMutation) ResetPrivateLevel() {
	m.private_level = nil
}

// SetUserID sets the "user_id" field.
func (m *CSFieldMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CSFieldMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *CSFieldMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *CSFieldMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CSFieldMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetMasterID sets the "master_id" field.
func (m *CSFieldMutation) SetMasterID(u uint64) {
	m.master_id = &u
	m.addmaster_id = nil
}

// MasterID returns the value of the "master_id" field in the mutation.
func (m *CSFieldMutation) MasterID() (r uint64, exists bool) {
	v := m.master_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMasterID returns the old "master_id" field's value of the CSField entity.
// If the CSField object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CSFieldMutation) OldMasterID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasterID: %w", err)
	}
	return oldValue.MasterID, nil
}

// AddMasterID adds u to the "master_id" field.
func (m *CSFieldMutation) AddMasterID(u int64) {
	if m.addmaster_id != nil {
		*m.addmaster_id += u
	} else {
		m.addmaster_id = &u
	}
}

// AddedMasterID returns the value that was added to the "master_id" field in this mutation.
func (m *CSFieldMutation) AddedMasterID() (r int64, exists bool) {
	v := m.addmaster_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearMasterID clears the value of the "master_id" field.
func (m *CSFieldMutation) ClearMasterID() {
	m.master_id = nil
	m.addmaster_id = nil
	m.clearedFields[csfield.FieldMasterID] = struct{}{}
}

// MasterIDCleared returns if the "master_id" field was cleared in this mutation.
func (m *CSFieldMutation) MasterIDCleared() bool {
	_, ok := m.clearedFields[csfield.FieldMasterID]
	return ok
}

// ResetMasterID resets all changes to the "master_id" field.
func (m *CSFieldMutation) ResetMasterID() {
	m.master_id = nil
	m.addmaster_id = nil
	delete(m.clearedFields, csfield.FieldMasterID)
}

// AddJoinedUserIDs adds the "joined_user" edge to the User entity by ids.
func (m *CSFieldMutation) AddJoinedUserIDs(ids ...uint64) {
	if m.joined_user == nil {
		m.joined_user = make(map[uint64]struct{})
	}
	for i := range ids {
		m.joined_user[ids[i]] = struct{}{}
	}
}

// ClearJoinedUser clears the "joined_user" edge to the User entity.
func (m *CSFieldMutation) ClearJoinedUser() {
	m.clearedjoined_user = true
}

// JoinedUserCleared reports if the "joined_user" edge to the User entity was cleared.
func (m *CSFieldMutation) JoinedUserCleared() bool {
	return m.clearedjoined_user
}

// RemoveJoinedUserIDs removes the "joined_user" edge to the User entity by IDs.
func (m *CSFieldMutation) RemoveJoinedUserIDs(ids ...uint64) {
	if m.removedjoined_user == nil {
		m.removedjoined_user = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.joined_user, ids[i])
		m.removedjoined_user[ids[i]] = struct{}{}
	}
}

// RemovedJoinedUser returns the removed IDs of the "joined_user" edge to the User entity.
func (m *CSFieldMutation) RemovedJoinedUserIDs() (ids []uint64) {
	for id := range m.removedjoined_user {
		ids = append(ids, id)
	}
	return
}

// JoinedUserIDs returns the "joined_user" edge IDs in the mutation.
func (m *CSFieldMutation) JoinedUserIDs() (ids []uint64) {
	for id := range m.joined_user {
		ids = append(ids, id)
	}
	return
}

// ResetJoinedUser resets all changes to the "joined_user" edge.
func (m *CSFieldMutation) ResetJoinedUser() {
	m.joined_user = nil
	m.clearedjoined_user = false
	m.removedjoined_user = nil
}

// AddJoinIDs adds the "joins" edge to the Join entity by ids.
func (m *CSFieldMutation) AddJoinIDs(ids ...int) {
	if m.joins == nil {
		m.joins = make(map[int]struct{})
	}
	for i := range ids {
		m.joins[ids[i]] = struct{}{}
	}
}

// ClearJoins clears the "joins" edge to the Join entity.
func (m *CSFieldMutation) ClearJoins() {
	m.clearedjoins = true
}

// JoinsCleared reports if the "joins" edge to the Join entity was cleared.
func (m *CSFieldMutation) JoinsCleared() bool {
	return m.clearedjoins
}

// RemoveJoinIDs removes the "joins" edge to the Join entity by IDs.
func (m *CSFieldMutation) RemoveJoinIDs(ids ...int) {
	if m.removedjoins == nil {
		m.removedjoins = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.joins, ids[i])
		m.removedjoins[ids[i]] = struct{}{}
	}
}

// RemovedJoins returns the removed IDs of the "joins" edge to the Join entity.
func (m *CSFieldMutation) RemovedJoinsIDs() (ids []int) {
	for id := range m.removedjoins {
		ids = append(ids, id)
	}
	return
}

// JoinsIDs returns the "joins" edge IDs in the mutation.
func (m *CSFieldMutation) JoinsIDs() (ids []int) {
	for id := range m.joins {
		ids = append(ids, id)
	}
	return
}

// ResetJoins resets all changes to the "joins" edge.
func (m *CSFieldMutation) ResetJoins() {
	m.joins = nil
	m.clearedjoins = false
	m.removedjoins = nil
}

// Where appends a list predicates to the CSFieldMutation builder.
func (m *CSFieldMutation) Where(ps ...predicate.CSField) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CSFieldMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CSField).
func (m *CSFieldMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CSFieldMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, csfield.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, csfield.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, csfield.FieldName)
	}
	if m.status != nil {
		fields = append(fields, csfield.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, csfield.FieldType)
	}
	if m.mode != nil {
		fields = append(fields, csfield.FieldMode)
	}
	if m.private_level != nil {
		fields = append(fields, csfield.FieldPrivateLevel)
	}
	if m.user_id != nil {
		fields = append(fields, csfield.FieldUserID)
	}
	if m.master_id != nil {
		fields = append(fields, csfield.FieldMasterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CSFieldMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case csfield.FieldCreateTime:
		return m.CreateTime()
	case csfield.FieldUpdateTime:
		return m.UpdateTime()
	case csfield.FieldName:
		return m.Name()
	case csfield.FieldStatus:
		return m.Status()
	case csfield.FieldType:
		return m.GetType()
	case csfield.FieldMode:
		return m.Mode()
	case csfield.FieldPrivateLevel:
		return m.PrivateLevel()
	case csfield.FieldUserID:
		return m.UserID()
	case csfield.FieldMasterID:
		return m.MasterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CSFieldMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case csfield.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case csfield.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case csfield.FieldName:
		return m.OldName(ctx)
	case csfield.FieldStatus:
		return m.OldStatus(ctx)
	case csfield.FieldType:
		return m.OldType(ctx)
	case csfield.FieldMode:
		return m.OldMode(ctx)
	case csfield.FieldPrivateLevel:
		return m.OldPrivateLevel(ctx)
	case csfield.FieldUserID:
		return m.OldUserID(ctx)
	case csfield.FieldMasterID:
		return m.OldMasterID(ctx)
	}
	return nil, fmt.Errorf("unknown CSField field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CSFieldMutation) SetField(name string, value ent.Value) error {
	switch name {
	case csfield.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case csfield.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case csfield.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case csfield.FieldStatus:
		v, ok := value.(csfield.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case csfield.FieldType:
		v, ok := value.(csfield.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case csfield.FieldMode:
		v, ok := value.(csfield.Mode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMode(v)
		return nil
	case csfield.FieldPrivateLevel:
		v, ok := value.(csfield.PrivateLevel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateLevel(v)
		return nil
	case csfield.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case csfield.FieldMasterID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasterID(v)
		return nil
	}
	return fmt.Errorf("unknown CSField field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CSFieldMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, csfield.FieldUserID)
	}
	if m.addmaster_id != nil {
		fields = append(fields, csfield.FieldMasterID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CSFieldMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case csfield.FieldUserID:
		return m.AddedUserID()
	case csfield.FieldMasterID:
		return m.AddedMasterID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CSFieldMutation) AddField(name string, value ent.Value) error {
	switch name {
	case csfield.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case csfield.FieldMasterID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasterID(v)
		return nil
	}
	return fmt.Errorf("unknown CSField numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CSFieldMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(csfield.FieldName) {
		fields = append(fields, csfield.FieldName)
	}
	if m.FieldCleared(csfield.FieldMasterID) {
		fields = append(fields, csfield.FieldMasterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CSFieldMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CSFieldMutation) ClearField(name string) error {
	switch name {
	case csfield.FieldName:
		m.ClearName()
		return nil
	case csfield.FieldMasterID:
		m.ClearMasterID()
		return nil
	}
	return fmt.Errorf("unknown CSField nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CSFieldMutation) ResetField(name string) error {
	switch name {
	case csfield.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case csfield.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case csfield.FieldName:
		m.ResetName()
		return nil
	case csfield.FieldStatus:
		m.ResetStatus()
		return nil
	case csfield.FieldType:
		m.ResetType()
		return nil
	case csfield.FieldMode:
		m.ResetMode()
		return nil
	case csfield.FieldPrivateLevel:
		m.ResetPrivateLevel()
		return nil
	case csfield.FieldUserID:
		m.ResetUserID()
		return nil
	case csfield.FieldMasterID:
		m.ResetMasterID()
		return nil
	}
	return fmt.Errorf("unknown CSField field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CSFieldMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.joined_user != nil {
		edges = append(edges, csfield.EdgeJoinedUser)
	}
	if m.joins != nil {
		edges = append(edges, csfield.EdgeJoins)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CSFieldMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case csfield.EdgeJoinedUser:
		ids := make([]ent.Value, 0, len(m.joined_user))
		for id := range m.joined_user {
			ids = append(ids, id)
		}
		return ids
	case csfield.EdgeJoins:
		ids := make([]ent.Value, 0, len(m.joins))
		for id := range m.joins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CSFieldMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedjoined_user != nil {
		edges = append(edges, csfield.EdgeJoinedUser)
	}
	if m.removedjoins != nil {
		edges = append(edges, csfield.EdgeJoins)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CSFieldMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case csfield.EdgeJoinedUser:
		ids := make([]ent.Value, 0, len(m.removedjoined_user))
		for id := range m.removedjoined_user {
			ids = append(ids, id)
		}
		return ids
	case csfield.EdgeJoins:
		ids := make([]ent.Value, 0, len(m.removedjoins))
		for id := range m.removedjoins {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CSFieldMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjoined_user {
		edges = append(edges, csfield.EdgeJoinedUser)
	}
	if m.clearedjoins {
		edges = append(edges, csfield.EdgeJoins)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CSFieldMutation) EdgeCleared(name string) bool {
	switch name {
	case csfield.EdgeJoinedUser:
		return m.clearedjoined_user
	case csfield.EdgeJoins:
		return m.clearedjoins
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CSFieldMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CSField unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CSFieldMutation) ResetEdge(name string) error {
	switch name {
	case csfield.EdgeJoinedUser:
		m.ResetJoinedUser()
		return nil
	case csfield.EdgeJoins:
		m.ResetJoins()
		return nil
	}
	return fmt.Errorf("unknown CSField edge %s", name)
}

// CardMutation represents an operation that mutates the Card nodes in the graph.
type CardMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	description   *string
	pic_url       *string
	thumbnail_url *string
	resource_url  *string
	status        *card.Status
	_type         *card.Type
	script        *[]string
	appendscript  []string
	script_raw    *string
	script_url    *string
	clearedFields map[string]struct{}
	rule          map[uint64]struct{}
	removedrule   map[uint64]struct{}
	clearedrule   bool
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Card, error)
	predicates    []predicate.Card
}

var _ ent.Mutation = (*CardMutation)(nil)

// cardOption allows management of the mutation configuration using functional options.
type cardOption func(*CardMutation)

// newCardMutation creates new mutation for the Card entity.
func newCardMutation(c config, op Op, opts ...cardOption) *CardMutation {
	m := &CardMutation{
		config:        c,
		op:            op,
		typ:           TypeCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardID sets the ID field of the mutation.
func withCardID(id uint64) cardOption {
	return func(m *CardMutation) {
		var (
			err   error
			once  sync.Once
			value *Card
		)
		m.oldValue = func(ctx context.Context) (*Card, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Card.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCard sets the old Card of the mutation.
func withCard(node *Card) cardOption {
	return func(m *CardMutation) {
		m.oldValue = func(context.Context) (*Card, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Card entities.
func (m *CardMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Card.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CardMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CardMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CardMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CardMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CardMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CardMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CardMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CardMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CardMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CardMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[card.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CardMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[card.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CardMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, card.FieldDescription)
}

// SetPicURL sets the "pic_url" field.
func (m *CardMutation) SetPicURL(s string) {
	m.pic_url = &s
}

// PicURL returns the value of the "pic_url" field in the mutation.
func (m *CardMutation) PicURL() (r string, exists bool) {
	v := m.pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPicURL returns the old "pic_url" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicURL: %w", err)
	}
	return oldValue.PicURL, nil
}

// ClearPicURL clears the value of the "pic_url" field.
func (m *CardMutation) ClearPicURL() {
	m.pic_url = nil
	m.clearedFields[card.FieldPicURL] = struct{}{}
}

// PicURLCleared returns if the "pic_url" field was cleared in this mutation.
func (m *CardMutation) PicURLCleared() bool {
	_, ok := m.clearedFields[card.FieldPicURL]
	return ok
}

// ResetPicURL resets all changes to the "pic_url" field.
func (m *CardMutation) ResetPicURL() {
	m.pic_url = nil
	delete(m.clearedFields, card.FieldPicURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *CardMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *CardMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *CardMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[card.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *CardMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[card.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *CardMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, card.FieldThumbnailURL)
}

// SetResourceURL sets the "resource_url" field.
func (m *CardMutation) SetResourceURL(s string) {
	m.resource_url = &s
}

// ResourceURL returns the value of the "resource_url" field in the mutation.
func (m *CardMutation) ResourceURL() (r string, exists bool) {
	v := m.resource_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceURL returns the old "resource_url" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldResourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceURL: %w", err)
	}
	return oldValue.ResourceURL, nil
}

// ClearResourceURL clears the value of the "resource_url" field.
func (m *CardMutation) ClearResourceURL() {
	m.resource_url = nil
	m.clearedFields[card.FieldResourceURL] = struct{}{}
}

// ResourceURLCleared returns if the "resource_url" field was cleared in this mutation.
func (m *CardMutation) ResourceURLCleared() bool {
	_, ok := m.clearedFields[card.FieldResourceURL]
	return ok
}

// ResetResourceURL resets all changes to the "resource_url" field.
func (m *CardMutation) ResetResourceURL() {
	m.resource_url = nil
	delete(m.clearedFields, card.FieldResourceURL)
}

// SetStatus sets the "status" field.
func (m *CardMutation) SetStatus(c card.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *CardMutation) Status() (r card.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldStatus(ctx context.Context) (v card.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CardMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *CardMutation) SetType(c card.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CardMutation) GetType() (r card.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldType(ctx context.Context) (v card.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CardMutation) ResetType() {
	m._type = nil
}

// SetScript sets the "script" field.
func (m *CardMutation) SetScript(s []string) {
	m.script = &s
	m.appendscript = nil
}

// Script returns the value of the "script" field in the mutation.
func (m *CardMutation) Script() (r []string, exists bool) {
	v := m.script
	if v == nil {
		return
	}
	return *v, true
}

// OldScript returns the old "script" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldScript(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScript is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScript requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScript: %w", err)
	}
	return oldValue.Script, nil
}

// AppendScript adds s to the "script" field.
func (m *CardMutation) AppendScript(s []string) {
	m.appendscript = append(m.appendscript, s...)
}

// AppendedScript returns the list of values that were appended to the "script" field in this mutation.
func (m *CardMutation) AppendedScript() ([]string, bool) {
	if len(m.appendscript) == 0 {
		return nil, false
	}
	return m.appendscript, true
}

// ClearScript clears the value of the "script" field.
func (m *CardMutation) ClearScript() {
	m.script = nil
	m.appendscript = nil
	m.clearedFields[card.FieldScript] = struct{}{}
}

// ScriptCleared returns if the "script" field was cleared in this mutation.
func (m *CardMutation) ScriptCleared() bool {
	_, ok := m.clearedFields[card.FieldScript]
	return ok
}

// ResetScript resets all changes to the "script" field.
func (m *CardMutation) ResetScript() {
	m.script = nil
	m.appendscript = nil
	delete(m.clearedFields, card.FieldScript)
}

// SetScriptRaw sets the "script_raw" field.
func (m *CardMutation) SetScriptRaw(s string) {
	m.script_raw = &s
}

// ScriptRaw returns the value of the "script_raw" field in the mutation.
func (m *CardMutation) ScriptRaw() (r string, exists bool) {
	v := m.script_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptRaw returns the old "script_raw" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldScriptRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptRaw: %w", err)
	}
	return oldValue.ScriptRaw, nil
}

// ClearScriptRaw clears the value of the "script_raw" field.
func (m *CardMutation) ClearScriptRaw() {
	m.script_raw = nil
	m.clearedFields[card.FieldScriptRaw] = struct{}{}
}

// ScriptRawCleared returns if the "script_raw" field was cleared in this mutation.
func (m *CardMutation) ScriptRawCleared() bool {
	_, ok := m.clearedFields[card.FieldScriptRaw]
	return ok
}

// ResetScriptRaw resets all changes to the "script_raw" field.
func (m *CardMutation) ResetScriptRaw() {
	m.script_raw = nil
	delete(m.clearedFields, card.FieldScriptRaw)
}

// SetScriptURL sets the "script_url" field.
func (m *CardMutation) SetScriptURL(s string) {
	m.script_url = &s
}

// ScriptURL returns the value of the "script_url" field in the mutation.
func (m *CardMutation) ScriptURL() (r string, exists bool) {
	v := m.script_url
	if v == nil {
		return
	}
	return *v, true
}

// OldScriptURL returns the old "script_url" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldScriptURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScriptURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScriptURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScriptURL: %w", err)
	}
	return oldValue.ScriptURL, nil
}

// ClearScriptURL clears the value of the "script_url" field.
func (m *CardMutation) ClearScriptURL() {
	m.script_url = nil
	m.clearedFields[card.FieldScriptURL] = struct{}{}
}

// ScriptURLCleared returns if the "script_url" field was cleared in this mutation.
func (m *CardMutation) ScriptURLCleared() bool {
	_, ok := m.clearedFields[card.FieldScriptURL]
	return ok
}

// ResetScriptURL resets all changes to the "script_url" field.
func (m *CardMutation) ResetScriptURL() {
	m.script_url = nil
	delete(m.clearedFields, card.FieldScriptURL)
}

// SetUserID sets the "user_id" field.
func (m *CardMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CardMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CardMutation) ClearUserID() {
	m.owner = nil
	m.clearedFields[card.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CardMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[card.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CardMutation) ResetUserID() {
	m.owner = nil
	delete(m.clearedFields, card.FieldUserID)
}

// AddRuleIDs adds the "rule" edge to the Rule entity by ids.
func (m *CardMutation) AddRuleIDs(ids ...uint64) {
	if m.rule == nil {
		m.rule = make(map[uint64]struct{})
	}
	for i := range ids {
		m.rule[ids[i]] = struct{}{}
	}
}

// ClearRule clears the "rule" edge to the Rule entity.
func (m *CardMutation) ClearRule() {
	m.clearedrule = true
}

// RuleCleared reports if the "rule" edge to the Rule entity was cleared.
func (m *CardMutation) RuleCleared() bool {
	return m.clearedrule
}

// RemoveRuleIDs removes the "rule" edge to the Rule entity by IDs.
func (m *CardMutation) RemoveRuleIDs(ids ...uint64) {
	if m.removedrule == nil {
		m.removedrule = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.rule, ids[i])
		m.removedrule[ids[i]] = struct{}{}
	}
}

// RemovedRule returns the removed IDs of the "rule" edge to the Rule entity.
func (m *CardMutation) RemovedRuleIDs() (ids []uint64) {
	for id := range m.removedrule {
		ids = append(ids, id)
	}
	return
}

// RuleIDs returns the "rule" edge IDs in the mutation.
func (m *CardMutation) RuleIDs() (ids []uint64) {
	for id := range m.rule {
		ids = append(ids, id)
	}
	return
}

// ResetRule resets all changes to the "rule" edge.
func (m *CardMutation) ResetRule() {
	m.rule = nil
	m.clearedrule = false
	m.removedrule = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CardMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CardMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CardMutation) OwnerCleared() bool {
	return m.UserIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CardMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CardMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CardMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the CardMutation builder.
func (m *CardMutation) Where(ps ...predicate.Card) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CardMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Card).
func (m *CardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.create_time != nil {
		fields = append(fields, card.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, card.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, card.FieldName)
	}
	if m.description != nil {
		fields = append(fields, card.FieldDescription)
	}
	if m.pic_url != nil {
		fields = append(fields, card.FieldPicURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, card.FieldThumbnailURL)
	}
	if m.resource_url != nil {
		fields = append(fields, card.FieldResourceURL)
	}
	if m.status != nil {
		fields = append(fields, card.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, card.FieldType)
	}
	if m.script != nil {
		fields = append(fields, card.FieldScript)
	}
	if m.script_raw != nil {
		fields = append(fields, card.FieldScriptRaw)
	}
	if m.script_url != nil {
		fields = append(fields, card.FieldScriptURL)
	}
	if m.owner != nil {
		fields = append(fields, card.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case card.FieldCreateTime:
		return m.CreateTime()
	case card.FieldUpdateTime:
		return m.UpdateTime()
	case card.FieldName:
		return m.Name()
	case card.FieldDescription:
		return m.Description()
	case card.FieldPicURL:
		return m.PicURL()
	case card.FieldThumbnailURL:
		return m.ThumbnailURL()
	case card.FieldResourceURL:
		return m.ResourceURL()
	case card.FieldStatus:
		return m.Status()
	case card.FieldType:
		return m.GetType()
	case card.FieldScript:
		return m.Script()
	case card.FieldScriptRaw:
		return m.ScriptRaw()
	case card.FieldScriptURL:
		return m.ScriptURL()
	case card.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case card.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case card.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case card.FieldName:
		return m.OldName(ctx)
	case card.FieldDescription:
		return m.OldDescription(ctx)
	case card.FieldPicURL:
		return m.OldPicURL(ctx)
	case card.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case card.FieldResourceURL:
		return m.OldResourceURL(ctx)
	case card.FieldStatus:
		return m.OldStatus(ctx)
	case card.FieldType:
		return m.OldType(ctx)
	case card.FieldScript:
		return m.OldScript(ctx)
	case card.FieldScriptRaw:
		return m.OldScriptRaw(ctx)
	case card.FieldScriptURL:
		return m.OldScriptURL(ctx)
	case card.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Card field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case card.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case card.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case card.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case card.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case card.FieldPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicURL(v)
		return nil
	case card.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case card.FieldResourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceURL(v)
		return nil
	case card.FieldStatus:
		v, ok := value.(card.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case card.FieldType:
		v, ok := value.(card.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case card.FieldScript:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScript(v)
		return nil
	case card.FieldScriptRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptRaw(v)
		return nil
	case card.FieldScriptURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScriptURL(v)
		return nil
	case card.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Card numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(card.FieldDescription) {
		fields = append(fields, card.FieldDescription)
	}
	if m.FieldCleared(card.FieldPicURL) {
		fields = append(fields, card.FieldPicURL)
	}
	if m.FieldCleared(card.FieldThumbnailURL) {
		fields = append(fields, card.FieldThumbnailURL)
	}
	if m.FieldCleared(card.FieldResourceURL) {
		fields = append(fields, card.FieldResourceURL)
	}
	if m.FieldCleared(card.FieldScript) {
		fields = append(fields, card.FieldScript)
	}
	if m.FieldCleared(card.FieldScriptRaw) {
		fields = append(fields, card.FieldScriptRaw)
	}
	if m.FieldCleared(card.FieldScriptURL) {
		fields = append(fields, card.FieldScriptURL)
	}
	if m.FieldCleared(card.FieldUserID) {
		fields = append(fields, card.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardMutation) ClearField(name string) error {
	switch name {
	case card.FieldDescription:
		m.ClearDescription()
		return nil
	case card.FieldPicURL:
		m.ClearPicURL()
		return nil
	case card.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case card.FieldResourceURL:
		m.ClearResourceURL()
		return nil
	case card.FieldScript:
		m.ClearScript()
		return nil
	case card.FieldScriptRaw:
		m.ClearScriptRaw()
		return nil
	case card.FieldScriptURL:
		m.ClearScriptURL()
		return nil
	case card.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Card nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardMutation) ResetField(name string) error {
	switch name {
	case card.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case card.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case card.FieldName:
		m.ResetName()
		return nil
	case card.FieldDescription:
		m.ResetDescription()
		return nil
	case card.FieldPicURL:
		m.ResetPicURL()
		return nil
	case card.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case card.FieldResourceURL:
		m.ResetResourceURL()
		return nil
	case card.FieldStatus:
		m.ResetStatus()
		return nil
	case card.FieldType:
		m.ResetType()
		return nil
	case card.FieldScript:
		m.ResetScript()
		return nil
	case card.FieldScriptRaw:
		m.ResetScriptRaw()
		return nil
	case card.FieldScriptURL:
		m.ResetScriptURL()
		return nil
	case card.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rule != nil {
		edges = append(edges, card.EdgeRule)
	}
	if m.owner != nil {
		edges = append(edges, card.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeRule:
		ids := make([]ent.Value, 0, len(m.rule))
		for id := range m.rule {
			ids = append(ids, id)
		}
		return ids
	case card.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedrule != nil {
		edges = append(edges, card.EdgeRule)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeRule:
		ids := make([]ent.Value, 0, len(m.removedrule))
		for id := range m.removedrule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrule {
		edges = append(edges, card.EdgeRule)
	}
	if m.clearedowner {
		edges = append(edges, card.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardMutation) EdgeCleared(name string) bool {
	switch name {
	case card.EdgeRule:
		return m.clearedrule
	case card.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardMutation) ClearEdge(name string) error {
	switch name {
	case card.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Card unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardMutation) ResetEdge(name string) error {
	switch name {
	case card.EdgeRule:
		m.ResetRule()
		return nil
	case card.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Card edge %s", name)
}

// CollectionMutation represents an operation that mutates the Collection nodes in the graph.
type CollectionMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	_type         *collection.Type
	item_id       *uint64
	additem_id    *int64
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Collection, error)
	predicates    []predicate.Collection
}

var _ ent.Mutation = (*CollectionMutation)(nil)

// collectionOption allows management of the mutation configuration using functional options.
type collectionOption func(*CollectionMutation)

// newCollectionMutation creates new mutation for the Collection entity.
func newCollectionMutation(c config, op Op, opts ...collectionOption) *CollectionMutation {
	m := &CollectionMutation{
		config:        c,
		op:            op,
		typ:           TypeCollection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCollectionID sets the ID field of the mutation.
func withCollectionID(id uint64) collectionOption {
	return func(m *CollectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Collection
		)
		m.oldValue = func(ctx context.Context) (*Collection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Collection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCollection sets the old Collection of the mutation.
func withCollection(node *Collection) collectionOption {
	return func(m *CollectionMutation) {
		m.oldValue = func(context.Context) (*Collection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CollectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CollectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Collection entities.
func (m *CollectionMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CollectionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CollectionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Collection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CollectionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CollectionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CollectionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CollectionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CollectionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CollectionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *CollectionMutation) SetType(c collection.Type) {
	m._type = &c
}

// GetType returns the value of the "type" field in the mutation.
func (m *CollectionMutation) GetType() (r collection.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldType(ctx context.Context) (v collection.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CollectionMutation) ResetType() {
	m._type = nil
}

// SetItemID sets the "item_id" field.
func (m *CollectionMutation) SetItemID(u uint64) {
	m.item_id = &u
	m.additem_id = nil
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *CollectionMutation) ItemID() (r uint64, exists bool) {
	v := m.item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldItemID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// AddItemID adds u to the "item_id" field.
func (m *CollectionMutation) AddItemID(u int64) {
	if m.additem_id != nil {
		*m.additem_id += u
	} else {
		m.additem_id = &u
	}
}

// AddedItemID returns the value that was added to the "item_id" field in this mutation.
func (m *CollectionMutation) AddedItemID() (r int64, exists bool) {
	v := m.additem_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetItemID resets all changes to the "item_id" field.
func (m *CollectionMutation) ResetItemID() {
	m.item_id = nil
	m.additem_id = nil
}

// SetUserID sets the "user_id" field.
func (m *CollectionMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CollectionMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Collection entity.
// If the Collection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CollectionMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CollectionMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CollectionMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CollectionMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CollectionMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CollectionMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CollectionMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CollectionMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the CollectionMutation builder.
func (m *CollectionMutation) Where(ps ...predicate.Collection) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CollectionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Collection).
func (m *CollectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CollectionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, collection.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, collection.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, collection.FieldType)
	}
	if m.item_id != nil {
		fields = append(fields, collection.FieldItemID)
	}
	if m.owner != nil {
		fields = append(fields, collection.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CollectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldCreateTime:
		return m.CreateTime()
	case collection.FieldUpdateTime:
		return m.UpdateTime()
	case collection.FieldType:
		return m.GetType()
	case collection.FieldItemID:
		return m.ItemID()
	case collection.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CollectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case collection.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case collection.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case collection.FieldType:
		return m.OldType(ctx)
	case collection.FieldItemID:
		return m.OldItemID(ctx)
	case collection.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Collection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case collection.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case collection.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case collection.FieldType:
		v, ok := value.(collection.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case collection.FieldItemID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case collection.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CollectionMutation) AddedFields() []string {
	var fields []string
	if m.additem_id != nil {
		fields = append(fields, collection.FieldItemID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CollectionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case collection.FieldItemID:
		return m.AddedItemID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CollectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case collection.FieldItemID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemID(v)
		return nil
	}
	return fmt.Errorf("unknown Collection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CollectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CollectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CollectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Collection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CollectionMutation) ResetField(name string) error {
	switch name {
	case collection.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case collection.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case collection.FieldType:
		m.ResetType()
		return nil
	case collection.FieldItemID:
		m.ResetItemID()
		return nil
	case collection.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Collection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CollectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, collection.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CollectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case collection.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CollectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CollectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CollectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, collection.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CollectionMutation) EdgeCleared(name string) bool {
	switch name {
	case collection.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CollectionMutation) ClearEdge(name string) error {
	switch name {
	case collection.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Collection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CollectionMutation) ResetEdge(name string) error {
	switch name {
	case collection.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Collection edge %s", name)
}

// CommodityMutation represents an operation that mutates the Commodity nodes in the graph.
type CommodityMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	clearedFields map[string]struct{}
	card          map[uint64]struct{}
	removedcard   map[uint64]struct{}
	clearedcard   bool
	_NFT          map[uint64]struct{}
	removed_NFT   map[uint64]struct{}
	cleared_NFT   bool
	done          bool
	oldValue      func(context.Context) (*Commodity, error)
	predicates    []predicate.Commodity
}

var _ ent.Mutation = (*CommodityMutation)(nil)

// commodityOption allows management of the mutation configuration using functional options.
type commodityOption func(*CommodityMutation)

// newCommodityMutation creates new mutation for the Commodity entity.
func newCommodityMutation(c config, op Op, opts ...commodityOption) *CommodityMutation {
	m := &CommodityMutation{
		config:        c,
		op:            op,
		typ:           TypeCommodity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommodityID sets the ID field of the mutation.
func withCommodityID(id uint64) commodityOption {
	return func(m *CommodityMutation) {
		var (
			err   error
			once  sync.Once
			value *Commodity
		)
		m.oldValue = func(ctx context.Context) (*Commodity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commodity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommodity sets the old Commodity of the mutation.
func withCommodity(node *Commodity) commodityOption {
	return func(m *CommodityMutation) {
		m.oldValue = func(context.Context) (*Commodity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommodityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommodityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Commodity entities.
func (m *CommodityMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommodityMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommodityMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Commodity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CommodityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CommodityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CommodityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CommodityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CommodityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CommodityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CommodityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CommodityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Commodity entity.
// If the Commodity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommodityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CommodityMutation) ResetName() {
	m.name = nil
}

// AddCardIDs adds the "card" edge to the Card entity by ids.
func (m *CommodityMutation) AddCardIDs(ids ...uint64) {
	if m.card == nil {
		m.card = make(map[uint64]struct{})
	}
	for i := range ids {
		m.card[ids[i]] = struct{}{}
	}
}

// ClearCard clears the "card" edge to the Card entity.
func (m *CommodityMutation) ClearCard() {
	m.clearedcard = true
}

// CardCleared reports if the "card" edge to the Card entity was cleared.
func (m *CommodityMutation) CardCleared() bool {
	return m.clearedcard
}

// RemoveCardIDs removes the "card" edge to the Card entity by IDs.
func (m *CommodityMutation) RemoveCardIDs(ids ...uint64) {
	if m.removedcard == nil {
		m.removedcard = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.card, ids[i])
		m.removedcard[ids[i]] = struct{}{}
	}
}

// RemovedCard returns the removed IDs of the "card" edge to the Card entity.
func (m *CommodityMutation) RemovedCardIDs() (ids []uint64) {
	for id := range m.removedcard {
		ids = append(ids, id)
	}
	return
}

// CardIDs returns the "card" edge IDs in the mutation.
func (m *CommodityMutation) CardIDs() (ids []uint64) {
	for id := range m.card {
		ids = append(ids, id)
	}
	return
}

// ResetCard resets all changes to the "card" edge.
func (m *CommodityMutation) ResetCard() {
	m.card = nil
	m.clearedcard = false
	m.removedcard = nil
}

// AddNFTIDs adds the "NFT" edge to the NFT entity by ids.
func (m *CommodityMutation) AddNFTIDs(ids ...uint64) {
	if m._NFT == nil {
		m._NFT = make(map[uint64]struct{})
	}
	for i := range ids {
		m._NFT[ids[i]] = struct{}{}
	}
}

// ClearNFT clears the "NFT" edge to the NFT entity.
func (m *CommodityMutation) ClearNFT() {
	m.cleared_NFT = true
}

// NFTCleared reports if the "NFT" edge to the NFT entity was cleared.
func (m *CommodityMutation) NFTCleared() bool {
	return m.cleared_NFT
}

// RemoveNFTIDs removes the "NFT" edge to the NFT entity by IDs.
func (m *CommodityMutation) RemoveNFTIDs(ids ...uint64) {
	if m.removed_NFT == nil {
		m.removed_NFT = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m._NFT, ids[i])
		m.removed_NFT[ids[i]] = struct{}{}
	}
}

// RemovedNFT returns the removed IDs of the "NFT" edge to the NFT entity.
func (m *CommodityMutation) RemovedNFTIDs() (ids []uint64) {
	for id := range m.removed_NFT {
		ids = append(ids, id)
	}
	return
}

// NFTIDs returns the "NFT" edge IDs in the mutation.
func (m *CommodityMutation) NFTIDs() (ids []uint64) {
	for id := range m._NFT {
		ids = append(ids, id)
	}
	return
}

// ResetNFT resets all changes to the "NFT" edge.
func (m *CommodityMutation) ResetNFT() {
	m._NFT = nil
	m.cleared_NFT = false
	m.removed_NFT = nil
}

// Where appends a list predicates to the CommodityMutation builder.
func (m *CommodityMutation) Where(ps ...predicate.Commodity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommodityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Commodity).
func (m *CommodityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommodityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, commodity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, commodity.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, commodity.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommodityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commodity.FieldCreateTime:
		return m.CreateTime()
	case commodity.FieldUpdateTime:
		return m.UpdateTime()
	case commodity.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommodityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commodity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case commodity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case commodity.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Commodity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommodityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commodity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case commodity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case commodity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Commodity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommodityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommodityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommodityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Commodity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommodityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommodityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommodityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Commodity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommodityMutation) ResetField(name string) error {
	switch name {
	case commodity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case commodity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case commodity.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Commodity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommodityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.card != nil {
		edges = append(edges, commodity.EdgeCard)
	}
	if m._NFT != nil {
		edges = append(edges, commodity.EdgeNFT)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommodityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commodity.EdgeCard:
		ids := make([]ent.Value, 0, len(m.card))
		for id := range m.card {
			ids = append(ids, id)
		}
		return ids
	case commodity.EdgeNFT:
		ids := make([]ent.Value, 0, len(m._NFT))
		for id := range m._NFT {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommodityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcard != nil {
		edges = append(edges, commodity.EdgeCard)
	}
	if m.removed_NFT != nil {
		edges = append(edges, commodity.EdgeNFT)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommodityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case commodity.EdgeCard:
		ids := make([]ent.Value, 0, len(m.removedcard))
		for id := range m.removedcard {
			ids = append(ids, id)
		}
		return ids
	case commodity.EdgeNFT:
		ids := make([]ent.Value, 0, len(m.removed_NFT))
		for id := range m.removed_NFT {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommodityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcard {
		edges = append(edges, commodity.EdgeCard)
	}
	if m.cleared_NFT {
		edges = append(edges, commodity.EdgeNFT)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommodityMutation) EdgeCleared(name string) bool {
	switch name {
	case commodity.EdgeCard:
		return m.clearedcard
	case commodity.EdgeNFT:
		return m.cleared_NFT
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommodityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Commodity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommodityMutation) ResetEdge(name string) error {
	switch name {
	case commodity.EdgeCard:
		m.ResetCard()
		return nil
	case commodity.EdgeNFT:
		m.ResetNFT()
		return nil
	}
	return fmt.Errorf("unknown Commodity edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	mobile_no     *string
	email         *string
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Contact, error)
	predicates    []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id uint64) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contact entities.
func (m *ContactMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ContactMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ContactMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ContactMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ContactMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ContactMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ContactMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *ContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ContactMutation) ClearName() {
	m.name = nil
	m.clearedFields[contact.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ContactMutation) NameCleared() bool {
	_, ok := m.clearedFields[contact.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ContactMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, contact.FieldName)
}

// SetMobileNo sets the "mobile_no" field.
func (m *ContactMutation) SetMobileNo(s string) {
	m.mobile_no = &s
}

// MobileNo returns the value of the "mobile_no" field in the mutation.
func (m *ContactMutation) MobileNo() (r string, exists bool) {
	v := m.mobile_no
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNo returns the old "mobile_no" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldMobileNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNo: %w", err)
	}
	return oldValue.MobileNo, nil
}

// ClearMobileNo clears the value of the "mobile_no" field.
func (m *ContactMutation) ClearMobileNo() {
	m.mobile_no = nil
	m.clearedFields[contact.FieldMobileNo] = struct{}{}
}

// MobileNoCleared returns if the "mobile_no" field was cleared in this mutation.
func (m *ContactMutation) MobileNoCleared() bool {
	_, ok := m.clearedFields[contact.FieldMobileNo]
	return ok
}

// ResetMobileNo resets all changes to the "mobile_no" field.
func (m *ContactMutation) ResetMobileNo() {
	m.mobile_no = nil
	delete(m.clearedFields, contact.FieldMobileNo)
}

// SetEmail sets the "email" field.
func (m *ContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *ContactMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[contact.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *ContactMutation) EmailCleared() bool {
	_, ok := m.clearedFields[contact.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, contact.FieldEmail)
}

// SetUserID sets the "user_id" field.
func (m *ContactMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ContactMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ContactMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *ContactMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ContactMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ContactMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *ContactMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ContactMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the ContactMutation builder.
func (m *ContactMutation) Where(ps ...predicate.Contact) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, contact.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, contact.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, contact.FieldName)
	}
	if m.mobile_no != nil {
		fields = append(fields, contact.FieldMobileNo)
	}
	if m.email != nil {
		fields = append(fields, contact.FieldEmail)
	}
	if m.owner != nil {
		fields = append(fields, contact.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldCreateTime:
		return m.CreateTime()
	case contact.FieldUpdateTime:
		return m.UpdateTime()
	case contact.FieldName:
		return m.Name()
	case contact.FieldMobileNo:
		return m.MobileNo()
	case contact.FieldEmail:
		return m.Email()
	case contact.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case contact.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case contact.FieldName:
		return m.OldName(ctx)
	case contact.FieldMobileNo:
		return m.OldMobileNo(ctx)
	case contact.FieldEmail:
		return m.OldEmail(ctx)
	case contact.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case contact.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case contact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contact.FieldMobileNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNo(v)
		return nil
	case contact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contact.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contact.FieldName) {
		fields = append(fields, contact.FieldName)
	}
	if m.FieldCleared(contact.FieldMobileNo) {
		fields = append(fields, contact.FieldMobileNo)
	}
	if m.FieldCleared(contact.FieldEmail) {
		fields = append(fields, contact.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	switch name {
	case contact.FieldName:
		m.ClearName()
		return nil
	case contact.FieldMobileNo:
		m.ClearMobileNo()
		return nil
	case contact.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case contact.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case contact.FieldName:
		m.ResetName()
		return nil
	case contact.FieldMobileNo:
		m.ResetMobileNo()
		return nil
	case contact.FieldEmail:
		m.ResetEmail()
		return nil
	case contact.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, contact.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, contact.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	switch name {
	case contact.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	switch name {
	case contact.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Contact edge %s", name)
}

// CreationMutation represents an operation that mutates the Creation nodes in the graph.
type CreationMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Creation, error)
	predicates    []predicate.Creation
}

var _ ent.Mutation = (*CreationMutation)(nil)

// creationOption allows management of the mutation configuration using functional options.
type creationOption func(*CreationMutation)

// newCreationMutation creates new mutation for the Creation entity.
func newCreationMutation(c config, op Op, opts ...creationOption) *CreationMutation {
	m := &CreationMutation{
		config:        c,
		op:            op,
		typ:           TypeCreation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCreationID sets the ID field of the mutation.
func withCreationID(id uint64) creationOption {
	return func(m *CreationMutation) {
		var (
			err   error
			once  sync.Once
			value *Creation
		)
		m.oldValue = func(ctx context.Context) (*Creation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Creation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCreation sets the old Creation of the mutation.
func withCreation(node *Creation) creationOption {
	return func(m *CreationMutation) {
		m.oldValue = func(context.Context) (*Creation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CreationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CreationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Creation entities.
func (m *CreationMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CreationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CreationMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Creation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CreationMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CreationMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Creation entity.
// If the Creation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreationMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CreationMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CreationMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CreationMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Creation entity.
// If the Creation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreationMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CreationMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CreationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CreationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Creation entity.
// If the Creation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CreationMutation) ResetName() {
	m.name = nil
}

// SetUserID sets the "user_id" field.
func (m *CreationMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CreationMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Creation entity.
// If the Creation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CreationMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CreationMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *CreationMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *CreationMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *CreationMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CreationMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CreationMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CreationMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the CreationMutation builder.
func (m *CreationMutation) Where(ps ...predicate.Creation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CreationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Creation).
func (m *CreationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CreationMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, creation.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, creation.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, creation.FieldName)
	}
	if m.owner != nil {
		fields = append(fields, creation.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CreationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case creation.FieldCreateTime:
		return m.CreateTime()
	case creation.FieldUpdateTime:
		return m.UpdateTime()
	case creation.FieldName:
		return m.Name()
	case creation.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CreationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case creation.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case creation.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case creation.FieldName:
		return m.OldName(ctx)
	case creation.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Creation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case creation.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case creation.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case creation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case creation.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Creation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CreationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CreationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CreationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Creation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CreationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CreationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CreationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Creation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CreationMutation) ResetField(name string) error {
	switch name {
	case creation.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case creation.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case creation.FieldName:
		m.ResetName()
		return nil
	case creation.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Creation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CreationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, creation.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CreationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case creation.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CreationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CreationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CreationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, creation.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CreationMutation) EdgeCleared(name string) bool {
	switch name {
	case creation.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CreationMutation) ClearEdge(name string) error {
	switch name {
	case creation.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Creation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CreationMutation) ResetEdge(name string) error {
	switch name {
	case creation.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Creation edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	_type         *device.Type
	code          *string
	push_token    *string
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Device, error)
	predicates    []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id uint64) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeviceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Device.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *DeviceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DeviceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DeviceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DeviceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DeviceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DeviceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *DeviceMutation) SetType(d device.Type) {
	m._type = &d
}

// GetType returns the value of the "type" field in the mutation.
func (m *DeviceMutation) GetType() (r device.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldType(ctx context.Context) (v device.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DeviceMutation) ResetType() {
	m._type = nil
}

// SetCode sets the "code" field.
func (m *DeviceMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DeviceMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *DeviceMutation) ClearCode() {
	m.code = nil
	m.clearedFields[device.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *DeviceMutation) CodeCleared() bool {
	_, ok := m.clearedFields[device.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *DeviceMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, device.FieldCode)
}

// SetPushToken sets the "push_token" field.
func (m *DeviceMutation) SetPushToken(s string) {
	m.push_token = &s
}

// PushToken returns the value of the "push_token" field in the mutation.
func (m *DeviceMutation) PushToken() (r string, exists bool) {
	v := m.push_token
	if v == nil {
		return
	}
	return *v, true
}

// OldPushToken returns the old "push_token" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldPushToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushToken: %w", err)
	}
	return oldValue.PushToken, nil
}

// ClearPushToken clears the value of the "push_token" field.
func (m *DeviceMutation) ClearPushToken() {
	m.push_token = nil
	m.clearedFields[device.FieldPushToken] = struct{}{}
}

// PushTokenCleared returns if the "push_token" field was cleared in this mutation.
func (m *DeviceMutation) PushTokenCleared() bool {
	_, ok := m.clearedFields[device.FieldPushToken]
	return ok
}

// ResetPushToken resets all changes to the "push_token" field.
func (m *DeviceMutation) ResetPushToken() {
	m.push_token = nil
	delete(m.clearedFields, device.FieldPushToken)
}

// SetUserID sets the "user_id" field.
func (m *DeviceMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DeviceMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DeviceMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *DeviceMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *DeviceMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *DeviceMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *DeviceMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *DeviceMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *DeviceMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, device.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, device.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, device.FieldType)
	}
	if m.code != nil {
		fields = append(fields, device.FieldCode)
	}
	if m.push_token != nil {
		fields = append(fields, device.FieldPushToken)
	}
	if m.owner != nil {
		fields = append(fields, device.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldCreateTime:
		return m.CreateTime()
	case device.FieldUpdateTime:
		return m.UpdateTime()
	case device.FieldType:
		return m.GetType()
	case device.FieldCode:
		return m.Code()
	case device.FieldPushToken:
		return m.PushToken()
	case device.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case device.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case device.FieldType:
		return m.OldType(ctx)
	case device.FieldCode:
		return m.OldCode(ctx)
	case device.FieldPushToken:
		return m.OldPushToken(ctx)
	case device.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case device.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case device.FieldType:
		v, ok := value.(device.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case device.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case device.FieldPushToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushToken(v)
		return nil
	case device.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldCode) {
		fields = append(fields, device.FieldCode)
	}
	if m.FieldCleared(device.FieldPushToken) {
		fields = append(fields, device.FieldPushToken)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldCode:
		m.ClearCode()
		return nil
	case device.FieldPushToken:
		m.ClearPushToken()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case device.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case device.FieldType:
		m.ResetType()
		return nil
	case device.FieldCode:
		m.ResetCode()
		return nil
	case device.FieldPushToken:
		m.ResetPushToken()
		return nil
	case device.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, device.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case device.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, device.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case device.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	switch name {
	case device.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	switch name {
	case device.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Device edge %s", name)
}

// FeedbackMutation represents an operation that mutates the Feedback nodes in the graph.
type FeedbackMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	_type         *feedback.Type
	reason        *string
	item_id       *uint64
	additem_id    *int64
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Feedback, error)
	predicates    []predicate.Feedback
}

var _ ent.Mutation = (*FeedbackMutation)(nil)

// feedbackOption allows management of the mutation configuration using functional options.
type feedbackOption func(*FeedbackMutation)

// newFeedbackMutation creates new mutation for the Feedback entity.
func newFeedbackMutation(c config, op Op, opts ...feedbackOption) *FeedbackMutation {
	m := &FeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedbackID sets the ID field of the mutation.
func withFeedbackID(id int) feedbackOption {
	return func(m *FeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *Feedback
		)
		m.oldValue = func(ctx context.Context) (*Feedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedback sets the old Feedback of the mutation.
func withFeedback(node *Feedback) feedbackOption {
	return func(m *FeedbackMutation) {
		m.oldValue = func(context.Context) (*Feedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedbackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedbackMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FeedbackMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FeedbackMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FeedbackMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FeedbackMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FeedbackMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FeedbackMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *FeedbackMutation) SetType(f feedback.Type) {
	m._type = &f
}

// GetType returns the value of the "type" field in the mutation.
func (m *FeedbackMutation) GetType() (r feedback.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldType(ctx context.Context) (v feedback.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *FeedbackMutation) ResetType() {
	m._type = nil
}

// SetReason sets the "reason" field.
func (m *FeedbackMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *FeedbackMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *FeedbackMutation) ResetReason() {
	m.reason = nil
}

// SetItemID sets the "item_id" field.
func (m *FeedbackMutation) SetItemID(u uint64) {
	m.item_id = &u
	m.additem_id = nil
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *FeedbackMutation) ItemID() (r uint64, exists bool) {
	v := m.item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldItemID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// AddItemID adds u to the "item_id" field.
func (m *FeedbackMutation) AddItemID(u int64) {
	if m.additem_id != nil {
		*m.additem_id += u
	} else {
		m.additem_id = &u
	}
}

// AddedItemID returns the value that was added to the "item_id" field in this mutation.
func (m *FeedbackMutation) AddedItemID() (r int64, exists bool) {
	v := m.additem_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearItemID clears the value of the "item_id" field.
func (m *FeedbackMutation) ClearItemID() {
	m.item_id = nil
	m.additem_id = nil
	m.clearedFields[feedback.FieldItemID] = struct{}{}
}

// ItemIDCleared returns if the "item_id" field was cleared in this mutation.
func (m *FeedbackMutation) ItemIDCleared() bool {
	_, ok := m.clearedFields[feedback.FieldItemID]
	return ok
}

// ResetItemID resets all changes to the "item_id" field.
func (m *FeedbackMutation) ResetItemID() {
	m.item_id = nil
	m.additem_id = nil
	delete(m.clearedFields, feedback.FieldItemID)
}

// SetUserID sets the "user_id" field.
func (m *FeedbackMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FeedbackMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FeedbackMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *FeedbackMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *FeedbackMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *FeedbackMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *FeedbackMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *FeedbackMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *FeedbackMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the FeedbackMutation builder.
func (m *FeedbackMutation) Where(ps ...predicate.Feedback) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FeedbackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Feedback).
func (m *FeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedbackMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, feedback.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, feedback.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, feedback.FieldType)
	}
	if m.reason != nil {
		fields = append(fields, feedback.FieldReason)
	}
	if m.item_id != nil {
		fields = append(fields, feedback.FieldItemID)
	}
	if m.owner != nil {
		fields = append(fields, feedback.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldCreateTime:
		return m.CreateTime()
	case feedback.FieldUpdateTime:
		return m.UpdateTime()
	case feedback.FieldType:
		return m.GetType()
	case feedback.FieldReason:
		return m.Reason()
	case feedback.FieldItemID:
		return m.ItemID()
	case feedback.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedback.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case feedback.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case feedback.FieldType:
		return m.OldType(ctx)
	case feedback.FieldReason:
		return m.OldReason(ctx)
	case feedback.FieldItemID:
		return m.OldItemID(ctx)
	case feedback.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Feedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case feedback.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case feedback.FieldType:
		v, ok := value.(feedback.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case feedback.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case feedback.FieldItemID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case feedback.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedbackMutation) AddedFields() []string {
	var fields []string
	if m.additem_id != nil {
		fields = append(fields, feedback.FieldItemID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedbackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldItemID:
		return m.AddedItemID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldItemID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddItemID(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feedback.FieldItemID) {
		fields = append(fields, feedback.FieldItemID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedbackMutation) ClearField(name string) error {
	switch name {
	case feedback.FieldItemID:
		m.ClearItemID()
		return nil
	}
	return fmt.Errorf("unknown Feedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedbackMutation) ResetField(name string) error {
	switch name {
	case feedback.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case feedback.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case feedback.FieldType:
		m.ResetType()
		return nil
	case feedback.FieldReason:
		m.ResetReason()
		return nil
	case feedback.FieldItemID:
		m.ResetItemID()
		return nil
	case feedback.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, feedback.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedback.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, feedback.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case feedback.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedbackMutation) ClearEdge(name string) error {
	switch name {
	case feedback.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Feedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedbackMutation) ResetEdge(name string) error {
	switch name {
	case feedback.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Feedback edge %s", name)
}

// FriendshipMutation represents an operation that mutates the Friendship nodes in the graph.
type FriendshipMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	status        *friendship.Status
	request_type  *friendship.RequestType
	curr_type     *friendship.CurrType
	clearedFields map[string]struct{}
	user          *uint64
	cleareduser   bool
	friend        *uint64
	clearedfriend bool
	done          bool
	oldValue      func(context.Context) (*Friendship, error)
	predicates    []predicate.Friendship
}

var _ ent.Mutation = (*FriendshipMutation)(nil)

// friendshipOption allows management of the mutation configuration using functional options.
type friendshipOption func(*FriendshipMutation)

// newFriendshipMutation creates new mutation for the Friendship entity.
func newFriendshipMutation(c config, op Op, opts ...friendshipOption) *FriendshipMutation {
	m := &FriendshipMutation{
		config:        c,
		op:            op,
		typ:           TypeFriendship,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFriendshipID sets the ID field of the mutation.
func withFriendshipID(id int) friendshipOption {
	return func(m *FriendshipMutation) {
		var (
			err   error
			once  sync.Once
			value *Friendship
		)
		m.oldValue = func(ctx context.Context) (*Friendship, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Friendship.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFriendship sets the old Friendship of the mutation.
func withFriendship(node *Friendship) friendshipOption {
	return func(m *FriendshipMutation) {
		m.oldValue = func(context.Context) (*Friendship, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FriendshipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FriendshipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FriendshipMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FriendshipMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Friendship.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *FriendshipMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *FriendshipMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *FriendshipMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *FriendshipMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *FriendshipMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *FriendshipMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStatus sets the "status" field.
func (m *FriendshipMutation) SetStatus(f friendship.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FriendshipMutation) Status() (r friendship.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldStatus(ctx context.Context) (v friendship.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FriendshipMutation) ResetStatus() {
	m.status = nil
}

// SetRequestType sets the "request_type" field.
func (m *FriendshipMutation) SetRequestType(ft friendship.RequestType) {
	m.request_type = &ft
}

// RequestType returns the value of the "request_type" field in the mutation.
func (m *FriendshipMutation) RequestType() (r friendship.RequestType, exists bool) {
	v := m.request_type
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestType returns the old "request_type" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldRequestType(ctx context.Context) (v friendship.RequestType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestType: %w", err)
	}
	return oldValue.RequestType, nil
}

// ResetRequestType resets all changes to the "request_type" field.
func (m *FriendshipMutation) ResetRequestType() {
	m.request_type = nil
}

// SetCurrType sets the "curr_type" field.
func (m *FriendshipMutation) SetCurrType(ft friendship.CurrType) {
	m.curr_type = &ft
}

// CurrType returns the value of the "curr_type" field in the mutation.
func (m *FriendshipMutation) CurrType() (r friendship.CurrType, exists bool) {
	v := m.curr_type
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrType returns the old "curr_type" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldCurrType(ctx context.Context) (v friendship.CurrType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrType: %w", err)
	}
	return oldValue.CurrType, nil
}

// ResetCurrType resets all changes to the "curr_type" field.
func (m *FriendshipMutation) ResetCurrType() {
	m.curr_type = nil
}

// SetUserID sets the "user_id" field.
func (m *FriendshipMutation) SetUserID(u uint64) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *FriendshipMutation) UserID() (r uint64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *FriendshipMutation) ResetUserID() {
	m.user = nil
}

// SetFriendID sets the "friend_id" field.
func (m *FriendshipMutation) SetFriendID(u uint64) {
	m.friend = &u
}

// FriendID returns the value of the "friend_id" field in the mutation.
func (m *FriendshipMutation) FriendID() (r uint64, exists bool) {
	v := m.friend
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendID returns the old "friend_id" field's value of the Friendship entity.
// If the Friendship object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FriendshipMutation) OldFriendID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendID: %w", err)
	}
	return oldValue.FriendID, nil
}

// ResetFriendID resets all changes to the "friend_id" field.
func (m *FriendshipMutation) ResetFriendID() {
	m.friend = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *FriendshipMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *FriendshipMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) UserIDs() (ids []uint64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *FriendshipMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearFriend clears the "friend" edge to the User entity.
func (m *FriendshipMutation) ClearFriend() {
	m.clearedfriend = true
}

// FriendCleared reports if the "friend" edge to the User entity was cleared.
func (m *FriendshipMutation) FriendCleared() bool {
	return m.clearedfriend
}

// FriendIDs returns the "friend" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FriendID instead. It exists only for internal usage by the builders.
func (m *FriendshipMutation) FriendIDs() (ids []uint64) {
	if id := m.friend; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFriend resets all changes to the "friend" edge.
func (m *FriendshipMutation) ResetFriend() {
	m.friend = nil
	m.clearedfriend = false
}

// Where appends a list predicates to the FriendshipMutation builder.
func (m *FriendshipMutation) Where(ps ...predicate.Friendship) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FriendshipMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Friendship).
func (m *FriendshipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FriendshipMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, friendship.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, friendship.FieldUpdateTime)
	}
	if m.status != nil {
		fields = append(fields, friendship.FieldStatus)
	}
	if m.request_type != nil {
		fields = append(fields, friendship.FieldRequestType)
	}
	if m.curr_type != nil {
		fields = append(fields, friendship.FieldCurrType)
	}
	if m.user != nil {
		fields = append(fields, friendship.FieldUserID)
	}
	if m.friend != nil {
		fields = append(fields, friendship.FieldFriendID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FriendshipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case friendship.FieldCreateTime:
		return m.CreateTime()
	case friendship.FieldUpdateTime:
		return m.UpdateTime()
	case friendship.FieldStatus:
		return m.Status()
	case friendship.FieldRequestType:
		return m.RequestType()
	case friendship.FieldCurrType:
		return m.CurrType()
	case friendship.FieldUserID:
		return m.UserID()
	case friendship.FieldFriendID:
		return m.FriendID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FriendshipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case friendship.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case friendship.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case friendship.FieldStatus:
		return m.OldStatus(ctx)
	case friendship.FieldRequestType:
		return m.OldRequestType(ctx)
	case friendship.FieldCurrType:
		return m.OldCurrType(ctx)
	case friendship.FieldUserID:
		return m.OldUserID(ctx)
	case friendship.FieldFriendID:
		return m.OldFriendID(ctx)
	}
	return nil, fmt.Errorf("unknown Friendship field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case friendship.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case friendship.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case friendship.FieldStatus:
		v, ok := value.(friendship.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case friendship.FieldRequestType:
		v, ok := value.(friendship.RequestType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestType(v)
		return nil
	case friendship.FieldCurrType:
		v, ok := value.(friendship.CurrType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrType(v)
		return nil
	case friendship.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case friendship.FieldFriendID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendID(v)
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FriendshipMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FriendshipMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FriendshipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Friendship numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FriendshipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FriendshipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FriendshipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Friendship nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FriendshipMutation) ResetField(name string) error {
	switch name {
	case friendship.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case friendship.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case friendship.FieldStatus:
		m.ResetStatus()
		return nil
	case friendship.FieldRequestType:
		m.ResetRequestType()
		return nil
	case friendship.FieldCurrType:
		m.ResetCurrType()
		return nil
	case friendship.FieldUserID:
		m.ResetUserID()
		return nil
	case friendship.FieldFriendID:
		m.ResetFriendID()
		return nil
	}
	return fmt.Errorf("unknown Friendship field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FriendshipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, friendship.EdgeUser)
	}
	if m.friend != nil {
		edges = append(edges, friendship.EdgeFriend)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FriendshipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case friendship.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case friendship.EdgeFriend:
		if id := m.friend; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FriendshipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FriendshipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FriendshipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, friendship.EdgeUser)
	}
	if m.clearedfriend {
		edges = append(edges, friendship.EdgeFriend)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FriendshipMutation) EdgeCleared(name string) bool {
	switch name {
	case friendship.EdgeUser:
		return m.cleareduser
	case friendship.EdgeFriend:
		return m.clearedfriend
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FriendshipMutation) ClearEdge(name string) error {
	switch name {
	case friendship.EdgeUser:
		m.ClearUser()
		return nil
	case friendship.EdgeFriend:
		m.ClearFriend()
		return nil
	}
	return fmt.Errorf("unknown Friendship unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FriendshipMutation) ResetEdge(name string) error {
	switch name {
	case friendship.EdgeUser:
		m.ResetUser()
		return nil
	case friendship.EdgeFriend:
		m.ResetFriend()
		return nil
	}
	return fmt.Errorf("unknown Friendship edge %s", name)
}

// HiddenMutation represents an operation that mutates the Hidden nodes in the graph.
type HiddenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	hidden_id     *uint64
	addhidden_id  *int64
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Hidden, error)
	predicates    []predicate.Hidden
}

var _ ent.Mutation = (*HiddenMutation)(nil)

// hiddenOption allows management of the mutation configuration using functional options.
type hiddenOption func(*HiddenMutation)

// newHiddenMutation creates new mutation for the Hidden entity.
func newHiddenMutation(c config, op Op, opts ...hiddenOption) *HiddenMutation {
	m := &HiddenMutation{
		config:        c,
		op:            op,
		typ:           TypeHidden,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHiddenID sets the ID field of the mutation.
func withHiddenID(id int) hiddenOption {
	return func(m *HiddenMutation) {
		var (
			err   error
			once  sync.Once
			value *Hidden
		)
		m.oldValue = func(ctx context.Context) (*Hidden, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Hidden.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHidden sets the old Hidden of the mutation.
func withHidden(node *Hidden) hiddenOption {
	return func(m *HiddenMutation) {
		m.oldValue = func(context.Context) (*Hidden, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HiddenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HiddenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HiddenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HiddenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Hidden.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *HiddenMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *HiddenMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Hidden entity.
// If the Hidden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiddenMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *HiddenMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *HiddenMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *HiddenMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Hidden entity.
// If the Hidden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiddenMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *HiddenMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUserID sets the "user_id" field.
func (m *HiddenMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *HiddenMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Hidden entity.
// If the Hidden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiddenMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *HiddenMutation) ResetUserID() {
	m.owner = nil
}

// SetHiddenID sets the "hidden_id" field.
func (m *HiddenMutation) SetHiddenID(u uint64) {
	m.hidden_id = &u
	m.addhidden_id = nil
}

// HiddenID returns the value of the "hidden_id" field in the mutation.
func (m *HiddenMutation) HiddenID() (r uint64, exists bool) {
	v := m.hidden_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHiddenID returns the old "hidden_id" field's value of the Hidden entity.
// If the Hidden object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HiddenMutation) OldHiddenID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHiddenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHiddenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHiddenID: %w", err)
	}
	return oldValue.HiddenID, nil
}

// AddHiddenID adds u to the "hidden_id" field.
func (m *HiddenMutation) AddHiddenID(u int64) {
	if m.addhidden_id != nil {
		*m.addhidden_id += u
	} else {
		m.addhidden_id = &u
	}
}

// AddedHiddenID returns the value that was added to the "hidden_id" field in this mutation.
func (m *HiddenMutation) AddedHiddenID() (r int64, exists bool) {
	v := m.addhidden_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetHiddenID resets all changes to the "hidden_id" field.
func (m *HiddenMutation) ResetHiddenID() {
	m.hidden_id = nil
	m.addhidden_id = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *HiddenMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *HiddenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *HiddenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *HiddenMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *HiddenMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *HiddenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the HiddenMutation builder.
func (m *HiddenMutation) Where(ps ...predicate.Hidden) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *HiddenMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Hidden).
func (m *HiddenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HiddenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, hidden.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, hidden.FieldUpdateTime)
	}
	if m.owner != nil {
		fields = append(fields, hidden.FieldUserID)
	}
	if m.hidden_id != nil {
		fields = append(fields, hidden.FieldHiddenID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HiddenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hidden.FieldCreateTime:
		return m.CreateTime()
	case hidden.FieldUpdateTime:
		return m.UpdateTime()
	case hidden.FieldUserID:
		return m.UserID()
	case hidden.FieldHiddenID:
		return m.HiddenID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HiddenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hidden.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case hidden.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case hidden.FieldUserID:
		return m.OldUserID(ctx)
	case hidden.FieldHiddenID:
		return m.OldHiddenID(ctx)
	}
	return nil, fmt.Errorf("unknown Hidden field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiddenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hidden.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case hidden.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case hidden.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case hidden.FieldHiddenID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHiddenID(v)
		return nil
	}
	return fmt.Errorf("unknown Hidden field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HiddenMutation) AddedFields() []string {
	var fields []string
	if m.addhidden_id != nil {
		fields = append(fields, hidden.FieldHiddenID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HiddenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hidden.FieldHiddenID:
		return m.AddedHiddenID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HiddenMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hidden.FieldHiddenID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHiddenID(v)
		return nil
	}
	return fmt.Errorf("unknown Hidden numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HiddenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HiddenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HiddenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Hidden nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HiddenMutation) ResetField(name string) error {
	switch name {
	case hidden.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case hidden.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case hidden.FieldUserID:
		m.ResetUserID()
		return nil
	case hidden.FieldHiddenID:
		m.ResetHiddenID()
		return nil
	}
	return fmt.Errorf("unknown Hidden field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HiddenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, hidden.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HiddenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hidden.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HiddenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HiddenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HiddenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, hidden.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HiddenMutation) EdgeCleared(name string) bool {
	switch name {
	case hidden.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HiddenMutation) ClearEdge(name string) error {
	switch name {
	case hidden.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Hidden unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HiddenMutation) ResetEdge(name string) error {
	switch name {
	case hidden.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Hidden edge %s", name)
}

// InviteCodeMutation represents an operation that mutates the Invite_Code nodes in the graph.
type InviteCodeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	_type          *invite_code.Type
	status         *invite_code.Status
	code           *string
	consumer_id    *uint64
	addconsumer_id *int64
	clearedFields  map[string]struct{}
	owner          *uint64
	clearedowner   bool
	done           bool
	oldValue       func(context.Context) (*Invite_Code, error)
	predicates     []predicate.Invite_Code
}

var _ ent.Mutation = (*InviteCodeMutation)(nil)

// inviteCodeOption allows management of the mutation configuration using functional options.
type inviteCodeOption func(*InviteCodeMutation)

// newInviteCodeMutation creates new mutation for the Invite_Code entity.
func newInviteCodeMutation(c config, op Op, opts ...inviteCodeOption) *InviteCodeMutation {
	m := &InviteCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite_Code,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvite_CodeID sets the ID field of the mutation.
func withInvite_CodeID(id int) inviteCodeOption {
	return func(m *InviteCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite_Code
		)
		m.oldValue = func(ctx context.Context) (*Invite_Code, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite_Code.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite_Code sets the old Invite_Code of the mutation.
func withInvite_Code(node *Invite_Code) inviteCodeOption {
	return func(m *InviteCodeMutation) {
		m.oldValue = func(context.Context) (*Invite_Code, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteCodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteCodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite_Code.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *InviteCodeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *InviteCodeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Invite_Code entity.
// If the Invite_Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteCodeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *InviteCodeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *InviteCodeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *InviteCodeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Invite_Code entity.
// If the Invite_Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteCodeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *InviteCodeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *InviteCodeMutation) SetType(ic invite_code.Type) {
	m._type = &ic
}

// GetType returns the value of the "type" field in the mutation.
func (m *InviteCodeMutation) GetType() (r invite_code.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Invite_Code entity.
// If the Invite_Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteCodeMutation) OldType(ctx context.Context) (v invite_code.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InviteCodeMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *InviteCodeMutation) SetStatus(ic invite_code.Status) {
	m.status = &ic
}

// Status returns the value of the "status" field in the mutation.
func (m *InviteCodeMutation) Status() (r invite_code.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Invite_Code entity.
// If the Invite_Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteCodeMutation) OldStatus(ctx context.Context) (v invite_code.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InviteCodeMutation) ResetStatus() {
	m.status = nil
}

// SetCode sets the "code" field.
func (m *InviteCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *InviteCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Invite_Code entity.
// If the Invite_Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *InviteCodeMutation) ResetCode() {
	m.code = nil
}

// SetConsumerID sets the "consumer_id" field.
func (m *InviteCodeMutation) SetConsumerID(u uint64) {
	m.consumer_id = &u
	m.addconsumer_id = nil
}

// ConsumerID returns the value of the "consumer_id" field in the mutation.
func (m *InviteCodeMutation) ConsumerID() (r uint64, exists bool) {
	v := m.consumer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumerID returns the old "consumer_id" field's value of the Invite_Code entity.
// If the Invite_Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteCodeMutation) OldConsumerID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumerID: %w", err)
	}
	return oldValue.ConsumerID, nil
}

// AddConsumerID adds u to the "consumer_id" field.
func (m *InviteCodeMutation) AddConsumerID(u int64) {
	if m.addconsumer_id != nil {
		*m.addconsumer_id += u
	} else {
		m.addconsumer_id = &u
	}
}

// AddedConsumerID returns the value that was added to the "consumer_id" field in this mutation.
func (m *InviteCodeMutation) AddedConsumerID() (r int64, exists bool) {
	v := m.addconsumer_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearConsumerID clears the value of the "consumer_id" field.
func (m *InviteCodeMutation) ClearConsumerID() {
	m.consumer_id = nil
	m.addconsumer_id = nil
	m.clearedFields[invite_code.FieldConsumerID] = struct{}{}
}

// ConsumerIDCleared returns if the "consumer_id" field was cleared in this mutation.
func (m *InviteCodeMutation) ConsumerIDCleared() bool {
	_, ok := m.clearedFields[invite_code.FieldConsumerID]
	return ok
}

// ResetConsumerID resets all changes to the "consumer_id" field.
func (m *InviteCodeMutation) ResetConsumerID() {
	m.consumer_id = nil
	m.addconsumer_id = nil
	delete(m.clearedFields, invite_code.FieldConsumerID)
}

// SetUserID sets the "user_id" field.
func (m *InviteCodeMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *InviteCodeMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Invite_Code entity.
// If the Invite_Code object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteCodeMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *InviteCodeMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *InviteCodeMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *InviteCodeMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *InviteCodeMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *InviteCodeMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InviteCodeMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *InviteCodeMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the InviteCodeMutation builder.
func (m *InviteCodeMutation) Where(ps ...predicate.Invite_Code) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InviteCodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Invite_Code).
func (m *InviteCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteCodeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, invite_code.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, invite_code.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, invite_code.FieldType)
	}
	if m.status != nil {
		fields = append(fields, invite_code.FieldStatus)
	}
	if m.code != nil {
		fields = append(fields, invite_code.FieldCode)
	}
	if m.consumer_id != nil {
		fields = append(fields, invite_code.FieldConsumerID)
	}
	if m.owner != nil {
		fields = append(fields, invite_code.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite_code.FieldCreateTime:
		return m.CreateTime()
	case invite_code.FieldUpdateTime:
		return m.UpdateTime()
	case invite_code.FieldType:
		return m.GetType()
	case invite_code.FieldStatus:
		return m.Status()
	case invite_code.FieldCode:
		return m.Code()
	case invite_code.FieldConsumerID:
		return m.ConsumerID()
	case invite_code.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite_code.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case invite_code.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case invite_code.FieldType:
		return m.OldType(ctx)
	case invite_code.FieldStatus:
		return m.OldStatus(ctx)
	case invite_code.FieldCode:
		return m.OldCode(ctx)
	case invite_code.FieldConsumerID:
		return m.OldConsumerID(ctx)
	case invite_code.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Invite_Code field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite_code.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case invite_code.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case invite_code.FieldType:
		v, ok := value.(invite_code.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case invite_code.FieldStatus:
		v, ok := value.(invite_code.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case invite_code.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case invite_code.FieldConsumerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumerID(v)
		return nil
	case invite_code.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Invite_Code field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteCodeMutation) AddedFields() []string {
	var fields []string
	if m.addconsumer_id != nil {
		fields = append(fields, invite_code.FieldConsumerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case invite_code.FieldConsumerID:
		return m.AddedConsumerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case invite_code.FieldConsumerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConsumerID(v)
		return nil
	}
	return fmt.Errorf("unknown Invite_Code numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invite_code.FieldConsumerID) {
		fields = append(fields, invite_code.FieldConsumerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteCodeMutation) ClearField(name string) error {
	switch name {
	case invite_code.FieldConsumerID:
		m.ClearConsumerID()
		return nil
	}
	return fmt.Errorf("unknown Invite_Code nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteCodeMutation) ResetField(name string) error {
	switch name {
	case invite_code.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case invite_code.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case invite_code.FieldType:
		m.ResetType()
		return nil
	case invite_code.FieldStatus:
		m.ResetStatus()
		return nil
	case invite_code.FieldCode:
		m.ResetCode()
		return nil
	case invite_code.FieldConsumerID:
		m.ResetConsumerID()
		return nil
	case invite_code.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Invite_Code field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, invite_code.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invite_code.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, invite_code.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case invite_code.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteCodeMutation) ClearEdge(name string) error {
	switch name {
	case invite_code.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Invite_Code unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteCodeMutation) ResetEdge(name string) error {
	switch name {
	case invite_code.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Invite_Code edge %s", name)
}

// JoinMutation represents an operation that mutates the Join nodes in the graph.
type JoinMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	join_at         *time.Time
	leave_at        *time.Time
	status          *join.Status
	clearedFields   map[string]struct{}
	user            *uint64
	cleareduser     bool
	cs_field        *uint64
	clearedcs_field bool
	done            bool
	oldValue        func(context.Context) (*Join, error)
	predicates      []predicate.Join
}

var _ ent.Mutation = (*JoinMutation)(nil)

// joinOption allows management of the mutation configuration using functional options.
type joinOption func(*JoinMutation)

// newJoinMutation creates new mutation for the Join entity.
func newJoinMutation(c config, op Op, opts ...joinOption) *JoinMutation {
	m := &JoinMutation{
		config:        c,
		op:            op,
		typ:           TypeJoin,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJoinID sets the ID field of the mutation.
func withJoinID(id int) joinOption {
	return func(m *JoinMutation) {
		var (
			err   error
			once  sync.Once
			value *Join
		)
		m.oldValue = func(ctx context.Context) (*Join, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Join.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJoin sets the old Join of the mutation.
func withJoin(node *Join) joinOption {
	return func(m *JoinMutation) {
		m.oldValue = func(context.Context) (*Join, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JoinMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JoinMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JoinMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JoinMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Join.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *JoinMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *JoinMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Join entity.
// If the Join object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JoinMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *JoinMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *JoinMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *JoinMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Join entity.
// If the Join object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JoinMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *JoinMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetJoinAt sets the "join_at" field.
func (m *JoinMutation) SetJoinAt(t time.Time) {
	m.join_at = &t
}

// JoinAt returns the value of the "join_at" field in the mutation.
func (m *JoinMutation) JoinAt() (r time.Time, exists bool) {
	v := m.join_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinAt returns the old "join_at" field's value of the Join entity.
// If the Join object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JoinMutation) OldJoinAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinAt: %w", err)
	}
	return oldValue.JoinAt, nil
}

// ResetJoinAt resets all changes to the "join_at" field.
func (m *JoinMutation) ResetJoinAt() {
	m.join_at = nil
}

// SetLeaveAt sets the "leave_at" field.
func (m *JoinMutation) SetLeaveAt(t time.Time) {
	m.leave_at = &t
}

// LeaveAt returns the value of the "leave_at" field in the mutation.
func (m *JoinMutation) LeaveAt() (r time.Time, exists bool) {
	v := m.leave_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaveAt returns the old "leave_at" field's value of the Join entity.
// If the Join object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JoinMutation) OldLeaveAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaveAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaveAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaveAt: %w", err)
	}
	return oldValue.LeaveAt, nil
}

// ClearLeaveAt clears the value of the "leave_at" field.
func (m *JoinMutation) ClearLeaveAt() {
	m.leave_at = nil
	m.clearedFields[join.FieldLeaveAt] = struct{}{}
}

// LeaveAtCleared returns if the "leave_at" field was cleared in this mutation.
func (m *JoinMutation) LeaveAtCleared() bool {
	_, ok := m.clearedFields[join.FieldLeaveAt]
	return ok
}

// ResetLeaveAt resets all changes to the "leave_at" field.
func (m *JoinMutation) ResetLeaveAt() {
	m.leave_at = nil
	delete(m.clearedFields, join.FieldLeaveAt)
}

// SetStatus sets the "status" field.
func (m *JoinMutation) SetStatus(j join.Status) {
	m.status = &j
}

// Status returns the value of the "status" field in the mutation.
func (m *JoinMutation) Status() (r join.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Join entity.
// If the Join object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JoinMutation) OldStatus(ctx context.Context) (v join.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JoinMutation) ResetStatus() {
	m.status = nil
}

// SetUserID sets the "user_id" field.
func (m *JoinMutation) SetUserID(u uint64) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *JoinMutation) UserID() (r uint64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Join entity.
// If the Join object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JoinMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *JoinMutation) ResetUserID() {
	m.user = nil
}

// SetCsFieldID sets the "cs_field_id" field.
func (m *JoinMutation) SetCsFieldID(u uint64) {
	m.cs_field = &u
}

// CsFieldID returns the value of the "cs_field_id" field in the mutation.
func (m *JoinMutation) CsFieldID() (r uint64, exists bool) {
	v := m.cs_field
	if v == nil {
		return
	}
	return *v, true
}

// OldCsFieldID returns the old "cs_field_id" field's value of the Join entity.
// If the Join object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JoinMutation) OldCsFieldID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCsFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCsFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCsFieldID: %w", err)
	}
	return oldValue.CsFieldID, nil
}

// ResetCsFieldID resets all changes to the "cs_field_id" field.
func (m *JoinMutation) ResetCsFieldID() {
	m.cs_field = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *JoinMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *JoinMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *JoinMutation) UserIDs() (ids []uint64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *JoinMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCsField clears the "cs_field" edge to the CSField entity.
func (m *JoinMutation) ClearCsField() {
	m.clearedcs_field = true
}

// CsFieldCleared reports if the "cs_field" edge to the CSField entity was cleared.
func (m *JoinMutation) CsFieldCleared() bool {
	return m.clearedcs_field
}

// CsFieldIDs returns the "cs_field" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CsFieldID instead. It exists only for internal usage by the builders.
func (m *JoinMutation) CsFieldIDs() (ids []uint64) {
	if id := m.cs_field; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCsField resets all changes to the "cs_field" edge.
func (m *JoinMutation) ResetCsField() {
	m.cs_field = nil
	m.clearedcs_field = false
}

// Where appends a list predicates to the JoinMutation builder.
func (m *JoinMutation) Where(ps ...predicate.Join) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *JoinMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Join).
func (m *JoinMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JoinMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, join.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, join.FieldUpdateTime)
	}
	if m.join_at != nil {
		fields = append(fields, join.FieldJoinAt)
	}
	if m.leave_at != nil {
		fields = append(fields, join.FieldLeaveAt)
	}
	if m.status != nil {
		fields = append(fields, join.FieldStatus)
	}
	if m.user != nil {
		fields = append(fields, join.FieldUserID)
	}
	if m.cs_field != nil {
		fields = append(fields, join.FieldCsFieldID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JoinMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case join.FieldCreateTime:
		return m.CreateTime()
	case join.FieldUpdateTime:
		return m.UpdateTime()
	case join.FieldJoinAt:
		return m.JoinAt()
	case join.FieldLeaveAt:
		return m.LeaveAt()
	case join.FieldStatus:
		return m.Status()
	case join.FieldUserID:
		return m.UserID()
	case join.FieldCsFieldID:
		return m.CsFieldID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JoinMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case join.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case join.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case join.FieldJoinAt:
		return m.OldJoinAt(ctx)
	case join.FieldLeaveAt:
		return m.OldLeaveAt(ctx)
	case join.FieldStatus:
		return m.OldStatus(ctx)
	case join.FieldUserID:
		return m.OldUserID(ctx)
	case join.FieldCsFieldID:
		return m.OldCsFieldID(ctx)
	}
	return nil, fmt.Errorf("unknown Join field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JoinMutation) SetField(name string, value ent.Value) error {
	switch name {
	case join.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case join.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case join.FieldJoinAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinAt(v)
		return nil
	case join.FieldLeaveAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaveAt(v)
		return nil
	case join.FieldStatus:
		v, ok := value.(join.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case join.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case join.FieldCsFieldID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCsFieldID(v)
		return nil
	}
	return fmt.Errorf("unknown Join field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JoinMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JoinMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JoinMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Join numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JoinMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(join.FieldLeaveAt) {
		fields = append(fields, join.FieldLeaveAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JoinMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JoinMutation) ClearField(name string) error {
	switch name {
	case join.FieldLeaveAt:
		m.ClearLeaveAt()
		return nil
	}
	return fmt.Errorf("unknown Join nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JoinMutation) ResetField(name string) error {
	switch name {
	case join.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case join.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case join.FieldJoinAt:
		m.ResetJoinAt()
		return nil
	case join.FieldLeaveAt:
		m.ResetLeaveAt()
		return nil
	case join.FieldStatus:
		m.ResetStatus()
		return nil
	case join.FieldUserID:
		m.ResetUserID()
		return nil
	case join.FieldCsFieldID:
		m.ResetCsFieldID()
		return nil
	}
	return fmt.Errorf("unknown Join field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JoinMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, join.EdgeUser)
	}
	if m.cs_field != nil {
		edges = append(edges, join.EdgeCsField)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JoinMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case join.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case join.EdgeCsField:
		if id := m.cs_field; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JoinMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JoinMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JoinMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, join.EdgeUser)
	}
	if m.clearedcs_field {
		edges = append(edges, join.EdgeCsField)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JoinMutation) EdgeCleared(name string) bool {
	switch name {
	case join.EdgeUser:
		return m.cleareduser
	case join.EdgeCsField:
		return m.clearedcs_field
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JoinMutation) ClearEdge(name string) error {
	switch name {
	case join.EdgeUser:
		m.ClearUser()
		return nil
	case join.EdgeCsField:
		m.ClearCsField()
		return nil
	}
	return fmt.Errorf("unknown Join unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JoinMutation) ResetEdge(name string) error {
	switch name {
	case join.EdgeUser:
		m.ResetUser()
		return nil
	case join.EdgeCsField:
		m.ResetCsField()
		return nil
	}
	return fmt.Errorf("unknown Join edge %s", name)
}

// MaskMutation represents an operation that mutates the Mask nodes in the graph.
type MaskMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	desc          *string
	_GUID         *string
	thumbnail_url *string
	status        *mask.Status
	_type         *mask.Type
	clearedFields map[string]struct{}
	bundle        map[uint64]struct{}
	removedbundle map[uint64]struct{}
	clearedbundle bool
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Mask, error)
	predicates    []predicate.Mask
}

var _ ent.Mutation = (*MaskMutation)(nil)

// maskOption allows management of the mutation configuration using functional options.
type maskOption func(*MaskMutation)

// newMaskMutation creates new mutation for the Mask entity.
func newMaskMutation(c config, op Op, opts ...maskOption) *MaskMutation {
	m := &MaskMutation{
		config:        c,
		op:            op,
		typ:           TypeMask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaskID sets the ID field of the mutation.
func withMaskID(id uint64) maskOption {
	return func(m *MaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Mask
		)
		m.oldValue = func(ctx context.Context) (*Mask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMask sets the old Mask of the mutation.
func withMask(node *Mask) maskOption {
	return func(m *MaskMutation) {
		m.oldValue = func(context.Context) (*Mask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mask entities.
func (m *MaskMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MaskMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MaskMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MaskMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MaskMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MaskMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MaskMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MaskMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MaskMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *MaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MaskMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *MaskMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *MaskMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *MaskMutation) ResetDesc() {
	m.desc = nil
}

// SetGUID sets the "GUID" field.
func (m *MaskMutation) SetGUID(s string) {
	m._GUID = &s
}

// GUID returns the value of the "GUID" field in the mutation.
func (m *MaskMutation) GUID() (r string, exists bool) {
	v := m._GUID
	if v == nil {
		return
	}
	return *v, true
}

// OldGUID returns the old "GUID" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldGUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGUID: %w", err)
	}
	return oldValue.GUID, nil
}

// ResetGUID resets all changes to the "GUID" field.
func (m *MaskMutation) ResetGUID() {
	m._GUID = nil
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *MaskMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *MaskMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *MaskMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
}

// SetStatus sets the "status" field.
func (m *MaskMutation) SetStatus(value mask.Status) {
	m.status = &value
}

// Status returns the value of the "status" field in the mutation.
func (m *MaskMutation) Status() (r mask.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldStatus(ctx context.Context) (v mask.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MaskMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *MaskMutation) SetType(value mask.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MaskMutation) GetType() (r mask.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldType(ctx context.Context) (v mask.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MaskMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user_id" field.
func (m *MaskMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MaskMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Mask entity.
// If the Mask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaskMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *MaskMutation) ClearUserID() {
	m.owner = nil
	m.clearedFields[mask.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *MaskMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[mask.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MaskMutation) ResetUserID() {
	m.owner = nil
	delete(m.clearedFields, mask.FieldUserID)
}

// AddBundleIDs adds the "bundle" edge to the Bundle entity by ids.
func (m *MaskMutation) AddBundleIDs(ids ...uint64) {
	if m.bundle == nil {
		m.bundle = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bundle[ids[i]] = struct{}{}
	}
}

// ClearBundle clears the "bundle" edge to the Bundle entity.
func (m *MaskMutation) ClearBundle() {
	m.clearedbundle = true
}

// BundleCleared reports if the "bundle" edge to the Bundle entity was cleared.
func (m *MaskMutation) BundleCleared() bool {
	return m.clearedbundle
}

// RemoveBundleIDs removes the "bundle" edge to the Bundle entity by IDs.
func (m *MaskMutation) RemoveBundleIDs(ids ...uint64) {
	if m.removedbundle == nil {
		m.removedbundle = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bundle, ids[i])
		m.removedbundle[ids[i]] = struct{}{}
	}
}

// RemovedBundle returns the removed IDs of the "bundle" edge to the Bundle entity.
func (m *MaskMutation) RemovedBundleIDs() (ids []uint64) {
	for id := range m.removedbundle {
		ids = append(ids, id)
	}
	return
}

// BundleIDs returns the "bundle" edge IDs in the mutation.
func (m *MaskMutation) BundleIDs() (ids []uint64) {
	for id := range m.bundle {
		ids = append(ids, id)
	}
	return
}

// ResetBundle resets all changes to the "bundle" edge.
func (m *MaskMutation) ResetBundle() {
	m.bundle = nil
	m.clearedbundle = false
	m.removedbundle = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *MaskMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *MaskMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *MaskMutation) OwnerCleared() bool {
	return m.UserIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MaskMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MaskMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MaskMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MaskMutation builder.
func (m *MaskMutation) Where(ps ...predicate.Mask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Mask).
func (m *MaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MaskMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, mask.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, mask.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, mask.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, mask.FieldDesc)
	}
	if m._GUID != nil {
		fields = append(fields, mask.FieldGUID)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, mask.FieldThumbnailURL)
	}
	if m.status != nil {
		fields = append(fields, mask.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, mask.FieldType)
	}
	if m.owner != nil {
		fields = append(fields, mask.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mask.FieldCreateTime:
		return m.CreateTime()
	case mask.FieldUpdateTime:
		return m.UpdateTime()
	case mask.FieldName:
		return m.Name()
	case mask.FieldDesc:
		return m.Desc()
	case mask.FieldGUID:
		return m.GUID()
	case mask.FieldThumbnailURL:
		return m.ThumbnailURL()
	case mask.FieldStatus:
		return m.Status()
	case mask.FieldType:
		return m.GetType()
	case mask.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mask.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case mask.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case mask.FieldName:
		return m.OldName(ctx)
	case mask.FieldDesc:
		return m.OldDesc(ctx)
	case mask.FieldGUID:
		return m.OldGUID(ctx)
	case mask.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case mask.FieldStatus:
		return m.OldStatus(ctx)
	case mask.FieldType:
		return m.OldType(ctx)
	case mask.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Mask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mask.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case mask.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case mask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mask.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case mask.FieldGUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGUID(v)
		return nil
	case mask.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case mask.FieldStatus:
		v, ok := value.(mask.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mask.FieldType:
		v, ok := value.(mask.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case mask.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Mask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MaskMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mask.FieldUserID) {
		fields = append(fields, mask.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaskMutation) ClearField(name string) error {
	switch name {
	case mask.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Mask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MaskMutation) ResetField(name string) error {
	switch name {
	case mask.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case mask.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case mask.FieldName:
		m.ResetName()
		return nil
	case mask.FieldDesc:
		m.ResetDesc()
		return nil
	case mask.FieldGUID:
		m.ResetGUID()
		return nil
	case mask.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case mask.FieldStatus:
		m.ResetStatus()
		return nil
	case mask.FieldType:
		m.ResetType()
		return nil
	case mask.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Mask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.bundle != nil {
		edges = append(edges, mask.EdgeBundle)
	}
	if m.owner != nil {
		edges = append(edges, mask.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mask.EdgeBundle:
		ids := make([]ent.Value, 0, len(m.bundle))
		for id := range m.bundle {
			ids = append(ids, id)
		}
		return ids
	case mask.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbundle != nil {
		edges = append(edges, mask.EdgeBundle)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mask.EdgeBundle:
		ids := make([]ent.Value, 0, len(m.removedbundle))
		for id := range m.removedbundle {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedbundle {
		edges = append(edges, mask.EdgeBundle)
	}
	if m.clearedowner {
		edges = append(edges, mask.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MaskMutation) EdgeCleared(name string) bool {
	switch name {
	case mask.EdgeBundle:
		return m.clearedbundle
	case mask.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MaskMutation) ClearEdge(name string) error {
	switch name {
	case mask.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Mask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MaskMutation) ResetEdge(name string) error {
	switch name {
	case mask.EdgeBundle:
		m.ResetBundle()
		return nil
	case mask.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Mask edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	_type         *message.Type
	content       *string
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id uint64) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Message entities.
func (m *MessageMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *MessageMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *MessageMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *MessageMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *MessageMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *MessageMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *MessageMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *MessageMutation) SetType(value message.Type) {
	m._type = &value
}

// GetType returns the value of the "type" field in the mutation.
func (m *MessageMutation) GetType() (r message.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldType(ctx context.Context) (v message.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MessageMutation) ResetType() {
	m._type = nil
}

// SetContent sets the "content" field.
func (m *MessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *MessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *MessageMutation) ClearContent() {
	m.content = nil
	m.clearedFields[message.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *MessageMutation) ContentCleared() bool {
	_, ok := m.clearedFields[message.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *MessageMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, message.FieldContent)
}

// SetUserID sets the "user_id" field.
func (m *MessageMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MessageMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MessageMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *MessageMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *MessageMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *MessageMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *MessageMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *MessageMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, message.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, message.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, message.FieldType)
	}
	if m.content != nil {
		fields = append(fields, message.FieldContent)
	}
	if m.owner != nil {
		fields = append(fields, message.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldCreateTime:
		return m.CreateTime()
	case message.FieldUpdateTime:
		return m.UpdateTime()
	case message.FieldType:
		return m.GetType()
	case message.FieldContent:
		return m.Content()
	case message.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case message.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case message.FieldType:
		return m.OldType(ctx)
	case message.FieldContent:
		return m.OldContent(ctx)
	case message.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case message.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case message.FieldType:
		v, ok := value.(message.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case message.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case message.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldContent) {
		fields = append(fields, message.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case message.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case message.FieldType:
		m.ResetType()
		return nil
	case message.FieldContent:
		m.ResetContent()
		return nil
	case message.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, message.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, message.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// NFTMutation represents an operation that mutates the NFT nodes in the graph.
type NFTMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	create_time           *time.Time
	update_time           *time.Time
	name                  *string
	desc                  *string
	creator_id            *uint64
	addcreator_id         *int64
	media_info_json       *[]string
	appendmedia_info_json []string
	media_url             *string
	media_durl            *string
	token_id              *string
	status                *nft.Status
	desc_json_url         *string
	desc_json_durl        *string
	pin_status            *nft.PinStatus
	contract_address      *string
	mint_card_num         *uint64
	addmint_card_num      *int64
	clearedFields         map[string]struct{}
	owner                 *uint64
	clearedowner          bool
	done                  bool
	oldValue              func(context.Context) (*NFT, error)
	predicates            []predicate.NFT
}

var _ ent.Mutation = (*NFTMutation)(nil)

// nftOption allows management of the mutation configuration using functional options.
type nftOption func(*NFTMutation)

// newNFTMutation creates new mutation for the NFT entity.
func newNFTMutation(c config, op Op, opts ...nftOption) *NFTMutation {
	m := &NFTMutation{
		config:        c,
		op:            op,
		typ:           TypeNFT,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNFTID sets the ID field of the mutation.
func withNFTID(id uint64) nftOption {
	return func(m *NFTMutation) {
		var (
			err   error
			once  sync.Once
			value *NFT
		)
		m.oldValue = func(ctx context.Context) (*NFT, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NFT.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNFT sets the old NFT of the mutation.
func withNFT(node *NFT) nftOption {
	return func(m *NFTMutation) {
		m.oldValue = func(context.Context) (*NFT, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NFTMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NFTMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NFT entities.
func (m *NFTMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NFTMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NFTMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NFT.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *NFTMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *NFTMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *NFTMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *NFTMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *NFTMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *NFTMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *NFTMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NFTMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NFTMutation) ResetName() {
	m.name = nil
}

// SetDesc sets the "desc" field.
func (m *NFTMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *NFTMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *NFTMutation) ResetDesc() {
	m.desc = nil
}

// SetUserID sets the "user_id" field.
func (m *NFTMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *NFTMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *NFTMutation) ClearUserID() {
	m.owner = nil
	m.clearedFields[nft.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *NFTMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[nft.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *NFTMutation) ResetUserID() {
	m.owner = nil
	delete(m.clearedFields, nft.FieldUserID)
}

// SetCreatorID sets the "creator_id" field.
func (m *NFTMutation) SetCreatorID(u uint64) {
	m.creator_id = &u
	m.addcreator_id = nil
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *NFTMutation) CreatorID() (r uint64, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldCreatorID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// AddCreatorID adds u to the "creator_id" field.
func (m *NFTMutation) AddCreatorID(u int64) {
	if m.addcreator_id != nil {
		*m.addcreator_id += u
	} else {
		m.addcreator_id = &u
	}
}

// AddedCreatorID returns the value that was added to the "creator_id" field in this mutation.
func (m *NFTMutation) AddedCreatorID() (r int64, exists bool) {
	v := m.addcreator_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatorID clears the value of the "creator_id" field.
func (m *NFTMutation) ClearCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
	m.clearedFields[nft.FieldCreatorID] = struct{}{}
}

// CreatorIDCleared returns if the "creator_id" field was cleared in this mutation.
func (m *NFTMutation) CreatorIDCleared() bool {
	_, ok := m.clearedFields[nft.FieldCreatorID]
	return ok
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *NFTMutation) ResetCreatorID() {
	m.creator_id = nil
	m.addcreator_id = nil
	delete(m.clearedFields, nft.FieldCreatorID)
}

// SetMediaInfoJSON sets the "media_info_json" field.
func (m *NFTMutation) SetMediaInfoJSON(s []string) {
	m.media_info_json = &s
	m.appendmedia_info_json = nil
}

// MediaInfoJSON returns the value of the "media_info_json" field in the mutation.
func (m *NFTMutation) MediaInfoJSON() (r []string, exists bool) {
	v := m.media_info_json
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaInfoJSON returns the old "media_info_json" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldMediaInfoJSON(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaInfoJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaInfoJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaInfoJSON: %w", err)
	}
	return oldValue.MediaInfoJSON, nil
}

// AppendMediaInfoJSON adds s to the "media_info_json" field.
func (m *NFTMutation) AppendMediaInfoJSON(s []string) {
	m.appendmedia_info_json = append(m.appendmedia_info_json, s...)
}

// AppendedMediaInfoJSON returns the list of values that were appended to the "media_info_json" field in this mutation.
func (m *NFTMutation) AppendedMediaInfoJSON() ([]string, bool) {
	if len(m.appendmedia_info_json) == 0 {
		return nil, false
	}
	return m.appendmedia_info_json, true
}

// ResetMediaInfoJSON resets all changes to the "media_info_json" field.
func (m *NFTMutation) ResetMediaInfoJSON() {
	m.media_info_json = nil
	m.appendmedia_info_json = nil
}

// SetMediaURL sets the "media_url" field.
func (m *NFTMutation) SetMediaURL(s string) {
	m.media_url = &s
}

// MediaURL returns the value of the "media_url" field in the mutation.
func (m *NFTMutation) MediaURL() (r string, exists bool) {
	v := m.media_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaURL returns the old "media_url" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldMediaURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaURL: %w", err)
	}
	return oldValue.MediaURL, nil
}

// ClearMediaURL clears the value of the "media_url" field.
func (m *NFTMutation) ClearMediaURL() {
	m.media_url = nil
	m.clearedFields[nft.FieldMediaURL] = struct{}{}
}

// MediaURLCleared returns if the "media_url" field was cleared in this mutation.
func (m *NFTMutation) MediaURLCleared() bool {
	_, ok := m.clearedFields[nft.FieldMediaURL]
	return ok
}

// ResetMediaURL resets all changes to the "media_url" field.
func (m *NFTMutation) ResetMediaURL() {
	m.media_url = nil
	delete(m.clearedFields, nft.FieldMediaURL)
}

// SetMediaDurl sets the "media_durl" field.
func (m *NFTMutation) SetMediaDurl(s string) {
	m.media_durl = &s
}

// MediaDurl returns the value of the "media_durl" field in the mutation.
func (m *NFTMutation) MediaDurl() (r string, exists bool) {
	v := m.media_durl
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaDurl returns the old "media_durl" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldMediaDurl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaDurl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaDurl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaDurl: %w", err)
	}
	return oldValue.MediaDurl, nil
}

// ClearMediaDurl clears the value of the "media_durl" field.
func (m *NFTMutation) ClearMediaDurl() {
	m.media_durl = nil
	m.clearedFields[nft.FieldMediaDurl] = struct{}{}
}

// MediaDurlCleared returns if the "media_durl" field was cleared in this mutation.
func (m *NFTMutation) MediaDurlCleared() bool {
	_, ok := m.clearedFields[nft.FieldMediaDurl]
	return ok
}

// ResetMediaDurl resets all changes to the "media_durl" field.
func (m *NFTMutation) ResetMediaDurl() {
	m.media_durl = nil
	delete(m.clearedFields, nft.FieldMediaDurl)
}

// SetTokenID sets the "token_id" field.
func (m *NFTMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *NFTMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ClearTokenID clears the value of the "token_id" field.
func (m *NFTMutation) ClearTokenID() {
	m.token_id = nil
	m.clearedFields[nft.FieldTokenID] = struct{}{}
}

// TokenIDCleared returns if the "token_id" field was cleared in this mutation.
func (m *NFTMutation) TokenIDCleared() bool {
	_, ok := m.clearedFields[nft.FieldTokenID]
	return ok
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *NFTMutation) ResetTokenID() {
	m.token_id = nil
	delete(m.clearedFields, nft.FieldTokenID)
}

// SetStatus sets the "status" field.
func (m *NFTMutation) SetStatus(n nft.Status) {
	m.status = &n
}

// Status returns the value of the "status" field in the mutation.
func (m *NFTMutation) Status() (r nft.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldStatus(ctx context.Context) (v nft.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *NFTMutation) ResetStatus() {
	m.status = nil
}

// SetDescJSONURL sets the "desc_json_url" field.
func (m *NFTMutation) SetDescJSONURL(s string) {
	m.desc_json_url = &s
}

// DescJSONURL returns the value of the "desc_json_url" field in the mutation.
func (m *NFTMutation) DescJSONURL() (r string, exists bool) {
	v := m.desc_json_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDescJSONURL returns the old "desc_json_url" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldDescJSONURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescJSONURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescJSONURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescJSONURL: %w", err)
	}
	return oldValue.DescJSONURL, nil
}

// ClearDescJSONURL clears the value of the "desc_json_url" field.
func (m *NFTMutation) ClearDescJSONURL() {
	m.desc_json_url = nil
	m.clearedFields[nft.FieldDescJSONURL] = struct{}{}
}

// DescJSONURLCleared returns if the "desc_json_url" field was cleared in this mutation.
func (m *NFTMutation) DescJSONURLCleared() bool {
	_, ok := m.clearedFields[nft.FieldDescJSONURL]
	return ok
}

// ResetDescJSONURL resets all changes to the "desc_json_url" field.
func (m *NFTMutation) ResetDescJSONURL() {
	m.desc_json_url = nil
	delete(m.clearedFields, nft.FieldDescJSONURL)
}

// SetDescJSONDurl sets the "desc_json_durl" field.
func (m *NFTMutation) SetDescJSONDurl(s string) {
	m.desc_json_durl = &s
}

// DescJSONDurl returns the value of the "desc_json_durl" field in the mutation.
func (m *NFTMutation) DescJSONDurl() (r string, exists bool) {
	v := m.desc_json_durl
	if v == nil {
		return
	}
	return *v, true
}

// OldDescJSONDurl returns the old "desc_json_durl" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldDescJSONDurl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescJSONDurl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescJSONDurl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescJSONDurl: %w", err)
	}
	return oldValue.DescJSONDurl, nil
}

// ClearDescJSONDurl clears the value of the "desc_json_durl" field.
func (m *NFTMutation) ClearDescJSONDurl() {
	m.desc_json_durl = nil
	m.clearedFields[nft.FieldDescJSONDurl] = struct{}{}
}

// DescJSONDurlCleared returns if the "desc_json_durl" field was cleared in this mutation.
func (m *NFTMutation) DescJSONDurlCleared() bool {
	_, ok := m.clearedFields[nft.FieldDescJSONDurl]
	return ok
}

// ResetDescJSONDurl resets all changes to the "desc_json_durl" field.
func (m *NFTMutation) ResetDescJSONDurl() {
	m.desc_json_durl = nil
	delete(m.clearedFields, nft.FieldDescJSONDurl)
}

// SetPinStatus sets the "pin_status" field.
func (m *NFTMutation) SetPinStatus(ns nft.PinStatus) {
	m.pin_status = &ns
}

// PinStatus returns the value of the "pin_status" field in the mutation.
func (m *NFTMutation) PinStatus() (r nft.PinStatus, exists bool) {
	v := m.pin_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPinStatus returns the old "pin_status" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldPinStatus(ctx context.Context) (v nft.PinStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPinStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPinStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPinStatus: %w", err)
	}
	return oldValue.PinStatus, nil
}

// ResetPinStatus resets all changes to the "pin_status" field.
func (m *NFTMutation) ResetPinStatus() {
	m.pin_status = nil
}

// SetContractAddress sets the "contract_address" field.
func (m *NFTMutation) SetContractAddress(s string) {
	m.contract_address = &s
}

// ContractAddress returns the value of the "contract_address" field in the mutation.
func (m *NFTMutation) ContractAddress() (r string, exists bool) {
	v := m.contract_address
	if v == nil {
		return
	}
	return *v, true
}

// OldContractAddress returns the old "contract_address" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldContractAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractAddress: %w", err)
	}
	return oldValue.ContractAddress, nil
}

// ResetContractAddress resets all changes to the "contract_address" field.
func (m *NFTMutation) ResetContractAddress() {
	m.contract_address = nil
}

// SetMintCardNum sets the "mint_card_num" field.
func (m *NFTMutation) SetMintCardNum(u uint64) {
	m.mint_card_num = &u
	m.addmint_card_num = nil
}

// MintCardNum returns the value of the "mint_card_num" field in the mutation.
func (m *NFTMutation) MintCardNum() (r uint64, exists bool) {
	v := m.mint_card_num
	if v == nil {
		return
	}
	return *v, true
}

// OldMintCardNum returns the old "mint_card_num" field's value of the NFT entity.
// If the NFT object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NFTMutation) OldMintCardNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMintCardNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMintCardNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMintCardNum: %w", err)
	}
	return oldValue.MintCardNum, nil
}

// AddMintCardNum adds u to the "mint_card_num" field.
func (m *NFTMutation) AddMintCardNum(u int64) {
	if m.addmint_card_num != nil {
		*m.addmint_card_num += u
	} else {
		m.addmint_card_num = &u
	}
}

// AddedMintCardNum returns the value that was added to the "mint_card_num" field in this mutation.
func (m *NFTMutation) AddedMintCardNum() (r int64, exists bool) {
	v := m.addmint_card_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetMintCardNum resets all changes to the "mint_card_num" field.
func (m *NFTMutation) ResetMintCardNum() {
	m.mint_card_num = nil
	m.addmint_card_num = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *NFTMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *NFTMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *NFTMutation) OwnerCleared() bool {
	return m.UserIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *NFTMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *NFTMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *NFTMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the NFTMutation builder.
func (m *NFTMutation) Where(ps ...predicate.NFT) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NFTMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (NFT).
func (m *NFTMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NFTMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.create_time != nil {
		fields = append(fields, nft.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, nft.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, nft.FieldName)
	}
	if m.desc != nil {
		fields = append(fields, nft.FieldDesc)
	}
	if m.owner != nil {
		fields = append(fields, nft.FieldUserID)
	}
	if m.creator_id != nil {
		fields = append(fields, nft.FieldCreatorID)
	}
	if m.media_info_json != nil {
		fields = append(fields, nft.FieldMediaInfoJSON)
	}
	if m.media_url != nil {
		fields = append(fields, nft.FieldMediaURL)
	}
	if m.media_durl != nil {
		fields = append(fields, nft.FieldMediaDurl)
	}
	if m.token_id != nil {
		fields = append(fields, nft.FieldTokenID)
	}
	if m.status != nil {
		fields = append(fields, nft.FieldStatus)
	}
	if m.desc_json_url != nil {
		fields = append(fields, nft.FieldDescJSONURL)
	}
	if m.desc_json_durl != nil {
		fields = append(fields, nft.FieldDescJSONDurl)
	}
	if m.pin_status != nil {
		fields = append(fields, nft.FieldPinStatus)
	}
	if m.contract_address != nil {
		fields = append(fields, nft.FieldContractAddress)
	}
	if m.mint_card_num != nil {
		fields = append(fields, nft.FieldMintCardNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NFTMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldCreateTime:
		return m.CreateTime()
	case nft.FieldUpdateTime:
		return m.UpdateTime()
	case nft.FieldName:
		return m.Name()
	case nft.FieldDesc:
		return m.Desc()
	case nft.FieldUserID:
		return m.UserID()
	case nft.FieldCreatorID:
		return m.CreatorID()
	case nft.FieldMediaInfoJSON:
		return m.MediaInfoJSON()
	case nft.FieldMediaURL:
		return m.MediaURL()
	case nft.FieldMediaDurl:
		return m.MediaDurl()
	case nft.FieldTokenID:
		return m.TokenID()
	case nft.FieldStatus:
		return m.Status()
	case nft.FieldDescJSONURL:
		return m.DescJSONURL()
	case nft.FieldDescJSONDurl:
		return m.DescJSONDurl()
	case nft.FieldPinStatus:
		return m.PinStatus()
	case nft.FieldContractAddress:
		return m.ContractAddress()
	case nft.FieldMintCardNum:
		return m.MintCardNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NFTMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nft.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case nft.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case nft.FieldName:
		return m.OldName(ctx)
	case nft.FieldDesc:
		return m.OldDesc(ctx)
	case nft.FieldUserID:
		return m.OldUserID(ctx)
	case nft.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case nft.FieldMediaInfoJSON:
		return m.OldMediaInfoJSON(ctx)
	case nft.FieldMediaURL:
		return m.OldMediaURL(ctx)
	case nft.FieldMediaDurl:
		return m.OldMediaDurl(ctx)
	case nft.FieldTokenID:
		return m.OldTokenID(ctx)
	case nft.FieldStatus:
		return m.OldStatus(ctx)
	case nft.FieldDescJSONURL:
		return m.OldDescJSONURL(ctx)
	case nft.FieldDescJSONDurl:
		return m.OldDescJSONDurl(ctx)
	case nft.FieldPinStatus:
		return m.OldPinStatus(ctx)
	case nft.FieldContractAddress:
		return m.OldContractAddress(ctx)
	case nft.FieldMintCardNum:
		return m.OldMintCardNum(ctx)
	}
	return nil, fmt.Errorf("unknown NFT field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nft.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case nft.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case nft.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nft.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case nft.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case nft.FieldCreatorID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case nft.FieldMediaInfoJSON:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaInfoJSON(v)
		return nil
	case nft.FieldMediaURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaURL(v)
		return nil
	case nft.FieldMediaDurl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaDurl(v)
		return nil
	case nft.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case nft.FieldStatus:
		v, ok := value.(nft.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case nft.FieldDescJSONURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescJSONURL(v)
		return nil
	case nft.FieldDescJSONDurl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescJSONDurl(v)
		return nil
	case nft.FieldPinStatus:
		v, ok := value.(nft.PinStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPinStatus(v)
		return nil
	case nft.FieldContractAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractAddress(v)
		return nil
	case nft.FieldMintCardNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMintCardNum(v)
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NFTMutation) AddedFields() []string {
	var fields []string
	if m.addcreator_id != nil {
		fields = append(fields, nft.FieldCreatorID)
	}
	if m.addmint_card_num != nil {
		fields = append(fields, nft.FieldMintCardNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NFTMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case nft.FieldCreatorID:
		return m.AddedCreatorID()
	case nft.FieldMintCardNum:
		return m.AddedMintCardNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NFTMutation) AddField(name string, value ent.Value) error {
	switch name {
	case nft.FieldCreatorID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatorID(v)
		return nil
	case nft.FieldMintCardNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMintCardNum(v)
		return nil
	}
	return fmt.Errorf("unknown NFT numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NFTMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(nft.FieldUserID) {
		fields = append(fields, nft.FieldUserID)
	}
	if m.FieldCleared(nft.FieldCreatorID) {
		fields = append(fields, nft.FieldCreatorID)
	}
	if m.FieldCleared(nft.FieldMediaURL) {
		fields = append(fields, nft.FieldMediaURL)
	}
	if m.FieldCleared(nft.FieldMediaDurl) {
		fields = append(fields, nft.FieldMediaDurl)
	}
	if m.FieldCleared(nft.FieldTokenID) {
		fields = append(fields, nft.FieldTokenID)
	}
	if m.FieldCleared(nft.FieldDescJSONURL) {
		fields = append(fields, nft.FieldDescJSONURL)
	}
	if m.FieldCleared(nft.FieldDescJSONDurl) {
		fields = append(fields, nft.FieldDescJSONDurl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NFTMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NFTMutation) ClearField(name string) error {
	switch name {
	case nft.FieldUserID:
		m.ClearUserID()
		return nil
	case nft.FieldCreatorID:
		m.ClearCreatorID()
		return nil
	case nft.FieldMediaURL:
		m.ClearMediaURL()
		return nil
	case nft.FieldMediaDurl:
		m.ClearMediaDurl()
		return nil
	case nft.FieldTokenID:
		m.ClearTokenID()
		return nil
	case nft.FieldDescJSONURL:
		m.ClearDescJSONURL()
		return nil
	case nft.FieldDescJSONDurl:
		m.ClearDescJSONDurl()
		return nil
	}
	return fmt.Errorf("unknown NFT nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NFTMutation) ResetField(name string) error {
	switch name {
	case nft.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case nft.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case nft.FieldName:
		m.ResetName()
		return nil
	case nft.FieldDesc:
		m.ResetDesc()
		return nil
	case nft.FieldUserID:
		m.ResetUserID()
		return nil
	case nft.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case nft.FieldMediaInfoJSON:
		m.ResetMediaInfoJSON()
		return nil
	case nft.FieldMediaURL:
		m.ResetMediaURL()
		return nil
	case nft.FieldMediaDurl:
		m.ResetMediaDurl()
		return nil
	case nft.FieldTokenID:
		m.ResetTokenID()
		return nil
	case nft.FieldStatus:
		m.ResetStatus()
		return nil
	case nft.FieldDescJSONURL:
		m.ResetDescJSONURL()
		return nil
	case nft.FieldDescJSONDurl:
		m.ResetDescJSONDurl()
		return nil
	case nft.FieldPinStatus:
		m.ResetPinStatus()
		return nil
	case nft.FieldContractAddress:
		m.ResetContractAddress()
		return nil
	case nft.FieldMintCardNum:
		m.ResetMintCardNum()
		return nil
	}
	return fmt.Errorf("unknown NFT field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NFTMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, nft.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NFTMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nft.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NFTMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NFTMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NFTMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, nft.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NFTMutation) EdgeCleared(name string) bool {
	switch name {
	case nft.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NFTMutation) ClearEdge(name string) error {
	switch name {
	case nft.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown NFT unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NFTMutation) ResetEdge(name string) error {
	switch name {
	case nft.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown NFT edge %s", name)
}

// ReactionMutation represents an operation that mutates the Reaction nodes in the graph.
type ReactionMutation struct {
	config
	op             Op
	typ            string
	id             *int
	create_time    *time.Time
	update_time    *time.Time
	isLOL          *bool
	isOMG          *bool
	isCool         *bool
	isNooo         *bool
	isDAMN         *bool
	clearedFields  map[string]struct{}
	timedew        *uint64
	clearedtimedew bool
	user           *uint64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*Reaction, error)
	predicates     []predicate.Reaction
}

var _ ent.Mutation = (*ReactionMutation)(nil)

// reactionOption allows management of the mutation configuration using functional options.
type reactionOption func(*ReactionMutation)

// newReactionMutation creates new mutation for the Reaction entity.
func newReactionMutation(c config, op Op, opts ...reactionOption) *ReactionMutation {
	m := &ReactionMutation{
		config:        c,
		op:            op,
		typ:           TypeReaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReactionID sets the ID field of the mutation.
func withReactionID(id int) reactionOption {
	return func(m *ReactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Reaction
		)
		m.oldValue = func(ctx context.Context) (*Reaction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReaction sets the old Reaction of the mutation.
func withReaction(node *Reaction) reactionOption {
	return func(m *ReactionMutation) {
		m.oldValue = func(context.Context) (*Reaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReactionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reaction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *ReactionMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ReactionMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ReactionMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ReactionMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ReactionMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ReactionMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetIsLOL sets the "isLOL" field.
func (m *ReactionMutation) SetIsLOL(b bool) {
	m.isLOL = &b
}

// IsLOL returns the value of the "isLOL" field in the mutation.
func (m *ReactionMutation) IsLOL() (r bool, exists bool) {
	v := m.isLOL
	if v == nil {
		return
	}
	return *v, true
}

// OldIsLOL returns the old "isLOL" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldIsLOL(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsLOL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsLOL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsLOL: %w", err)
	}
	return oldValue.IsLOL, nil
}

// ResetIsLOL resets all changes to the "isLOL" field.
func (m *ReactionMutation) ResetIsLOL() {
	m.isLOL = nil
}

// SetIsOMG sets the "isOMG" field.
func (m *ReactionMutation) SetIsOMG(b bool) {
	m.isOMG = &b
}

// IsOMG returns the value of the "isOMG" field in the mutation.
func (m *ReactionMutation) IsOMG() (r bool, exists bool) {
	v := m.isOMG
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOMG returns the old "isOMG" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldIsOMG(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOMG is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOMG requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOMG: %w", err)
	}
	return oldValue.IsOMG, nil
}

// ResetIsOMG resets all changes to the "isOMG" field.
func (m *ReactionMutation) ResetIsOMG() {
	m.isOMG = nil
}

// SetIsCool sets the "isCool" field.
func (m *ReactionMutation) SetIsCool(b bool) {
	m.isCool = &b
}

// IsCool returns the value of the "isCool" field in the mutation.
func (m *ReactionMutation) IsCool() (r bool, exists bool) {
	v := m.isCool
	if v == nil {
		return
	}
	return *v, true
}

// OldIsCool returns the old "isCool" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldIsCool(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsCool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsCool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsCool: %w", err)
	}
	return oldValue.IsCool, nil
}

// ResetIsCool resets all changes to the "isCool" field.
func (m *ReactionMutation) ResetIsCool() {
	m.isCool = nil
}

// SetIsNooo sets the "isNooo" field.
func (m *ReactionMutation) SetIsNooo(b bool) {
	m.isNooo = &b
}

// IsNooo returns the value of the "isNooo" field in the mutation.
func (m *ReactionMutation) IsNooo() (r bool, exists bool) {
	v := m.isNooo
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNooo returns the old "isNooo" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldIsNooo(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNooo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNooo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNooo: %w", err)
	}
	return oldValue.IsNooo, nil
}

// ResetIsNooo resets all changes to the "isNooo" field.
func (m *ReactionMutation) ResetIsNooo() {
	m.isNooo = nil
}

// SetIsDAMN sets the "isDAMN" field.
func (m *ReactionMutation) SetIsDAMN(b bool) {
	m.isDAMN = &b
}

// IsDAMN returns the value of the "isDAMN" field in the mutation.
func (m *ReactionMutation) IsDAMN() (r bool, exists bool) {
	v := m.isDAMN
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDAMN returns the old "isDAMN" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldIsDAMN(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDAMN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDAMN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDAMN: %w", err)
	}
	return oldValue.IsDAMN, nil
}

// ResetIsDAMN resets all changes to the "isDAMN" field.
func (m *ReactionMutation) ResetIsDAMN() {
	m.isDAMN = nil
}

// SetTimeDewID sets the "time_dew_id" field.
func (m *ReactionMutation) SetTimeDewID(u uint64) {
	m.timedew = &u
}

// TimeDewID returns the value of the "time_dew_id" field in the mutation.
func (m *ReactionMutation) TimeDewID() (r uint64, exists bool) {
	v := m.timedew
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeDewID returns the old "time_dew_id" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldTimeDewID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeDewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeDewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeDewID: %w", err)
	}
	return oldValue.TimeDewID, nil
}

// ResetTimeDewID resets all changes to the "time_dew_id" field.
func (m *ReactionMutation) ResetTimeDewID() {
	m.timedew = nil
}

// SetUserID sets the "user_id" field.
func (m *ReactionMutation) SetUserID(u uint64) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ReactionMutation) UserID() (r uint64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Reaction entity.
// If the Reaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReactionMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ReactionMutation) ResetUserID() {
	m.user = nil
}

// SetTimedewID sets the "timedew" edge to the TimeDew entity by id.
func (m *ReactionMutation) SetTimedewID(id uint64) {
	m.timedew = &id
}

// ClearTimedew clears the "timedew" edge to the TimeDew entity.
func (m *ReactionMutation) ClearTimedew() {
	m.clearedtimedew = true
}

// TimedewCleared reports if the "timedew" edge to the TimeDew entity was cleared.
func (m *ReactionMutation) TimedewCleared() bool {
	return m.clearedtimedew
}

// TimedewID returns the "timedew" edge ID in the mutation.
func (m *ReactionMutation) TimedewID() (id uint64, exists bool) {
	if m.timedew != nil {
		return *m.timedew, true
	}
	return
}

// TimedewIDs returns the "timedew" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TimedewID instead. It exists only for internal usage by the builders.
func (m *ReactionMutation) TimedewIDs() (ids []uint64) {
	if id := m.timedew; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTimedew resets all changes to the "timedew" edge.
func (m *ReactionMutation) ResetTimedew() {
	m.timedew = nil
	m.clearedtimedew = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *ReactionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ReactionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ReactionMutation) UserIDs() (ids []uint64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ReactionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ReactionMutation builder.
func (m *ReactionMutation) Where(ps ...predicate.Reaction) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Reaction).
func (m *ReactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReactionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, reaction.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, reaction.FieldUpdateTime)
	}
	if m.isLOL != nil {
		fields = append(fields, reaction.FieldIsLOL)
	}
	if m.isOMG != nil {
		fields = append(fields, reaction.FieldIsOMG)
	}
	if m.isCool != nil {
		fields = append(fields, reaction.FieldIsCool)
	}
	if m.isNooo != nil {
		fields = append(fields, reaction.FieldIsNooo)
	}
	if m.isDAMN != nil {
		fields = append(fields, reaction.FieldIsDAMN)
	}
	if m.timedew != nil {
		fields = append(fields, reaction.FieldTimeDewID)
	}
	if m.user != nil {
		fields = append(fields, reaction.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reaction.FieldCreateTime:
		return m.CreateTime()
	case reaction.FieldUpdateTime:
		return m.UpdateTime()
	case reaction.FieldIsLOL:
		return m.IsLOL()
	case reaction.FieldIsOMG:
		return m.IsOMG()
	case reaction.FieldIsCool:
		return m.IsCool()
	case reaction.FieldIsNooo:
		return m.IsNooo()
	case reaction.FieldIsDAMN:
		return m.IsDAMN()
	case reaction.FieldTimeDewID:
		return m.TimeDewID()
	case reaction.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reaction.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case reaction.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case reaction.FieldIsLOL:
		return m.OldIsLOL(ctx)
	case reaction.FieldIsOMG:
		return m.OldIsOMG(ctx)
	case reaction.FieldIsCool:
		return m.OldIsCool(ctx)
	case reaction.FieldIsNooo:
		return m.OldIsNooo(ctx)
	case reaction.FieldIsDAMN:
		return m.OldIsDAMN(ctx)
	case reaction.FieldTimeDewID:
		return m.OldTimeDewID(ctx)
	case reaction.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Reaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reaction.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case reaction.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case reaction.FieldIsLOL:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsLOL(v)
		return nil
	case reaction.FieldIsOMG:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOMG(v)
		return nil
	case reaction.FieldIsCool:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsCool(v)
		return nil
	case reaction.FieldIsNooo:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNooo(v)
		return nil
	case reaction.FieldIsDAMN:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDAMN(v)
		return nil
	case reaction.FieldTimeDewID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeDewID(v)
		return nil
	case reaction.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Reaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReactionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Reaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReactionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReactionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Reaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReactionMutation) ResetField(name string) error {
	switch name {
	case reaction.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case reaction.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case reaction.FieldIsLOL:
		m.ResetIsLOL()
		return nil
	case reaction.FieldIsOMG:
		m.ResetIsOMG()
		return nil
	case reaction.FieldIsCool:
		m.ResetIsCool()
		return nil
	case reaction.FieldIsNooo:
		m.ResetIsNooo()
		return nil
	case reaction.FieldIsDAMN:
		m.ResetIsDAMN()
		return nil
	case reaction.FieldTimeDewID:
		m.ResetTimeDewID()
		return nil
	case reaction.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Reaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.timedew != nil {
		edges = append(edges, reaction.EdgeTimedew)
	}
	if m.user != nil {
		edges = append(edges, reaction.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReactionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reaction.EdgeTimedew:
		if id := m.timedew; id != nil {
			return []ent.Value{*id}
		}
	case reaction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtimedew {
		edges = append(edges, reaction.EdgeTimedew)
	}
	if m.cleareduser {
		edges = append(edges, reaction.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReactionMutation) EdgeCleared(name string) bool {
	switch name {
	case reaction.EdgeTimedew:
		return m.clearedtimedew
	case reaction.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReactionMutation) ClearEdge(name string) error {
	switch name {
	case reaction.EdgeTimedew:
		m.ClearTimedew()
		return nil
	case reaction.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Reaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReactionMutation) ResetEdge(name string) error {
	switch name {
	case reaction.EdgeTimedew:
		m.ResetTimedew()
		return nil
	case reaction.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Reaction edge %s", name)
}

// RuleMutation represents an operation that mutates the Rule nodes in the graph.
type RuleMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	clearedFields map[string]struct{}
	used          map[uint64]struct{}
	removedused   map[uint64]struct{}
	clearedused   bool
	done          bool
	oldValue      func(context.Context) (*Rule, error)
	predicates    []predicate.Rule
}

var _ ent.Mutation = (*RuleMutation)(nil)

// ruleOption allows management of the mutation configuration using functional options.
type ruleOption func(*RuleMutation)

// newRuleMutation creates new mutation for the Rule entity.
func newRuleMutation(c config, op Op, opts ...ruleOption) *RuleMutation {
	m := &RuleMutation{
		config:        c,
		op:            op,
		typ:           TypeRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRuleID sets the ID field of the mutation.
func withRuleID(id uint64) ruleOption {
	return func(m *RuleMutation) {
		var (
			err   error
			once  sync.Once
			value *Rule
		)
		m.oldValue = func(ctx context.Context) (*Rule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRule sets the old Rule of the mutation.
func withRule(node *Rule) ruleOption {
	return func(m *RuleMutation) {
		m.oldValue = func(context.Context) (*Rule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Rule entities.
func (m *RuleMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RuleMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RuleMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *RuleMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RuleMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RuleMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RuleMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RuleMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RuleMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *RuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Rule entity.
// If the Rule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RuleMutation) ResetName() {
	m.name = nil
}

// AddUsedIDs adds the "used" edge to the Card entity by ids.
func (m *RuleMutation) AddUsedIDs(ids ...uint64) {
	if m.used == nil {
		m.used = make(map[uint64]struct{})
	}
	for i := range ids {
		m.used[ids[i]] = struct{}{}
	}
}

// ClearUsed clears the "used" edge to the Card entity.
func (m *RuleMutation) ClearUsed() {
	m.clearedused = true
}

// UsedCleared reports if the "used" edge to the Card entity was cleared.
func (m *RuleMutation) UsedCleared() bool {
	return m.clearedused
}

// RemoveUsedIDs removes the "used" edge to the Card entity by IDs.
func (m *RuleMutation) RemoveUsedIDs(ids ...uint64) {
	if m.removedused == nil {
		m.removedused = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.used, ids[i])
		m.removedused[ids[i]] = struct{}{}
	}
}

// RemovedUsed returns the removed IDs of the "used" edge to the Card entity.
func (m *RuleMutation) RemovedUsedIDs() (ids []uint64) {
	for id := range m.removedused {
		ids = append(ids, id)
	}
	return
}

// UsedIDs returns the "used" edge IDs in the mutation.
func (m *RuleMutation) UsedIDs() (ids []uint64) {
	for id := range m.used {
		ids = append(ids, id)
	}
	return
}

// ResetUsed resets all changes to the "used" edge.
func (m *RuleMutation) ResetUsed() {
	m.used = nil
	m.clearedused = false
	m.removedused = nil
}

// Where appends a list predicates to the RuleMutation builder.
func (m *RuleMutation) Where(ps ...predicate.Rule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rule).
func (m *RuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, rule.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, rule.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, rule.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rule.FieldCreateTime:
		return m.CreateTime()
	case rule.FieldUpdateTime:
		return m.UpdateTime()
	case rule.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rule.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case rule.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case rule.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Rule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rule.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case rule.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case rule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Rule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RuleMutation) ResetField(name string) error {
	switch name {
	case rule.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case rule.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case rule.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Rule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.used != nil {
		edges = append(edges, rule.EdgeUsed)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeUsed:
		ids := make([]ent.Value, 0, len(m.used))
		for id := range m.used {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedused != nil {
		edges = append(edges, rule.EdgeUsed)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rule.EdgeUsed:
		ids := make([]ent.Value, 0, len(m.removedused))
		for id := range m.removedused {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedused {
		edges = append(edges, rule.EdgeUsed)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RuleMutation) EdgeCleared(name string) bool {
	switch name {
	case rule.EdgeUsed:
		return m.clearedused
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RuleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Rule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RuleMutation) ResetEdge(name string) error {
	switch name {
	case rule.EdgeUsed:
		m.ResetUsed()
		return nil
	}
	return fmt.Errorf("unknown Rule edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint64
	create_time              *time.Time
	update_time              *time.Time
	friends_online           *bool
	time_dew_from_friends    *bool
	detailed_notification    *bool
	receive_field_invitation *bool
	see_my_location          *bool
	camera                   *bool
	microphone               *bool
	health_data              *bool
	time_dew_location        *bool
	time_dew_microphone      *bool
	time_dew_Lora            *bool
	public_collection        *bool
	clearedFields            map[string]struct{}
	owner                    *uint64
	clearedowner             bool
	done                     bool
	oldValue                 func(context.Context) (*Setting, error)
	predicates               []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uint64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Setting entities.
func (m *SettingMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *SettingMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SettingMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SettingMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SettingMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SettingMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SettingMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetFriendsOnline sets the "friends_online" field.
func (m *SettingMutation) SetFriendsOnline(b bool) {
	m.friends_online = &b
}

// FriendsOnline returns the value of the "friends_online" field in the mutation.
func (m *SettingMutation) FriendsOnline() (r bool, exists bool) {
	v := m.friends_online
	if v == nil {
		return
	}
	return *v, true
}

// OldFriendsOnline returns the old "friends_online" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldFriendsOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFriendsOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFriendsOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFriendsOnline: %w", err)
	}
	return oldValue.FriendsOnline, nil
}

// ClearFriendsOnline clears the value of the "friends_online" field.
func (m *SettingMutation) ClearFriendsOnline() {
	m.friends_online = nil
	m.clearedFields[setting.FieldFriendsOnline] = struct{}{}
}

// FriendsOnlineCleared returns if the "friends_online" field was cleared in this mutation.
func (m *SettingMutation) FriendsOnlineCleared() bool {
	_, ok := m.clearedFields[setting.FieldFriendsOnline]
	return ok
}

// ResetFriendsOnline resets all changes to the "friends_online" field.
func (m *SettingMutation) ResetFriendsOnline() {
	m.friends_online = nil
	delete(m.clearedFields, setting.FieldFriendsOnline)
}

// SetTimeDewFromFriends sets the "time_dew_from_friends" field.
func (m *SettingMutation) SetTimeDewFromFriends(b bool) {
	m.time_dew_from_friends = &b
}

// TimeDewFromFriends returns the value of the "time_dew_from_friends" field in the mutation.
func (m *SettingMutation) TimeDewFromFriends() (r bool, exists bool) {
	v := m.time_dew_from_friends
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeDewFromFriends returns the old "time_dew_from_friends" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldTimeDewFromFriends(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeDewFromFriends is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeDewFromFriends requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeDewFromFriends: %w", err)
	}
	return oldValue.TimeDewFromFriends, nil
}

// ClearTimeDewFromFriends clears the value of the "time_dew_from_friends" field.
func (m *SettingMutation) ClearTimeDewFromFriends() {
	m.time_dew_from_friends = nil
	m.clearedFields[setting.FieldTimeDewFromFriends] = struct{}{}
}

// TimeDewFromFriendsCleared returns if the "time_dew_from_friends" field was cleared in this mutation.
func (m *SettingMutation) TimeDewFromFriendsCleared() bool {
	_, ok := m.clearedFields[setting.FieldTimeDewFromFriends]
	return ok
}

// ResetTimeDewFromFriends resets all changes to the "time_dew_from_friends" field.
func (m *SettingMutation) ResetTimeDewFromFriends() {
	m.time_dew_from_friends = nil
	delete(m.clearedFields, setting.FieldTimeDewFromFriends)
}

// SetDetailedNotification sets the "detailed_notification" field.
func (m *SettingMutation) SetDetailedNotification(b bool) {
	m.detailed_notification = &b
}

// DetailedNotification returns the value of the "detailed_notification" field in the mutation.
func (m *SettingMutation) DetailedNotification() (r bool, exists bool) {
	v := m.detailed_notification
	if v == nil {
		return
	}
	return *v, true
}

// OldDetailedNotification returns the old "detailed_notification" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDetailedNotification(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetailedNotification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetailedNotification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetailedNotification: %w", err)
	}
	return oldValue.DetailedNotification, nil
}

// ClearDetailedNotification clears the value of the "detailed_notification" field.
func (m *SettingMutation) ClearDetailedNotification() {
	m.detailed_notification = nil
	m.clearedFields[setting.FieldDetailedNotification] = struct{}{}
}

// DetailedNotificationCleared returns if the "detailed_notification" field was cleared in this mutation.
func (m *SettingMutation) DetailedNotificationCleared() bool {
	_, ok := m.clearedFields[setting.FieldDetailedNotification]
	return ok
}

// ResetDetailedNotification resets all changes to the "detailed_notification" field.
func (m *SettingMutation) ResetDetailedNotification() {
	m.detailed_notification = nil
	delete(m.clearedFields, setting.FieldDetailedNotification)
}

// SetReceiveFieldInvitation sets the "receive_field_invitation" field.
func (m *SettingMutation) SetReceiveFieldInvitation(b bool) {
	m.receive_field_invitation = &b
}

// ReceiveFieldInvitation returns the value of the "receive_field_invitation" field in the mutation.
func (m *SettingMutation) ReceiveFieldInvitation() (r bool, exists bool) {
	v := m.receive_field_invitation
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiveFieldInvitation returns the old "receive_field_invitation" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldReceiveFieldInvitation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiveFieldInvitation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiveFieldInvitation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiveFieldInvitation: %w", err)
	}
	return oldValue.ReceiveFieldInvitation, nil
}

// ClearReceiveFieldInvitation clears the value of the "receive_field_invitation" field.
func (m *SettingMutation) ClearReceiveFieldInvitation() {
	m.receive_field_invitation = nil
	m.clearedFields[setting.FieldReceiveFieldInvitation] = struct{}{}
}

// ReceiveFieldInvitationCleared returns if the "receive_field_invitation" field was cleared in this mutation.
func (m *SettingMutation) ReceiveFieldInvitationCleared() bool {
	_, ok := m.clearedFields[setting.FieldReceiveFieldInvitation]
	return ok
}

// ResetReceiveFieldInvitation resets all changes to the "receive_field_invitation" field.
func (m *SettingMutation) ResetReceiveFieldInvitation() {
	m.receive_field_invitation = nil
	delete(m.clearedFields, setting.FieldReceiveFieldInvitation)
}

// SetSeeMyLocation sets the "see_my_location" field.
func (m *SettingMutation) SetSeeMyLocation(b bool) {
	m.see_my_location = &b
}

// SeeMyLocation returns the value of the "see_my_location" field in the mutation.
func (m *SettingMutation) SeeMyLocation() (r bool, exists bool) {
	v := m.see_my_location
	if v == nil {
		return
	}
	return *v, true
}

// OldSeeMyLocation returns the old "see_my_location" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldSeeMyLocation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeeMyLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeeMyLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeeMyLocation: %w", err)
	}
	return oldValue.SeeMyLocation, nil
}

// ClearSeeMyLocation clears the value of the "see_my_location" field.
func (m *SettingMutation) ClearSeeMyLocation() {
	m.see_my_location = nil
	m.clearedFields[setting.FieldSeeMyLocation] = struct{}{}
}

// SeeMyLocationCleared returns if the "see_my_location" field was cleared in this mutation.
func (m *SettingMutation) SeeMyLocationCleared() bool {
	_, ok := m.clearedFields[setting.FieldSeeMyLocation]
	return ok
}

// ResetSeeMyLocation resets all changes to the "see_my_location" field.
func (m *SettingMutation) ResetSeeMyLocation() {
	m.see_my_location = nil
	delete(m.clearedFields, setting.FieldSeeMyLocation)
}

// SetCamera sets the "camera" field.
func (m *SettingMutation) SetCamera(b bool) {
	m.camera = &b
}

// Camera returns the value of the "camera" field in the mutation.
func (m *SettingMutation) Camera() (r bool, exists bool) {
	v := m.camera
	if v == nil {
		return
	}
	return *v, true
}

// OldCamera returns the old "camera" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCamera(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCamera is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCamera requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCamera: %w", err)
	}
	return oldValue.Camera, nil
}

// ClearCamera clears the value of the "camera" field.
func (m *SettingMutation) ClearCamera() {
	m.camera = nil
	m.clearedFields[setting.FieldCamera] = struct{}{}
}

// CameraCleared returns if the "camera" field was cleared in this mutation.
func (m *SettingMutation) CameraCleared() bool {
	_, ok := m.clearedFields[setting.FieldCamera]
	return ok
}

// ResetCamera resets all changes to the "camera" field.
func (m *SettingMutation) ResetCamera() {
	m.camera = nil
	delete(m.clearedFields, setting.FieldCamera)
}

// SetMicrophone sets the "microphone" field.
func (m *SettingMutation) SetMicrophone(b bool) {
	m.microphone = &b
}

// Microphone returns the value of the "microphone" field in the mutation.
func (m *SettingMutation) Microphone() (r bool, exists bool) {
	v := m.microphone
	if v == nil {
		return
	}
	return *v, true
}

// OldMicrophone returns the old "microphone" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldMicrophone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMicrophone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMicrophone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMicrophone: %w", err)
	}
	return oldValue.Microphone, nil
}

// ClearMicrophone clears the value of the "microphone" field.
func (m *SettingMutation) ClearMicrophone() {
	m.microphone = nil
	m.clearedFields[setting.FieldMicrophone] = struct{}{}
}

// MicrophoneCleared returns if the "microphone" field was cleared in this mutation.
func (m *SettingMutation) MicrophoneCleared() bool {
	_, ok := m.clearedFields[setting.FieldMicrophone]
	return ok
}

// ResetMicrophone resets all changes to the "microphone" field.
func (m *SettingMutation) ResetMicrophone() {
	m.microphone = nil
	delete(m.clearedFields, setting.FieldMicrophone)
}

// SetHealthData sets the "health_data" field.
func (m *SettingMutation) SetHealthData(b bool) {
	m.health_data = &b
}

// HealthData returns the value of the "health_data" field in the mutation.
func (m *SettingMutation) HealthData() (r bool, exists bool) {
	v := m.health_data
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthData returns the old "health_data" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldHealthData(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthData: %w", err)
	}
	return oldValue.HealthData, nil
}

// ClearHealthData clears the value of the "health_data" field.
func (m *SettingMutation) ClearHealthData() {
	m.health_data = nil
	m.clearedFields[setting.FieldHealthData] = struct{}{}
}

// HealthDataCleared returns if the "health_data" field was cleared in this mutation.
func (m *SettingMutation) HealthDataCleared() bool {
	_, ok := m.clearedFields[setting.FieldHealthData]
	return ok
}

// ResetHealthData resets all changes to the "health_data" field.
func (m *SettingMutation) ResetHealthData() {
	m.health_data = nil
	delete(m.clearedFields, setting.FieldHealthData)
}

// SetTimeDewLocation sets the "time_dew_location" field.
func (m *SettingMutation) SetTimeDewLocation(b bool) {
	m.time_dew_location = &b
}

// TimeDewLocation returns the value of the "time_dew_location" field in the mutation.
func (m *SettingMutation) TimeDewLocation() (r bool, exists bool) {
	v := m.time_dew_location
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeDewLocation returns the old "time_dew_location" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldTimeDewLocation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeDewLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeDewLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeDewLocation: %w", err)
	}
	return oldValue.TimeDewLocation, nil
}

// ClearTimeDewLocation clears the value of the "time_dew_location" field.
func (m *SettingMutation) ClearTimeDewLocation() {
	m.time_dew_location = nil
	m.clearedFields[setting.FieldTimeDewLocation] = struct{}{}
}

// TimeDewLocationCleared returns if the "time_dew_location" field was cleared in this mutation.
func (m *SettingMutation) TimeDewLocationCleared() bool {
	_, ok := m.clearedFields[setting.FieldTimeDewLocation]
	return ok
}

// ResetTimeDewLocation resets all changes to the "time_dew_location" field.
func (m *SettingMutation) ResetTimeDewLocation() {
	m.time_dew_location = nil
	delete(m.clearedFields, setting.FieldTimeDewLocation)
}

// SetTimeDewMicrophone sets the "time_dew_microphone" field.
func (m *SettingMutation) SetTimeDewMicrophone(b bool) {
	m.time_dew_microphone = &b
}

// TimeDewMicrophone returns the value of the "time_dew_microphone" field in the mutation.
func (m *SettingMutation) TimeDewMicrophone() (r bool, exists bool) {
	v := m.time_dew_microphone
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeDewMicrophone returns the old "time_dew_microphone" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldTimeDewMicrophone(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeDewMicrophone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeDewMicrophone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeDewMicrophone: %w", err)
	}
	return oldValue.TimeDewMicrophone, nil
}

// ClearTimeDewMicrophone clears the value of the "time_dew_microphone" field.
func (m *SettingMutation) ClearTimeDewMicrophone() {
	m.time_dew_microphone = nil
	m.clearedFields[setting.FieldTimeDewMicrophone] = struct{}{}
}

// TimeDewMicrophoneCleared returns if the "time_dew_microphone" field was cleared in this mutation.
func (m *SettingMutation) TimeDewMicrophoneCleared() bool {
	_, ok := m.clearedFields[setting.FieldTimeDewMicrophone]
	return ok
}

// ResetTimeDewMicrophone resets all changes to the "time_dew_microphone" field.
func (m *SettingMutation) ResetTimeDewMicrophone() {
	m.time_dew_microphone = nil
	delete(m.clearedFields, setting.FieldTimeDewMicrophone)
}

// SetTimeDewLora sets the "time_dew_Lora" field.
func (m *SettingMutation) SetTimeDewLora(b bool) {
	m.time_dew_Lora = &b
}

// TimeDewLora returns the value of the "time_dew_Lora" field in the mutation.
func (m *SettingMutation) TimeDewLora() (r bool, exists bool) {
	v := m.time_dew_Lora
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeDewLora returns the old "time_dew_Lora" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldTimeDewLora(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeDewLora is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeDewLora requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeDewLora: %w", err)
	}
	return oldValue.TimeDewLora, nil
}

// ClearTimeDewLora clears the value of the "time_dew_Lora" field.
func (m *SettingMutation) ClearTimeDewLora() {
	m.time_dew_Lora = nil
	m.clearedFields[setting.FieldTimeDewLora] = struct{}{}
}

// TimeDewLoraCleared returns if the "time_dew_Lora" field was cleared in this mutation.
func (m *SettingMutation) TimeDewLoraCleared() bool {
	_, ok := m.clearedFields[setting.FieldTimeDewLora]
	return ok
}

// ResetTimeDewLora resets all changes to the "time_dew_Lora" field.
func (m *SettingMutation) ResetTimeDewLora() {
	m.time_dew_Lora = nil
	delete(m.clearedFields, setting.FieldTimeDewLora)
}

// SetPublicCollection sets the "public_collection" field.
func (m *SettingMutation) SetPublicCollection(b bool) {
	m.public_collection = &b
}

// PublicCollection returns the value of the "public_collection" field in the mutation.
func (m *SettingMutation) PublicCollection() (r bool, exists bool) {
	v := m.public_collection
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicCollection returns the old "public_collection" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldPublicCollection(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicCollection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicCollection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicCollection: %w", err)
	}
	return oldValue.PublicCollection, nil
}

// ClearPublicCollection clears the value of the "public_collection" field.
func (m *SettingMutation) ClearPublicCollection() {
	m.public_collection = nil
	m.clearedFields[setting.FieldPublicCollection] = struct{}{}
}

// PublicCollectionCleared returns if the "public_collection" field was cleared in this mutation.
func (m *SettingMutation) PublicCollectionCleared() bool {
	_, ok := m.clearedFields[setting.FieldPublicCollection]
	return ok
}

// ResetPublicCollection resets all changes to the "public_collection" field.
func (m *SettingMutation) ResetPublicCollection() {
	m.public_collection = nil
	delete(m.clearedFields, setting.FieldPublicCollection)
}

// SetUserID sets the "user_id" field.
func (m *SettingMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SettingMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SettingMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *SettingMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *SettingMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *SettingMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *SettingMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *SettingMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *SettingMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.create_time != nil {
		fields = append(fields, setting.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, setting.FieldUpdateTime)
	}
	if m.friends_online != nil {
		fields = append(fields, setting.FieldFriendsOnline)
	}
	if m.time_dew_from_friends != nil {
		fields = append(fields, setting.FieldTimeDewFromFriends)
	}
	if m.detailed_notification != nil {
		fields = append(fields, setting.FieldDetailedNotification)
	}
	if m.receive_field_invitation != nil {
		fields = append(fields, setting.FieldReceiveFieldInvitation)
	}
	if m.see_my_location != nil {
		fields = append(fields, setting.FieldSeeMyLocation)
	}
	if m.camera != nil {
		fields = append(fields, setting.FieldCamera)
	}
	if m.microphone != nil {
		fields = append(fields, setting.FieldMicrophone)
	}
	if m.health_data != nil {
		fields = append(fields, setting.FieldHealthData)
	}
	if m.time_dew_location != nil {
		fields = append(fields, setting.FieldTimeDewLocation)
	}
	if m.time_dew_microphone != nil {
		fields = append(fields, setting.FieldTimeDewMicrophone)
	}
	if m.time_dew_Lora != nil {
		fields = append(fields, setting.FieldTimeDewLora)
	}
	if m.public_collection != nil {
		fields = append(fields, setting.FieldPublicCollection)
	}
	if m.owner != nil {
		fields = append(fields, setting.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreateTime:
		return m.CreateTime()
	case setting.FieldUpdateTime:
		return m.UpdateTime()
	case setting.FieldFriendsOnline:
		return m.FriendsOnline()
	case setting.FieldTimeDewFromFriends:
		return m.TimeDewFromFriends()
	case setting.FieldDetailedNotification:
		return m.DetailedNotification()
	case setting.FieldReceiveFieldInvitation:
		return m.ReceiveFieldInvitation()
	case setting.FieldSeeMyLocation:
		return m.SeeMyLocation()
	case setting.FieldCamera:
		return m.Camera()
	case setting.FieldMicrophone:
		return m.Microphone()
	case setting.FieldHealthData:
		return m.HealthData()
	case setting.FieldTimeDewLocation:
		return m.TimeDewLocation()
	case setting.FieldTimeDewMicrophone:
		return m.TimeDewMicrophone()
	case setting.FieldTimeDewLora:
		return m.TimeDewLora()
	case setting.FieldPublicCollection:
		return m.PublicCollection()
	case setting.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case setting.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case setting.FieldFriendsOnline:
		return m.OldFriendsOnline(ctx)
	case setting.FieldTimeDewFromFriends:
		return m.OldTimeDewFromFriends(ctx)
	case setting.FieldDetailedNotification:
		return m.OldDetailedNotification(ctx)
	case setting.FieldReceiveFieldInvitation:
		return m.OldReceiveFieldInvitation(ctx)
	case setting.FieldSeeMyLocation:
		return m.OldSeeMyLocation(ctx)
	case setting.FieldCamera:
		return m.OldCamera(ctx)
	case setting.FieldMicrophone:
		return m.OldMicrophone(ctx)
	case setting.FieldHealthData:
		return m.OldHealthData(ctx)
	case setting.FieldTimeDewLocation:
		return m.OldTimeDewLocation(ctx)
	case setting.FieldTimeDewMicrophone:
		return m.OldTimeDewMicrophone(ctx)
	case setting.FieldTimeDewLora:
		return m.OldTimeDewLora(ctx)
	case setting.FieldPublicCollection:
		return m.OldPublicCollection(ctx)
	case setting.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case setting.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case setting.FieldFriendsOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFriendsOnline(v)
		return nil
	case setting.FieldTimeDewFromFriends:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeDewFromFriends(v)
		return nil
	case setting.FieldDetailedNotification:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetailedNotification(v)
		return nil
	case setting.FieldReceiveFieldInvitation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiveFieldInvitation(v)
		return nil
	case setting.FieldSeeMyLocation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeeMyLocation(v)
		return nil
	case setting.FieldCamera:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCamera(v)
		return nil
	case setting.FieldMicrophone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMicrophone(v)
		return nil
	case setting.FieldHealthData:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthData(v)
		return nil
	case setting.FieldTimeDewLocation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeDewLocation(v)
		return nil
	case setting.FieldTimeDewMicrophone:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeDewMicrophone(v)
		return nil
	case setting.FieldTimeDewLora:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeDewLora(v)
		return nil
	case setting.FieldPublicCollection:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicCollection(v)
		return nil
	case setting.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldFriendsOnline) {
		fields = append(fields, setting.FieldFriendsOnline)
	}
	if m.FieldCleared(setting.FieldTimeDewFromFriends) {
		fields = append(fields, setting.FieldTimeDewFromFriends)
	}
	if m.FieldCleared(setting.FieldDetailedNotification) {
		fields = append(fields, setting.FieldDetailedNotification)
	}
	if m.FieldCleared(setting.FieldReceiveFieldInvitation) {
		fields = append(fields, setting.FieldReceiveFieldInvitation)
	}
	if m.FieldCleared(setting.FieldSeeMyLocation) {
		fields = append(fields, setting.FieldSeeMyLocation)
	}
	if m.FieldCleared(setting.FieldCamera) {
		fields = append(fields, setting.FieldCamera)
	}
	if m.FieldCleared(setting.FieldMicrophone) {
		fields = append(fields, setting.FieldMicrophone)
	}
	if m.FieldCleared(setting.FieldHealthData) {
		fields = append(fields, setting.FieldHealthData)
	}
	if m.FieldCleared(setting.FieldTimeDewLocation) {
		fields = append(fields, setting.FieldTimeDewLocation)
	}
	if m.FieldCleared(setting.FieldTimeDewMicrophone) {
		fields = append(fields, setting.FieldTimeDewMicrophone)
	}
	if m.FieldCleared(setting.FieldTimeDewLora) {
		fields = append(fields, setting.FieldTimeDewLora)
	}
	if m.FieldCleared(setting.FieldPublicCollection) {
		fields = append(fields, setting.FieldPublicCollection)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldFriendsOnline:
		m.ClearFriendsOnline()
		return nil
	case setting.FieldTimeDewFromFriends:
		m.ClearTimeDewFromFriends()
		return nil
	case setting.FieldDetailedNotification:
		m.ClearDetailedNotification()
		return nil
	case setting.FieldReceiveFieldInvitation:
		m.ClearReceiveFieldInvitation()
		return nil
	case setting.FieldSeeMyLocation:
		m.ClearSeeMyLocation()
		return nil
	case setting.FieldCamera:
		m.ClearCamera()
		return nil
	case setting.FieldMicrophone:
		m.ClearMicrophone()
		return nil
	case setting.FieldHealthData:
		m.ClearHealthData()
		return nil
	case setting.FieldTimeDewLocation:
		m.ClearTimeDewLocation()
		return nil
	case setting.FieldTimeDewMicrophone:
		m.ClearTimeDewMicrophone()
		return nil
	case setting.FieldTimeDewLora:
		m.ClearTimeDewLora()
		return nil
	case setting.FieldPublicCollection:
		m.ClearPublicCollection()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case setting.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case setting.FieldFriendsOnline:
		m.ResetFriendsOnline()
		return nil
	case setting.FieldTimeDewFromFriends:
		m.ResetTimeDewFromFriends()
		return nil
	case setting.FieldDetailedNotification:
		m.ResetDetailedNotification()
		return nil
	case setting.FieldReceiveFieldInvitation:
		m.ResetReceiveFieldInvitation()
		return nil
	case setting.FieldSeeMyLocation:
		m.ResetSeeMyLocation()
		return nil
	case setting.FieldCamera:
		m.ResetCamera()
		return nil
	case setting.FieldMicrophone:
		m.ResetMicrophone()
		return nil
	case setting.FieldHealthData:
		m.ResetHealthData()
		return nil
	case setting.FieldTimeDewLocation:
		m.ResetTimeDewLocation()
		return nil
	case setting.FieldTimeDewMicrophone:
		m.ResetTimeDewMicrophone()
		return nil
	case setting.FieldTimeDewLora:
		m.ResetTimeDewLora()
		return nil
	case setting.FieldPublicCollection:
		m.ResetPublicCollection()
		return nil
	case setting.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, setting.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case setting.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, setting.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	switch name {
	case setting.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	switch name {
	case setting.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	switch name {
	case setting.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Setting edge %s", name)
}

// StreamMutation represents an operation that mutates the Stream nodes in the graph.
type StreamMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	name          *string
	_type         *stream.Type
	stream_url    *string
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Stream, error)
	predicates    []predicate.Stream
}

var _ ent.Mutation = (*StreamMutation)(nil)

// streamOption allows management of the mutation configuration using functional options.
type streamOption func(*StreamMutation)

// newStreamMutation creates new mutation for the Stream entity.
func newStreamMutation(c config, op Op, opts ...streamOption) *StreamMutation {
	m := &StreamMutation{
		config:        c,
		op:            op,
		typ:           TypeStream,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStreamID sets the ID field of the mutation.
func withStreamID(id uint64) streamOption {
	return func(m *StreamMutation) {
		var (
			err   error
			once  sync.Once
			value *Stream
		)
		m.oldValue = func(ctx context.Context) (*Stream, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stream.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStream sets the old Stream of the mutation.
func withStream(node *Stream) streamOption {
	return func(m *StreamMutation) {
		m.oldValue = func(context.Context) (*Stream, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StreamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StreamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stream entities.
func (m *StreamMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StreamMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StreamMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stream.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *StreamMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *StreamMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *StreamMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *StreamMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *StreamMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *StreamMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *StreamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StreamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StreamMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *StreamMutation) SetType(s stream.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *StreamMutation) GetType() (r stream.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldType(ctx context.Context) (v stream.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *StreamMutation) ResetType() {
	m._type = nil
}

// SetStreamURL sets the "stream_url" field.
func (m *StreamMutation) SetStreamURL(s string) {
	m.stream_url = &s
}

// StreamURL returns the value of the "stream_url" field in the mutation.
func (m *StreamMutation) StreamURL() (r string, exists bool) {
	v := m.stream_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStreamURL returns the old "stream_url" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldStreamURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreamURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreamURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreamURL: %w", err)
	}
	return oldValue.StreamURL, nil
}

// ClearStreamURL clears the value of the "stream_url" field.
func (m *StreamMutation) ClearStreamURL() {
	m.stream_url = nil
	m.clearedFields[stream.FieldStreamURL] = struct{}{}
}

// StreamURLCleared returns if the "stream_url" field was cleared in this mutation.
func (m *StreamMutation) StreamURLCleared() bool {
	_, ok := m.clearedFields[stream.FieldStreamURL]
	return ok
}

// ResetStreamURL resets all changes to the "stream_url" field.
func (m *StreamMutation) ResetStreamURL() {
	m.stream_url = nil
	delete(m.clearedFields, stream.FieldStreamURL)
}

// SetUserID sets the "user_id" field.
func (m *StreamMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *StreamMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Stream entity.
// If the Stream object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StreamMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *StreamMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *StreamMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *StreamMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *StreamMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *StreamMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *StreamMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *StreamMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the StreamMutation builder.
func (m *StreamMutation) Where(ps ...predicate.Stream) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StreamMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stream).
func (m *StreamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StreamMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, stream.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, stream.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, stream.FieldName)
	}
	if m._type != nil {
		fields = append(fields, stream.FieldType)
	}
	if m.stream_url != nil {
		fields = append(fields, stream.FieldStreamURL)
	}
	if m.owner != nil {
		fields = append(fields, stream.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StreamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stream.FieldCreateTime:
		return m.CreateTime()
	case stream.FieldUpdateTime:
		return m.UpdateTime()
	case stream.FieldName:
		return m.Name()
	case stream.FieldType:
		return m.GetType()
	case stream.FieldStreamURL:
		return m.StreamURL()
	case stream.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StreamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stream.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case stream.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case stream.FieldName:
		return m.OldName(ctx)
	case stream.FieldType:
		return m.OldType(ctx)
	case stream.FieldStreamURL:
		return m.OldStreamURL(ctx)
	case stream.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Stream field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stream.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case stream.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case stream.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case stream.FieldType:
		v, ok := value.(stream.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case stream.FieldStreamURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreamURL(v)
		return nil
	case stream.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Stream field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StreamMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StreamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StreamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Stream numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StreamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stream.FieldStreamURL) {
		fields = append(fields, stream.FieldStreamURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StreamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StreamMutation) ClearField(name string) error {
	switch name {
	case stream.FieldStreamURL:
		m.ClearStreamURL()
		return nil
	}
	return fmt.Errorf("unknown Stream nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StreamMutation) ResetField(name string) error {
	switch name {
	case stream.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case stream.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case stream.FieldName:
		m.ResetName()
		return nil
	case stream.FieldType:
		m.ResetType()
		return nil
	case stream.FieldStreamURL:
		m.ResetStreamURL()
		return nil
	case stream.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Stream field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StreamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, stream.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StreamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stream.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StreamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StreamMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StreamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, stream.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StreamMutation) EdgeCleared(name string) bool {
	switch name {
	case stream.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StreamMutation) ClearEdge(name string) error {
	switch name {
	case stream.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Stream unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StreamMutation) ResetEdge(name string) error {
	switch name {
	case stream.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Stream edge %s", name)
}

// TimeDewMutation represents an operation that mutates the TimeDew nodes in the graph.
type TimeDewMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	create_time          *time.Time
	update_time          *time.Time
	name                 *string
	description          *string
	raw_data             *[]string
	appendraw_data       []string
	speechs              *string
	place                *string
	generated_content    *string
	prompt_seq           *string
	prompt_seq_full_text *string
	joined_label         *string
	pic_url              *string
	thumbnail_url        *string
	resource_url         *string
	status               *timedew.Status
	_type                *timedew.Type
	cs_field_id          *uint64
	addcs_field_id       *int64
	target_id            *uint64
	addtarget_id         *int64
	members              *[]string
	appendmembers        []string
	clearedFields        map[string]struct{}
	owner                *uint64
	clearedowner         bool
	reaction_user        map[uint64]struct{}
	removedreaction_user map[uint64]struct{}
	clearedreaction_user bool
	reactions            map[int]struct{}
	removedreactions     map[int]struct{}
	clearedreactions     bool
	done                 bool
	oldValue             func(context.Context) (*TimeDew, error)
	predicates           []predicate.TimeDew
}

var _ ent.Mutation = (*TimeDewMutation)(nil)

// timedewOption allows management of the mutation configuration using functional options.
type timedewOption func(*TimeDewMutation)

// newTimeDewMutation creates new mutation for the TimeDew entity.
func newTimeDewMutation(c config, op Op, opts ...timedewOption) *TimeDewMutation {
	m := &TimeDewMutation{
		config:        c,
		op:            op,
		typ:           TypeTimeDew,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTimeDewID sets the ID field of the mutation.
func withTimeDewID(id uint64) timedewOption {
	return func(m *TimeDewMutation) {
		var (
			err   error
			once  sync.Once
			value *TimeDew
		)
		m.oldValue = func(ctx context.Context) (*TimeDew, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TimeDew.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTimeDew sets the old TimeDew of the mutation.
func withTimeDew(node *TimeDew) timedewOption {
	return func(m *TimeDewMutation) {
		m.oldValue = func(context.Context) (*TimeDew, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TimeDewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TimeDewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TimeDew entities.
func (m *TimeDewMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TimeDewMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TimeDewMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TimeDew.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *TimeDewMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TimeDewMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TimeDewMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TimeDewMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TimeDewMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TimeDewMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *TimeDewMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TimeDewMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TimeDewMutation) ClearName() {
	m.name = nil
	m.clearedFields[timedew.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TimeDewMutation) NameCleared() bool {
	_, ok := m.clearedFields[timedew.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TimeDewMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, timedew.FieldName)
}

// SetDescription sets the "description" field.
func (m *TimeDewMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TimeDewMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TimeDewMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[timedew.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TimeDewMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[timedew.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TimeDewMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, timedew.FieldDescription)
}

// SetRawData sets the "raw_data" field.
func (m *TimeDewMutation) SetRawData(s []string) {
	m.raw_data = &s
	m.appendraw_data = nil
}

// RawData returns the value of the "raw_data" field in the mutation.
func (m *TimeDewMutation) RawData() (r []string, exists bool) {
	v := m.raw_data
	if v == nil {
		return
	}
	return *v, true
}

// OldRawData returns the old "raw_data" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldRawData(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawData: %w", err)
	}
	return oldValue.RawData, nil
}

// AppendRawData adds s to the "raw_data" field.
func (m *TimeDewMutation) AppendRawData(s []string) {
	m.appendraw_data = append(m.appendraw_data, s...)
}

// AppendedRawData returns the list of values that were appended to the "raw_data" field in this mutation.
func (m *TimeDewMutation) AppendedRawData() ([]string, bool) {
	if len(m.appendraw_data) == 0 {
		return nil, false
	}
	return m.appendraw_data, true
}

// ClearRawData clears the value of the "raw_data" field.
func (m *TimeDewMutation) ClearRawData() {
	m.raw_data = nil
	m.appendraw_data = nil
	m.clearedFields[timedew.FieldRawData] = struct{}{}
}

// RawDataCleared returns if the "raw_data" field was cleared in this mutation.
func (m *TimeDewMutation) RawDataCleared() bool {
	_, ok := m.clearedFields[timedew.FieldRawData]
	return ok
}

// ResetRawData resets all changes to the "raw_data" field.
func (m *TimeDewMutation) ResetRawData() {
	m.raw_data = nil
	m.appendraw_data = nil
	delete(m.clearedFields, timedew.FieldRawData)
}

// SetSpeechs sets the "speechs" field.
func (m *TimeDewMutation) SetSpeechs(s string) {
	m.speechs = &s
}

// Speechs returns the value of the "speechs" field in the mutation.
func (m *TimeDewMutation) Speechs() (r string, exists bool) {
	v := m.speechs
	if v == nil {
		return
	}
	return *v, true
}

// OldSpeechs returns the old "speechs" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldSpeechs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpeechs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpeechs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpeechs: %w", err)
	}
	return oldValue.Speechs, nil
}

// ClearSpeechs clears the value of the "speechs" field.
func (m *TimeDewMutation) ClearSpeechs() {
	m.speechs = nil
	m.clearedFields[timedew.FieldSpeechs] = struct{}{}
}

// SpeechsCleared returns if the "speechs" field was cleared in this mutation.
func (m *TimeDewMutation) SpeechsCleared() bool {
	_, ok := m.clearedFields[timedew.FieldSpeechs]
	return ok
}

// ResetSpeechs resets all changes to the "speechs" field.
func (m *TimeDewMutation) ResetSpeechs() {
	m.speechs = nil
	delete(m.clearedFields, timedew.FieldSpeechs)
}

// SetPlace sets the "place" field.
func (m *TimeDewMutation) SetPlace(s string) {
	m.place = &s
}

// Place returns the value of the "place" field in the mutation.
func (m *TimeDewMutation) Place() (r string, exists bool) {
	v := m.place
	if v == nil {
		return
	}
	return *v, true
}

// OldPlace returns the old "place" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldPlace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlace: %w", err)
	}
	return oldValue.Place, nil
}

// ClearPlace clears the value of the "place" field.
func (m *TimeDewMutation) ClearPlace() {
	m.place = nil
	m.clearedFields[timedew.FieldPlace] = struct{}{}
}

// PlaceCleared returns if the "place" field was cleared in this mutation.
func (m *TimeDewMutation) PlaceCleared() bool {
	_, ok := m.clearedFields[timedew.FieldPlace]
	return ok
}

// ResetPlace resets all changes to the "place" field.
func (m *TimeDewMutation) ResetPlace() {
	m.place = nil
	delete(m.clearedFields, timedew.FieldPlace)
}

// SetGeneratedContent sets the "generated_content" field.
func (m *TimeDewMutation) SetGeneratedContent(s string) {
	m.generated_content = &s
}

// GeneratedContent returns the value of the "generated_content" field in the mutation.
func (m *TimeDewMutation) GeneratedContent() (r string, exists bool) {
	v := m.generated_content
	if v == nil {
		return
	}
	return *v, true
}

// OldGeneratedContent returns the old "generated_content" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldGeneratedContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeneratedContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeneratedContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeneratedContent: %w", err)
	}
	return oldValue.GeneratedContent, nil
}

// ClearGeneratedContent clears the value of the "generated_content" field.
func (m *TimeDewMutation) ClearGeneratedContent() {
	m.generated_content = nil
	m.clearedFields[timedew.FieldGeneratedContent] = struct{}{}
}

// GeneratedContentCleared returns if the "generated_content" field was cleared in this mutation.
func (m *TimeDewMutation) GeneratedContentCleared() bool {
	_, ok := m.clearedFields[timedew.FieldGeneratedContent]
	return ok
}

// ResetGeneratedContent resets all changes to the "generated_content" field.
func (m *TimeDewMutation) ResetGeneratedContent() {
	m.generated_content = nil
	delete(m.clearedFields, timedew.FieldGeneratedContent)
}

// SetPromptSeq sets the "prompt_seq" field.
func (m *TimeDewMutation) SetPromptSeq(s string) {
	m.prompt_seq = &s
}

// PromptSeq returns the value of the "prompt_seq" field in the mutation.
func (m *TimeDewMutation) PromptSeq() (r string, exists bool) {
	v := m.prompt_seq
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptSeq returns the old "prompt_seq" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldPromptSeq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptSeq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptSeq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptSeq: %w", err)
	}
	return oldValue.PromptSeq, nil
}

// ClearPromptSeq clears the value of the "prompt_seq" field.
func (m *TimeDewMutation) ClearPromptSeq() {
	m.prompt_seq = nil
	m.clearedFields[timedew.FieldPromptSeq] = struct{}{}
}

// PromptSeqCleared returns if the "prompt_seq" field was cleared in this mutation.
func (m *TimeDewMutation) PromptSeqCleared() bool {
	_, ok := m.clearedFields[timedew.FieldPromptSeq]
	return ok
}

// ResetPromptSeq resets all changes to the "prompt_seq" field.
func (m *TimeDewMutation) ResetPromptSeq() {
	m.prompt_seq = nil
	delete(m.clearedFields, timedew.FieldPromptSeq)
}

// SetPromptSeqFullText sets the "prompt_seq_full_text" field.
func (m *TimeDewMutation) SetPromptSeqFullText(s string) {
	m.prompt_seq_full_text = &s
}

// PromptSeqFullText returns the value of the "prompt_seq_full_text" field in the mutation.
func (m *TimeDewMutation) PromptSeqFullText() (r string, exists bool) {
	v := m.prompt_seq_full_text
	if v == nil {
		return
	}
	return *v, true
}

// OldPromptSeqFullText returns the old "prompt_seq_full_text" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldPromptSeqFullText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromptSeqFullText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromptSeqFullText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromptSeqFullText: %w", err)
	}
	return oldValue.PromptSeqFullText, nil
}

// ClearPromptSeqFullText clears the value of the "prompt_seq_full_text" field.
func (m *TimeDewMutation) ClearPromptSeqFullText() {
	m.prompt_seq_full_text = nil
	m.clearedFields[timedew.FieldPromptSeqFullText] = struct{}{}
}

// PromptSeqFullTextCleared returns if the "prompt_seq_full_text" field was cleared in this mutation.
func (m *TimeDewMutation) PromptSeqFullTextCleared() bool {
	_, ok := m.clearedFields[timedew.FieldPromptSeqFullText]
	return ok
}

// ResetPromptSeqFullText resets all changes to the "prompt_seq_full_text" field.
func (m *TimeDewMutation) ResetPromptSeqFullText() {
	m.prompt_seq_full_text = nil
	delete(m.clearedFields, timedew.FieldPromptSeqFullText)
}

// SetJoinedLabel sets the "joined_label" field.
func (m *TimeDewMutation) SetJoinedLabel(s string) {
	m.joined_label = &s
}

// JoinedLabel returns the value of the "joined_label" field in the mutation.
func (m *TimeDewMutation) JoinedLabel() (r string, exists bool) {
	v := m.joined_label
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedLabel returns the old "joined_label" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldJoinedLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedLabel: %w", err)
	}
	return oldValue.JoinedLabel, nil
}

// ClearJoinedLabel clears the value of the "joined_label" field.
func (m *TimeDewMutation) ClearJoinedLabel() {
	m.joined_label = nil
	m.clearedFields[timedew.FieldJoinedLabel] = struct{}{}
}

// JoinedLabelCleared returns if the "joined_label" field was cleared in this mutation.
func (m *TimeDewMutation) JoinedLabelCleared() bool {
	_, ok := m.clearedFields[timedew.FieldJoinedLabel]
	return ok
}

// ResetJoinedLabel resets all changes to the "joined_label" field.
func (m *TimeDewMutation) ResetJoinedLabel() {
	m.joined_label = nil
	delete(m.clearedFields, timedew.FieldJoinedLabel)
}

// SetPicURL sets the "pic_url" field.
func (m *TimeDewMutation) SetPicURL(s string) {
	m.pic_url = &s
}

// PicURL returns the value of the "pic_url" field in the mutation.
func (m *TimeDewMutation) PicURL() (r string, exists bool) {
	v := m.pic_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPicURL returns the old "pic_url" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldPicURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicURL: %w", err)
	}
	return oldValue.PicURL, nil
}

// ClearPicURL clears the value of the "pic_url" field.
func (m *TimeDewMutation) ClearPicURL() {
	m.pic_url = nil
	m.clearedFields[timedew.FieldPicURL] = struct{}{}
}

// PicURLCleared returns if the "pic_url" field was cleared in this mutation.
func (m *TimeDewMutation) PicURLCleared() bool {
	_, ok := m.clearedFields[timedew.FieldPicURL]
	return ok
}

// ResetPicURL resets all changes to the "pic_url" field.
func (m *TimeDewMutation) ResetPicURL() {
	m.pic_url = nil
	delete(m.clearedFields, timedew.FieldPicURL)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *TimeDewMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *TimeDewMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ClearThumbnailURL clears the value of the "thumbnail_url" field.
func (m *TimeDewMutation) ClearThumbnailURL() {
	m.thumbnail_url = nil
	m.clearedFields[timedew.FieldThumbnailURL] = struct{}{}
}

// ThumbnailURLCleared returns if the "thumbnail_url" field was cleared in this mutation.
func (m *TimeDewMutation) ThumbnailURLCleared() bool {
	_, ok := m.clearedFields[timedew.FieldThumbnailURL]
	return ok
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *TimeDewMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
	delete(m.clearedFields, timedew.FieldThumbnailURL)
}

// SetResourceURL sets the "resource_url" field.
func (m *TimeDewMutation) SetResourceURL(s string) {
	m.resource_url = &s
}

// ResourceURL returns the value of the "resource_url" field in the mutation.
func (m *TimeDewMutation) ResourceURL() (r string, exists bool) {
	v := m.resource_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceURL returns the old "resource_url" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldResourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceURL: %w", err)
	}
	return oldValue.ResourceURL, nil
}

// ClearResourceURL clears the value of the "resource_url" field.
func (m *TimeDewMutation) ClearResourceURL() {
	m.resource_url = nil
	m.clearedFields[timedew.FieldResourceURL] = struct{}{}
}

// ResourceURLCleared returns if the "resource_url" field was cleared in this mutation.
func (m *TimeDewMutation) ResourceURLCleared() bool {
	_, ok := m.clearedFields[timedew.FieldResourceURL]
	return ok
}

// ResetResourceURL resets all changes to the "resource_url" field.
func (m *TimeDewMutation) ResetResourceURL() {
	m.resource_url = nil
	delete(m.clearedFields, timedew.FieldResourceURL)
}

// SetStatus sets the "status" field.
func (m *TimeDewMutation) SetStatus(t timedew.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TimeDewMutation) Status() (r timedew.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldStatus(ctx context.Context) (v timedew.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TimeDewMutation) ResetStatus() {
	m.status = nil
}

// SetType sets the "type" field.
func (m *TimeDewMutation) SetType(t timedew.Type) {
	m._type = &t
}

// GetType returns the value of the "type" field in the mutation.
func (m *TimeDewMutation) GetType() (r timedew.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldType(ctx context.Context) (v timedew.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TimeDewMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user_id" field.
func (m *TimeDewMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TimeDewMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TimeDewMutation) ResetUserID() {
	m.owner = nil
}

// SetCsFieldID sets the "cs_field_id" field.
func (m *TimeDewMutation) SetCsFieldID(u uint64) {
	m.cs_field_id = &u
	m.addcs_field_id = nil
}

// CsFieldID returns the value of the "cs_field_id" field in the mutation.
func (m *TimeDewMutation) CsFieldID() (r uint64, exists bool) {
	v := m.cs_field_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCsFieldID returns the old "cs_field_id" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldCsFieldID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCsFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCsFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCsFieldID: %w", err)
	}
	return oldValue.CsFieldID, nil
}

// AddCsFieldID adds u to the "cs_field_id" field.
func (m *TimeDewMutation) AddCsFieldID(u int64) {
	if m.addcs_field_id != nil {
		*m.addcs_field_id += u
	} else {
		m.addcs_field_id = &u
	}
}

// AddedCsFieldID returns the value that was added to the "cs_field_id" field in this mutation.
func (m *TimeDewMutation) AddedCsFieldID() (r int64, exists bool) {
	v := m.addcs_field_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCsFieldID clears the value of the "cs_field_id" field.
func (m *TimeDewMutation) ClearCsFieldID() {
	m.cs_field_id = nil
	m.addcs_field_id = nil
	m.clearedFields[timedew.FieldCsFieldID] = struct{}{}
}

// CsFieldIDCleared returns if the "cs_field_id" field was cleared in this mutation.
func (m *TimeDewMutation) CsFieldIDCleared() bool {
	_, ok := m.clearedFields[timedew.FieldCsFieldID]
	return ok
}

// ResetCsFieldID resets all changes to the "cs_field_id" field.
func (m *TimeDewMutation) ResetCsFieldID() {
	m.cs_field_id = nil
	m.addcs_field_id = nil
	delete(m.clearedFields, timedew.FieldCsFieldID)
}

// SetTargetID sets the "target_id" field.
func (m *TimeDewMutation) SetTargetID(u uint64) {
	m.target_id = &u
	m.addtarget_id = nil
}

// TargetID returns the value of the "target_id" field in the mutation.
func (m *TimeDewMutation) TargetID() (r uint64, exists bool) {
	v := m.target_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetID returns the old "target_id" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldTargetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetID: %w", err)
	}
	return oldValue.TargetID, nil
}

// AddTargetID adds u to the "target_id" field.
func (m *TimeDewMutation) AddTargetID(u int64) {
	if m.addtarget_id != nil {
		*m.addtarget_id += u
	} else {
		m.addtarget_id = &u
	}
}

// AddedTargetID returns the value that was added to the "target_id" field in this mutation.
func (m *TimeDewMutation) AddedTargetID() (r int64, exists bool) {
	v := m.addtarget_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTargetID clears the value of the "target_id" field.
func (m *TimeDewMutation) ClearTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	m.clearedFields[timedew.FieldTargetID] = struct{}{}
}

// TargetIDCleared returns if the "target_id" field was cleared in this mutation.
func (m *TimeDewMutation) TargetIDCleared() bool {
	_, ok := m.clearedFields[timedew.FieldTargetID]
	return ok
}

// ResetTargetID resets all changes to the "target_id" field.
func (m *TimeDewMutation) ResetTargetID() {
	m.target_id = nil
	m.addtarget_id = nil
	delete(m.clearedFields, timedew.FieldTargetID)
}

// SetMembers sets the "members" field.
func (m *TimeDewMutation) SetMembers(s []string) {
	m.members = &s
	m.appendmembers = nil
}

// Members returns the value of the "members" field in the mutation.
func (m *TimeDewMutation) Members() (r []string, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMembers returns the old "members" field's value of the TimeDew entity.
// If the TimeDew object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TimeDewMutation) OldMembers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembers: %w", err)
	}
	return oldValue.Members, nil
}

// AppendMembers adds s to the "members" field.
func (m *TimeDewMutation) AppendMembers(s []string) {
	m.appendmembers = append(m.appendmembers, s...)
}

// AppendedMembers returns the list of values that were appended to the "members" field in this mutation.
func (m *TimeDewMutation) AppendedMembers() ([]string, bool) {
	if len(m.appendmembers) == 0 {
		return nil, false
	}
	return m.appendmembers, true
}

// ClearMembers clears the value of the "members" field.
func (m *TimeDewMutation) ClearMembers() {
	m.members = nil
	m.appendmembers = nil
	m.clearedFields[timedew.FieldMembers] = struct{}{}
}

// MembersCleared returns if the "members" field was cleared in this mutation.
func (m *TimeDewMutation) MembersCleared() bool {
	_, ok := m.clearedFields[timedew.FieldMembers]
	return ok
}

// ResetMembers resets all changes to the "members" field.
func (m *TimeDewMutation) ResetMembers() {
	m.members = nil
	m.appendmembers = nil
	delete(m.clearedFields, timedew.FieldMembers)
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TimeDewMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TimeDewMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TimeDewMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TimeDewMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TimeDewMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TimeDewMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddReactionUserIDs adds the "reaction_user" edge to the User entity by ids.
func (m *TimeDewMutation) AddReactionUserIDs(ids ...uint64) {
	if m.reaction_user == nil {
		m.reaction_user = make(map[uint64]struct{})
	}
	for i := range ids {
		m.reaction_user[ids[i]] = struct{}{}
	}
}

// ClearReactionUser clears the "reaction_user" edge to the User entity.
func (m *TimeDewMutation) ClearReactionUser() {
	m.clearedreaction_user = true
}

// ReactionUserCleared reports if the "reaction_user" edge to the User entity was cleared.
func (m *TimeDewMutation) ReactionUserCleared() bool {
	return m.clearedreaction_user
}

// RemoveReactionUserIDs removes the "reaction_user" edge to the User entity by IDs.
func (m *TimeDewMutation) RemoveReactionUserIDs(ids ...uint64) {
	if m.removedreaction_user == nil {
		m.removedreaction_user = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.reaction_user, ids[i])
		m.removedreaction_user[ids[i]] = struct{}{}
	}
}

// RemovedReactionUser returns the removed IDs of the "reaction_user" edge to the User entity.
func (m *TimeDewMutation) RemovedReactionUserIDs() (ids []uint64) {
	for id := range m.removedreaction_user {
		ids = append(ids, id)
	}
	return
}

// ReactionUserIDs returns the "reaction_user" edge IDs in the mutation.
func (m *TimeDewMutation) ReactionUserIDs() (ids []uint64) {
	for id := range m.reaction_user {
		ids = append(ids, id)
	}
	return
}

// ResetReactionUser resets all changes to the "reaction_user" edge.
func (m *TimeDewMutation) ResetReactionUser() {
	m.reaction_user = nil
	m.clearedreaction_user = false
	m.removedreaction_user = nil
}

// AddReactionIDs adds the "reactions" edge to the Reaction entity by ids.
func (m *TimeDewMutation) AddReactionIDs(ids ...int) {
	if m.reactions == nil {
		m.reactions = make(map[int]struct{})
	}
	for i := range ids {
		m.reactions[ids[i]] = struct{}{}
	}
}

// ClearReactions clears the "reactions" edge to the Reaction entity.
func (m *TimeDewMutation) ClearReactions() {
	m.clearedreactions = true
}

// ReactionsCleared reports if the "reactions" edge to the Reaction entity was cleared.
func (m *TimeDewMutation) ReactionsCleared() bool {
	return m.clearedreactions
}

// RemoveReactionIDs removes the "reactions" edge to the Reaction entity by IDs.
func (m *TimeDewMutation) RemoveReactionIDs(ids ...int) {
	if m.removedreactions == nil {
		m.removedreactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reactions, ids[i])
		m.removedreactions[ids[i]] = struct{}{}
	}
}

// RemovedReactions returns the removed IDs of the "reactions" edge to the Reaction entity.
func (m *TimeDewMutation) RemovedReactionsIDs() (ids []int) {
	for id := range m.removedreactions {
		ids = append(ids, id)
	}
	return
}

// ReactionsIDs returns the "reactions" edge IDs in the mutation.
func (m *TimeDewMutation) ReactionsIDs() (ids []int) {
	for id := range m.reactions {
		ids = append(ids, id)
	}
	return
}

// ResetReactions resets all changes to the "reactions" edge.
func (m *TimeDewMutation) ResetReactions() {
	m.reactions = nil
	m.clearedreactions = false
	m.removedreactions = nil
}

// Where appends a list predicates to the TimeDewMutation builder.
func (m *TimeDewMutation) Where(ps ...predicate.TimeDew) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TimeDewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TimeDew).
func (m *TimeDewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TimeDewMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.create_time != nil {
		fields = append(fields, timedew.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, timedew.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, timedew.FieldName)
	}
	if m.description != nil {
		fields = append(fields, timedew.FieldDescription)
	}
	if m.raw_data != nil {
		fields = append(fields, timedew.FieldRawData)
	}
	if m.speechs != nil {
		fields = append(fields, timedew.FieldSpeechs)
	}
	if m.place != nil {
		fields = append(fields, timedew.FieldPlace)
	}
	if m.generated_content != nil {
		fields = append(fields, timedew.FieldGeneratedContent)
	}
	if m.prompt_seq != nil {
		fields = append(fields, timedew.FieldPromptSeq)
	}
	if m.prompt_seq_full_text != nil {
		fields = append(fields, timedew.FieldPromptSeqFullText)
	}
	if m.joined_label != nil {
		fields = append(fields, timedew.FieldJoinedLabel)
	}
	if m.pic_url != nil {
		fields = append(fields, timedew.FieldPicURL)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, timedew.FieldThumbnailURL)
	}
	if m.resource_url != nil {
		fields = append(fields, timedew.FieldResourceURL)
	}
	if m.status != nil {
		fields = append(fields, timedew.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, timedew.FieldType)
	}
	if m.owner != nil {
		fields = append(fields, timedew.FieldUserID)
	}
	if m.cs_field_id != nil {
		fields = append(fields, timedew.FieldCsFieldID)
	}
	if m.target_id != nil {
		fields = append(fields, timedew.FieldTargetID)
	}
	if m.members != nil {
		fields = append(fields, timedew.FieldMembers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TimeDewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case timedew.FieldCreateTime:
		return m.CreateTime()
	case timedew.FieldUpdateTime:
		return m.UpdateTime()
	case timedew.FieldName:
		return m.Name()
	case timedew.FieldDescription:
		return m.Description()
	case timedew.FieldRawData:
		return m.RawData()
	case timedew.FieldSpeechs:
		return m.Speechs()
	case timedew.FieldPlace:
		return m.Place()
	case timedew.FieldGeneratedContent:
		return m.GeneratedContent()
	case timedew.FieldPromptSeq:
		return m.PromptSeq()
	case timedew.FieldPromptSeqFullText:
		return m.PromptSeqFullText()
	case timedew.FieldJoinedLabel:
		return m.JoinedLabel()
	case timedew.FieldPicURL:
		return m.PicURL()
	case timedew.FieldThumbnailURL:
		return m.ThumbnailURL()
	case timedew.FieldResourceURL:
		return m.ResourceURL()
	case timedew.FieldStatus:
		return m.Status()
	case timedew.FieldType:
		return m.GetType()
	case timedew.FieldUserID:
		return m.UserID()
	case timedew.FieldCsFieldID:
		return m.CsFieldID()
	case timedew.FieldTargetID:
		return m.TargetID()
	case timedew.FieldMembers:
		return m.Members()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TimeDewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case timedew.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case timedew.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case timedew.FieldName:
		return m.OldName(ctx)
	case timedew.FieldDescription:
		return m.OldDescription(ctx)
	case timedew.FieldRawData:
		return m.OldRawData(ctx)
	case timedew.FieldSpeechs:
		return m.OldSpeechs(ctx)
	case timedew.FieldPlace:
		return m.OldPlace(ctx)
	case timedew.FieldGeneratedContent:
		return m.OldGeneratedContent(ctx)
	case timedew.FieldPromptSeq:
		return m.OldPromptSeq(ctx)
	case timedew.FieldPromptSeqFullText:
		return m.OldPromptSeqFullText(ctx)
	case timedew.FieldJoinedLabel:
		return m.OldJoinedLabel(ctx)
	case timedew.FieldPicURL:
		return m.OldPicURL(ctx)
	case timedew.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case timedew.FieldResourceURL:
		return m.OldResourceURL(ctx)
	case timedew.FieldStatus:
		return m.OldStatus(ctx)
	case timedew.FieldType:
		return m.OldType(ctx)
	case timedew.FieldUserID:
		return m.OldUserID(ctx)
	case timedew.FieldCsFieldID:
		return m.OldCsFieldID(ctx)
	case timedew.FieldTargetID:
		return m.OldTargetID(ctx)
	case timedew.FieldMembers:
		return m.OldMembers(ctx)
	}
	return nil, fmt.Errorf("unknown TimeDew field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeDewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case timedew.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case timedew.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case timedew.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case timedew.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case timedew.FieldRawData:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawData(v)
		return nil
	case timedew.FieldSpeechs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpeechs(v)
		return nil
	case timedew.FieldPlace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlace(v)
		return nil
	case timedew.FieldGeneratedContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeneratedContent(v)
		return nil
	case timedew.FieldPromptSeq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptSeq(v)
		return nil
	case timedew.FieldPromptSeqFullText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromptSeqFullText(v)
		return nil
	case timedew.FieldJoinedLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedLabel(v)
		return nil
	case timedew.FieldPicURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicURL(v)
		return nil
	case timedew.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case timedew.FieldResourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceURL(v)
		return nil
	case timedew.FieldStatus:
		v, ok := value.(timedew.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case timedew.FieldType:
		v, ok := value.(timedew.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case timedew.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case timedew.FieldCsFieldID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCsFieldID(v)
		return nil
	case timedew.FieldTargetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetID(v)
		return nil
	case timedew.FieldMembers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembers(v)
		return nil
	}
	return fmt.Errorf("unknown TimeDew field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TimeDewMutation) AddedFields() []string {
	var fields []string
	if m.addcs_field_id != nil {
		fields = append(fields, timedew.FieldCsFieldID)
	}
	if m.addtarget_id != nil {
		fields = append(fields, timedew.FieldTargetID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TimeDewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case timedew.FieldCsFieldID:
		return m.AddedCsFieldID()
	case timedew.FieldTargetID:
		return m.AddedTargetID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TimeDewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case timedew.FieldCsFieldID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCsFieldID(v)
		return nil
	case timedew.FieldTargetID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTargetID(v)
		return nil
	}
	return fmt.Errorf("unknown TimeDew numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TimeDewMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(timedew.FieldName) {
		fields = append(fields, timedew.FieldName)
	}
	if m.FieldCleared(timedew.FieldDescription) {
		fields = append(fields, timedew.FieldDescription)
	}
	if m.FieldCleared(timedew.FieldRawData) {
		fields = append(fields, timedew.FieldRawData)
	}
	if m.FieldCleared(timedew.FieldSpeechs) {
		fields = append(fields, timedew.FieldSpeechs)
	}
	if m.FieldCleared(timedew.FieldPlace) {
		fields = append(fields, timedew.FieldPlace)
	}
	if m.FieldCleared(timedew.FieldGeneratedContent) {
		fields = append(fields, timedew.FieldGeneratedContent)
	}
	if m.FieldCleared(timedew.FieldPromptSeq) {
		fields = append(fields, timedew.FieldPromptSeq)
	}
	if m.FieldCleared(timedew.FieldPromptSeqFullText) {
		fields = append(fields, timedew.FieldPromptSeqFullText)
	}
	if m.FieldCleared(timedew.FieldJoinedLabel) {
		fields = append(fields, timedew.FieldJoinedLabel)
	}
	if m.FieldCleared(timedew.FieldPicURL) {
		fields = append(fields, timedew.FieldPicURL)
	}
	if m.FieldCleared(timedew.FieldThumbnailURL) {
		fields = append(fields, timedew.FieldThumbnailURL)
	}
	if m.FieldCleared(timedew.FieldResourceURL) {
		fields = append(fields, timedew.FieldResourceURL)
	}
	if m.FieldCleared(timedew.FieldCsFieldID) {
		fields = append(fields, timedew.FieldCsFieldID)
	}
	if m.FieldCleared(timedew.FieldTargetID) {
		fields = append(fields, timedew.FieldTargetID)
	}
	if m.FieldCleared(timedew.FieldMembers) {
		fields = append(fields, timedew.FieldMembers)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TimeDewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TimeDewMutation) ClearField(name string) error {
	switch name {
	case timedew.FieldName:
		m.ClearName()
		return nil
	case timedew.FieldDescription:
		m.ClearDescription()
		return nil
	case timedew.FieldRawData:
		m.ClearRawData()
		return nil
	case timedew.FieldSpeechs:
		m.ClearSpeechs()
		return nil
	case timedew.FieldPlace:
		m.ClearPlace()
		return nil
	case timedew.FieldGeneratedContent:
		m.ClearGeneratedContent()
		return nil
	case timedew.FieldPromptSeq:
		m.ClearPromptSeq()
		return nil
	case timedew.FieldPromptSeqFullText:
		m.ClearPromptSeqFullText()
		return nil
	case timedew.FieldJoinedLabel:
		m.ClearJoinedLabel()
		return nil
	case timedew.FieldPicURL:
		m.ClearPicURL()
		return nil
	case timedew.FieldThumbnailURL:
		m.ClearThumbnailURL()
		return nil
	case timedew.FieldResourceURL:
		m.ClearResourceURL()
		return nil
	case timedew.FieldCsFieldID:
		m.ClearCsFieldID()
		return nil
	case timedew.FieldTargetID:
		m.ClearTargetID()
		return nil
	case timedew.FieldMembers:
		m.ClearMembers()
		return nil
	}
	return fmt.Errorf("unknown TimeDew nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TimeDewMutation) ResetField(name string) error {
	switch name {
	case timedew.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case timedew.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case timedew.FieldName:
		m.ResetName()
		return nil
	case timedew.FieldDescription:
		m.ResetDescription()
		return nil
	case timedew.FieldRawData:
		m.ResetRawData()
		return nil
	case timedew.FieldSpeechs:
		m.ResetSpeechs()
		return nil
	case timedew.FieldPlace:
		m.ResetPlace()
		return nil
	case timedew.FieldGeneratedContent:
		m.ResetGeneratedContent()
		return nil
	case timedew.FieldPromptSeq:
		m.ResetPromptSeq()
		return nil
	case timedew.FieldPromptSeqFullText:
		m.ResetPromptSeqFullText()
		return nil
	case timedew.FieldJoinedLabel:
		m.ResetJoinedLabel()
		return nil
	case timedew.FieldPicURL:
		m.ResetPicURL()
		return nil
	case timedew.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case timedew.FieldResourceURL:
		m.ResetResourceURL()
		return nil
	case timedew.FieldStatus:
		m.ResetStatus()
		return nil
	case timedew.FieldType:
		m.ResetType()
		return nil
	case timedew.FieldUserID:
		m.ResetUserID()
		return nil
	case timedew.FieldCsFieldID:
		m.ResetCsFieldID()
		return nil
	case timedew.FieldTargetID:
		m.ResetTargetID()
		return nil
	case timedew.FieldMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown TimeDew field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TimeDewMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.owner != nil {
		edges = append(edges, timedew.EdgeOwner)
	}
	if m.reaction_user != nil {
		edges = append(edges, timedew.EdgeReactionUser)
	}
	if m.reactions != nil {
		edges = append(edges, timedew.EdgeReactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TimeDewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case timedew.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case timedew.EdgeReactionUser:
		ids := make([]ent.Value, 0, len(m.reaction_user))
		for id := range m.reaction_user {
			ids = append(ids, id)
		}
		return ids
	case timedew.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.reactions))
		for id := range m.reactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TimeDewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedreaction_user != nil {
		edges = append(edges, timedew.EdgeReactionUser)
	}
	if m.removedreactions != nil {
		edges = append(edges, timedew.EdgeReactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TimeDewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case timedew.EdgeReactionUser:
		ids := make([]ent.Value, 0, len(m.removedreaction_user))
		for id := range m.removedreaction_user {
			ids = append(ids, id)
		}
		return ids
	case timedew.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.removedreactions))
		for id := range m.removedreactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TimeDewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedowner {
		edges = append(edges, timedew.EdgeOwner)
	}
	if m.clearedreaction_user {
		edges = append(edges, timedew.EdgeReactionUser)
	}
	if m.clearedreactions {
		edges = append(edges, timedew.EdgeReactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TimeDewMutation) EdgeCleared(name string) bool {
	switch name {
	case timedew.EdgeOwner:
		return m.clearedowner
	case timedew.EdgeReactionUser:
		return m.clearedreaction_user
	case timedew.EdgeReactions:
		return m.clearedreactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TimeDewMutation) ClearEdge(name string) error {
	switch name {
	case timedew.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown TimeDew unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TimeDewMutation) ResetEdge(name string) error {
	switch name {
	case timedew.EdgeOwner:
		m.ResetOwner()
		return nil
	case timedew.EdgeReactionUser:
		m.ResetReactionUser()
		return nil
	case timedew.EdgeReactions:
		m.ResetReactions()
		return nil
	}
	return fmt.Errorf("unknown TimeDew edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint64
	create_time             *time.Time
	update_time             *time.Time
	open_id                 *string
	name                    *string
	nick_name               *string
	system_name             *string
	avatar                  *string
	thumbnail_url           *string
	sex                     *string
	mobile_no               *string
	region_code             *string
	email_address           *string
	birthday                *string
	school_name             *string
	bio                     *string
	status                  *user.Status
	role                    *user.Role
	is_online               *bool
	is_show_collections     *bool
	is_invited              *bool
	need_privacy_confirm    *bool
	current_cs_field_id     *uint64
	addcurrent_cs_field_id  *int64
	current_cs_field_name   *string
	private_cs_field_id     *uint64
	addprivate_cs_field_id  *int64
	private_cs_field_name   *string
	register_ip             *string
	constellation           *string
	total_connections       *int
	addtotal_connections    *int
	clearedFields           map[string]struct{}
	user_auth               map[int]struct{}
	removeduser_auth        map[int]struct{}
	cleareduser_auth        bool
	card                    map[uint64]struct{}
	removedcard             map[uint64]struct{}
	clearedcard             bool
	message                 map[uint64]struct{}
	removedmessage          map[uint64]struct{}
	clearedmessage          bool
	device                  map[uint64]struct{}
	removeddevice           map[uint64]struct{}
	cleareddevice           bool
	joined_csfield          map[uint64]struct{}
	removedjoined_csfield   map[uint64]struct{}
	clearedjoined_csfield   bool
	friends                 map[uint64]struct{}
	removedfriends          map[uint64]struct{}
	clearedfriends          bool
	hidden                  map[int]struct{}
	removedhidden           map[int]struct{}
	clearedhidden           bool
	history                 map[uint64]struct{}
	removedhistory          map[uint64]struct{}
	clearedhistory          bool
	token                   map[uint64]struct{}
	removedtoken            map[uint64]struct{}
	clearedtoken            bool
	creation                map[uint64]struct{}
	removedcreation         map[uint64]struct{}
	clearedcreation         bool
	contact                 map[uint64]struct{}
	removedcontact          map[uint64]struct{}
	clearedcontact          bool
	setting                 map[uint64]struct{}
	removedsetting          map[uint64]struct{}
	clearedsetting          bool
	nft                     map[uint64]struct{}
	removednft              map[uint64]struct{}
	clearednft              bool
	stream                  map[uint64]struct{}
	removedstream           map[uint64]struct{}
	clearedstream           bool
	mask                    map[uint64]struct{}
	removedmask             map[uint64]struct{}
	clearedmask             bool
	timedew                 map[uint64]struct{}
	removedtimedew          map[uint64]struct{}
	clearedtimedew          bool
	collection              map[uint64]struct{}
	removedcollection       map[uint64]struct{}
	clearedcollection       bool
	invite_code             map[int]struct{}
	removedinvite_code      map[int]struct{}
	clearedinvite_code      bool
	feedback                map[int]struct{}
	removedfeedback         map[int]struct{}
	clearedfeedback         bool
	reaction_timedew        map[uint64]struct{}
	removedreaction_timedew map[uint64]struct{}
	clearedreaction_timedew bool
	joins                   map[int]struct{}
	removedjoins            map[int]struct{}
	clearedjoins            bool
	friendships             map[int]struct{}
	removedfriendships      map[int]struct{}
	clearedfriendships      bool
	reactions               map[int]struct{}
	removedreactions        map[int]struct{}
	clearedreactions        bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetOpenID sets the "open_id" field.
func (m *UserMutation) SetOpenID(s string) {
	m.open_id = &s
}

// OpenID returns the value of the "open_id" field in the mutation.
func (m *UserMutation) OpenID() (r string, exists bool) {
	v := m.open_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenID returns the old "open_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOpenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenID: %w", err)
	}
	return oldValue.OpenID, nil
}

// ClearOpenID clears the value of the "open_id" field.
func (m *UserMutation) ClearOpenID() {
	m.open_id = nil
	m.clearedFields[user.FieldOpenID] = struct{}{}
}

// OpenIDCleared returns if the "open_id" field was cleared in this mutation.
func (m *UserMutation) OpenIDCleared() bool {
	_, ok := m.clearedFields[user.FieldOpenID]
	return ok
}

// ResetOpenID resets all changes to the "open_id" field.
func (m *UserMutation) ResetOpenID() {
	m.open_id = nil
	delete(m.clearedFields, user.FieldOpenID)
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetNickName sets the "nick_name" field.
func (m *UserMutation) SetNickName(s string) {
	m.nick_name = &s
}

// NickName returns the value of the "nick_name" field in the mutation.
func (m *UserMutation) NickName() (r string, exists bool) {
	v := m.nick_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nick_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ClearNickName clears the value of the "nick_name" field.
func (m *UserMutation) ClearNickName() {
	m.nick_name = nil
	m.clearedFields[user.FieldNickName] = struct{}{}
}

// NickNameCleared returns if the "nick_name" field was cleared in this mutation.
func (m *UserMutation) NickNameCleared() bool {
	_, ok := m.clearedFields[user.FieldNickName]
	return ok
}

// ResetNickName resets all changes to the "nick_name" field.
func (m *UserMutation) ResetNickName() {
	m.nick_name = nil
	delete(m.clearedFields, user.FieldNickName)
}

// SetSystemName sets the "system_name" field.
func (m *UserMutation) SetSystemName(s string) {
	m.system_name = &s
}

// SystemName returns the value of the "system_name" field in the mutation.
func (m *UserMutation) SystemName() (r string, exists bool) {
	v := m.system_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemName returns the old "system_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSystemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemName: %w", err)
	}
	return oldValue.SystemName, nil
}

// ClearSystemName clears the value of the "system_name" field.
func (m *UserMutation) ClearSystemName() {
	m.system_name = nil
	m.clearedFields[user.FieldSystemName] = struct{}{}
}

// SystemNameCleared returns if the "system_name" field was cleared in this mutation.
func (m *UserMutation) SystemNameCleared() bool {
	_, ok := m.clearedFields[user.FieldSystemName]
	return ok
}

// ResetSystemName resets all changes to the "system_name" field.
func (m *UserMutation) ResetSystemName() {
	m.system_name = nil
	delete(m.clearedFields, user.FieldSystemName)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (m *UserMutation) SetThumbnailURL(s string) {
	m.thumbnail_url = &s
}

// ThumbnailURL returns the value of the "thumbnail_url" field in the mutation.
func (m *UserMutation) ThumbnailURL() (r string, exists bool) {
	v := m.thumbnail_url
	if v == nil {
		return
	}
	return *v, true
}

// OldThumbnailURL returns the old "thumbnail_url" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldThumbnailURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThumbnailURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThumbnailURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThumbnailURL: %w", err)
	}
	return oldValue.ThumbnailURL, nil
}

// ResetThumbnailURL resets all changes to the "thumbnail_url" field.
func (m *UserMutation) ResetThumbnailURL() {
	m.thumbnail_url = nil
}

// SetSex sets the "sex" field.
func (m *UserMutation) SetSex(s string) {
	m.sex = &s
}

// Sex returns the value of the "sex" field in the mutation.
func (m *UserMutation) Sex() (r string, exists bool) {
	v := m.sex
	if v == nil {
		return
	}
	return *v, true
}

// OldSex returns the old "sex" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSex: %w", err)
	}
	return oldValue.Sex, nil
}

// ClearSex clears the value of the "sex" field.
func (m *UserMutation) ClearSex() {
	m.sex = nil
	m.clearedFields[user.FieldSex] = struct{}{}
}

// SexCleared returns if the "sex" field was cleared in this mutation.
func (m *UserMutation) SexCleared() bool {
	_, ok := m.clearedFields[user.FieldSex]
	return ok
}

// ResetSex resets all changes to the "sex" field.
func (m *UserMutation) ResetSex() {
	m.sex = nil
	delete(m.clearedFields, user.FieldSex)
}

// SetMobileNo sets the "mobile_no" field.
func (m *UserMutation) SetMobileNo(s string) {
	m.mobile_no = &s
}

// MobileNo returns the value of the "mobile_no" field in the mutation.
func (m *UserMutation) MobileNo() (r string, exists bool) {
	v := m.mobile_no
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNo returns the old "mobile_no" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobileNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNo: %w", err)
	}
	return oldValue.MobileNo, nil
}

// ClearMobileNo clears the value of the "mobile_no" field.
func (m *UserMutation) ClearMobileNo() {
	m.mobile_no = nil
	m.clearedFields[user.FieldMobileNo] = struct{}{}
}

// MobileNoCleared returns if the "mobile_no" field was cleared in this mutation.
func (m *UserMutation) MobileNoCleared() bool {
	_, ok := m.clearedFields[user.FieldMobileNo]
	return ok
}

// ResetMobileNo resets all changes to the "mobile_no" field.
func (m *UserMutation) ResetMobileNo() {
	m.mobile_no = nil
	delete(m.clearedFields, user.FieldMobileNo)
}

// SetRegionCode sets the "region_code" field.
func (m *UserMutation) SetRegionCode(s string) {
	m.region_code = &s
}

// RegionCode returns the value of the "region_code" field in the mutation.
func (m *UserMutation) RegionCode() (r string, exists bool) {
	v := m.region_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "region_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// ClearRegionCode clears the value of the "region_code" field.
func (m *UserMutation) ClearRegionCode() {
	m.region_code = nil
	m.clearedFields[user.FieldRegionCode] = struct{}{}
}

// RegionCodeCleared returns if the "region_code" field was cleared in this mutation.
func (m *UserMutation) RegionCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldRegionCode]
	return ok
}

// ResetRegionCode resets all changes to the "region_code" field.
func (m *UserMutation) ResetRegionCode() {
	m.region_code = nil
	delete(m.clearedFields, user.FieldRegionCode)
}

// SetEmailAddress sets the "email_address" field.
func (m *UserMutation) SetEmailAddress(s string) {
	m.email_address = &s
}

// EmailAddress returns the value of the "email_address" field in the mutation.
func (m *UserMutation) EmailAddress() (r string, exists bool) {
	v := m.email_address
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAddress returns the old "email_address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAddress: %w", err)
	}
	return oldValue.EmailAddress, nil
}

// ClearEmailAddress clears the value of the "email_address" field.
func (m *UserMutation) ClearEmailAddress() {
	m.email_address = nil
	m.clearedFields[user.FieldEmailAddress] = struct{}{}
}

// EmailAddressCleared returns if the "email_address" field was cleared in this mutation.
func (m *UserMutation) EmailAddressCleared() bool {
	_, ok := m.clearedFields[user.FieldEmailAddress]
	return ok
}

// ResetEmailAddress resets all changes to the "email_address" field.
func (m *UserMutation) ResetEmailAddress() {
	m.email_address = nil
	delete(m.clearedFields, user.FieldEmailAddress)
}

// SetBirthday sets the "birthday" field.
func (m *UserMutation) SetBirthday(s string) {
	m.birthday = &s
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *UserMutation) Birthday() (r string, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ClearBirthday clears the value of the "birthday" field.
func (m *UserMutation) ClearBirthday() {
	m.birthday = nil
	m.clearedFields[user.FieldBirthday] = struct{}{}
}

// BirthdayCleared returns if the "birthday" field was cleared in this mutation.
func (m *UserMutation) BirthdayCleared() bool {
	_, ok := m.clearedFields[user.FieldBirthday]
	return ok
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
	delete(m.clearedFields, user.FieldBirthday)
}

// SetSchoolName sets the "school_name" field.
func (m *UserMutation) SetSchoolName(s string) {
	m.school_name = &s
}

// SchoolName returns the value of the "school_name" field in the mutation.
func (m *UserMutation) SchoolName() (r string, exists bool) {
	v := m.school_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSchoolName returns the old "school_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSchoolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchoolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchoolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchoolName: %w", err)
	}
	return oldValue.SchoolName, nil
}

// ClearSchoolName clears the value of the "school_name" field.
func (m *UserMutation) ClearSchoolName() {
	m.school_name = nil
	m.clearedFields[user.FieldSchoolName] = struct{}{}
}

// SchoolNameCleared returns if the "school_name" field was cleared in this mutation.
func (m *UserMutation) SchoolNameCleared() bool {
	_, ok := m.clearedFields[user.FieldSchoolName]
	return ok
}

// ResetSchoolName resets all changes to the "school_name" field.
func (m *UserMutation) ResetSchoolName() {
	m.school_name = nil
	delete(m.clearedFields, user.FieldSchoolName)
}

// SetBio sets the "bio" field.
func (m *UserMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *UserMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *UserMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[user.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *UserMutation) BioCleared() bool {
	_, ok := m.clearedFields[user.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *UserMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, user.FieldBio)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(u user.Status) {
	m.status = &u
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r user.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v user.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v user.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetIsOnline sets the "is_online" field.
func (m *UserMutation) SetIsOnline(b bool) {
	m.is_online = &b
}

// IsOnline returns the value of the "is_online" field in the mutation.
func (m *UserMutation) IsOnline() (r bool, exists bool) {
	v := m.is_online
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOnline returns the old "is_online" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOnline(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOnline: %w", err)
	}
	return oldValue.IsOnline, nil
}

// ClearIsOnline clears the value of the "is_online" field.
func (m *UserMutation) ClearIsOnline() {
	m.is_online = nil
	m.clearedFields[user.FieldIsOnline] = struct{}{}
}

// IsOnlineCleared returns if the "is_online" field was cleared in this mutation.
func (m *UserMutation) IsOnlineCleared() bool {
	_, ok := m.clearedFields[user.FieldIsOnline]
	return ok
}

// ResetIsOnline resets all changes to the "is_online" field.
func (m *UserMutation) ResetIsOnline() {
	m.is_online = nil
	delete(m.clearedFields, user.FieldIsOnline)
}

// SetIsShowCollections sets the "is_show_collections" field.
func (m *UserMutation) SetIsShowCollections(b bool) {
	m.is_show_collections = &b
}

// IsShowCollections returns the value of the "is_show_collections" field in the mutation.
func (m *UserMutation) IsShowCollections() (r bool, exists bool) {
	v := m.is_show_collections
	if v == nil {
		return
	}
	return *v, true
}

// OldIsShowCollections returns the old "is_show_collections" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsShowCollections(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsShowCollections is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsShowCollections requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsShowCollections: %w", err)
	}
	return oldValue.IsShowCollections, nil
}

// ResetIsShowCollections resets all changes to the "is_show_collections" field.
func (m *UserMutation) ResetIsShowCollections() {
	m.is_show_collections = nil
}

// SetIsInvited sets the "is_invited" field.
func (m *UserMutation) SetIsInvited(b bool) {
	m.is_invited = &b
}

// IsInvited returns the value of the "is_invited" field in the mutation.
func (m *UserMutation) IsInvited() (r bool, exists bool) {
	v := m.is_invited
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInvited returns the old "is_invited" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsInvited(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInvited is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInvited requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInvited: %w", err)
	}
	return oldValue.IsInvited, nil
}

// ResetIsInvited resets all changes to the "is_invited" field.
func (m *UserMutation) ResetIsInvited() {
	m.is_invited = nil
}

// SetNeedPrivacyConfirm sets the "need_privacy_confirm" field.
func (m *UserMutation) SetNeedPrivacyConfirm(b bool) {
	m.need_privacy_confirm = &b
}

// NeedPrivacyConfirm returns the value of the "need_privacy_confirm" field in the mutation.
func (m *UserMutation) NeedPrivacyConfirm() (r bool, exists bool) {
	v := m.need_privacy_confirm
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedPrivacyConfirm returns the old "need_privacy_confirm" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNeedPrivacyConfirm(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedPrivacyConfirm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedPrivacyConfirm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedPrivacyConfirm: %w", err)
	}
	return oldValue.NeedPrivacyConfirm, nil
}

// ResetNeedPrivacyConfirm resets all changes to the "need_privacy_confirm" field.
func (m *UserMutation) ResetNeedPrivacyConfirm() {
	m.need_privacy_confirm = nil
}

// SetCurrentCsFieldID sets the "current_cs_field_id" field.
func (m *UserMutation) SetCurrentCsFieldID(u uint64) {
	m.current_cs_field_id = &u
	m.addcurrent_cs_field_id = nil
}

// CurrentCsFieldID returns the value of the "current_cs_field_id" field in the mutation.
func (m *UserMutation) CurrentCsFieldID() (r uint64, exists bool) {
	v := m.current_cs_field_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentCsFieldID returns the old "current_cs_field_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrentCsFieldID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentCsFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentCsFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentCsFieldID: %w", err)
	}
	return oldValue.CurrentCsFieldID, nil
}

// AddCurrentCsFieldID adds u to the "current_cs_field_id" field.
func (m *UserMutation) AddCurrentCsFieldID(u int64) {
	if m.addcurrent_cs_field_id != nil {
		*m.addcurrent_cs_field_id += u
	} else {
		m.addcurrent_cs_field_id = &u
	}
}

// AddedCurrentCsFieldID returns the value that was added to the "current_cs_field_id" field in this mutation.
func (m *UserMutation) AddedCurrentCsFieldID() (r int64, exists bool) {
	v := m.addcurrent_cs_field_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentCsFieldID clears the value of the "current_cs_field_id" field.
func (m *UserMutation) ClearCurrentCsFieldID() {
	m.current_cs_field_id = nil
	m.addcurrent_cs_field_id = nil
	m.clearedFields[user.FieldCurrentCsFieldID] = struct{}{}
}

// CurrentCsFieldIDCleared returns if the "current_cs_field_id" field was cleared in this mutation.
func (m *UserMutation) CurrentCsFieldIDCleared() bool {
	_, ok := m.clearedFields[user.FieldCurrentCsFieldID]
	return ok
}

// ResetCurrentCsFieldID resets all changes to the "current_cs_field_id" field.
func (m *UserMutation) ResetCurrentCsFieldID() {
	m.current_cs_field_id = nil
	m.addcurrent_cs_field_id = nil
	delete(m.clearedFields, user.FieldCurrentCsFieldID)
}

// SetCurrentCsFieldName sets the "current_cs_field_name" field.
func (m *UserMutation) SetCurrentCsFieldName(s string) {
	m.current_cs_field_name = &s
}

// CurrentCsFieldName returns the value of the "current_cs_field_name" field in the mutation.
func (m *UserMutation) CurrentCsFieldName() (r string, exists bool) {
	v := m.current_cs_field_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentCsFieldName returns the old "current_cs_field_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCurrentCsFieldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentCsFieldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentCsFieldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentCsFieldName: %w", err)
	}
	return oldValue.CurrentCsFieldName, nil
}

// ClearCurrentCsFieldName clears the value of the "current_cs_field_name" field.
func (m *UserMutation) ClearCurrentCsFieldName() {
	m.current_cs_field_name = nil
	m.clearedFields[user.FieldCurrentCsFieldName] = struct{}{}
}

// CurrentCsFieldNameCleared returns if the "current_cs_field_name" field was cleared in this mutation.
func (m *UserMutation) CurrentCsFieldNameCleared() bool {
	_, ok := m.clearedFields[user.FieldCurrentCsFieldName]
	return ok
}

// ResetCurrentCsFieldName resets all changes to the "current_cs_field_name" field.
func (m *UserMutation) ResetCurrentCsFieldName() {
	m.current_cs_field_name = nil
	delete(m.clearedFields, user.FieldCurrentCsFieldName)
}

// SetPrivateCsFieldID sets the "private_cs_field_id" field.
func (m *UserMutation) SetPrivateCsFieldID(u uint64) {
	m.private_cs_field_id = &u
	m.addprivate_cs_field_id = nil
}

// PrivateCsFieldID returns the value of the "private_cs_field_id" field in the mutation.
func (m *UserMutation) PrivateCsFieldID() (r uint64, exists bool) {
	v := m.private_cs_field_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateCsFieldID returns the old "private_cs_field_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrivateCsFieldID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateCsFieldID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateCsFieldID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateCsFieldID: %w", err)
	}
	return oldValue.PrivateCsFieldID, nil
}

// AddPrivateCsFieldID adds u to the "private_cs_field_id" field.
func (m *UserMutation) AddPrivateCsFieldID(u int64) {
	if m.addprivate_cs_field_id != nil {
		*m.addprivate_cs_field_id += u
	} else {
		m.addprivate_cs_field_id = &u
	}
}

// AddedPrivateCsFieldID returns the value that was added to the "private_cs_field_id" field in this mutation.
func (m *UserMutation) AddedPrivateCsFieldID() (r int64, exists bool) {
	v := m.addprivate_cs_field_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrivateCsFieldID clears the value of the "private_cs_field_id" field.
func (m *UserMutation) ClearPrivateCsFieldID() {
	m.private_cs_field_id = nil
	m.addprivate_cs_field_id = nil
	m.clearedFields[user.FieldPrivateCsFieldID] = struct{}{}
}

// PrivateCsFieldIDCleared returns if the "private_cs_field_id" field was cleared in this mutation.
func (m *UserMutation) PrivateCsFieldIDCleared() bool {
	_, ok := m.clearedFields[user.FieldPrivateCsFieldID]
	return ok
}

// ResetPrivateCsFieldID resets all changes to the "private_cs_field_id" field.
func (m *UserMutation) ResetPrivateCsFieldID() {
	m.private_cs_field_id = nil
	m.addprivate_cs_field_id = nil
	delete(m.clearedFields, user.FieldPrivateCsFieldID)
}

// SetPrivateCsFieldName sets the "private_cs_field_name" field.
func (m *UserMutation) SetPrivateCsFieldName(s string) {
	m.private_cs_field_name = &s
}

// PrivateCsFieldName returns the value of the "private_cs_field_name" field in the mutation.
func (m *UserMutation) PrivateCsFieldName() (r string, exists bool) {
	v := m.private_cs_field_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateCsFieldName returns the old "private_cs_field_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPrivateCsFieldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateCsFieldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateCsFieldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateCsFieldName: %w", err)
	}
	return oldValue.PrivateCsFieldName, nil
}

// ClearPrivateCsFieldName clears the value of the "private_cs_field_name" field.
func (m *UserMutation) ClearPrivateCsFieldName() {
	m.private_cs_field_name = nil
	m.clearedFields[user.FieldPrivateCsFieldName] = struct{}{}
}

// PrivateCsFieldNameCleared returns if the "private_cs_field_name" field was cleared in this mutation.
func (m *UserMutation) PrivateCsFieldNameCleared() bool {
	_, ok := m.clearedFields[user.FieldPrivateCsFieldName]
	return ok
}

// ResetPrivateCsFieldName resets all changes to the "private_cs_field_name" field.
func (m *UserMutation) ResetPrivateCsFieldName() {
	m.private_cs_field_name = nil
	delete(m.clearedFields, user.FieldPrivateCsFieldName)
}

// SetRegisterIP sets the "register_ip" field.
func (m *UserMutation) SetRegisterIP(s string) {
	m.register_ip = &s
}

// RegisterIP returns the value of the "register_ip" field in the mutation.
func (m *UserMutation) RegisterIP() (r string, exists bool) {
	v := m.register_ip
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterIP returns the old "register_ip" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegisterIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegisterIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegisterIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterIP: %w", err)
	}
	return oldValue.RegisterIP, nil
}

// ClearRegisterIP clears the value of the "register_ip" field.
func (m *UserMutation) ClearRegisterIP() {
	m.register_ip = nil
	m.clearedFields[user.FieldRegisterIP] = struct{}{}
}

// RegisterIPCleared returns if the "register_ip" field was cleared in this mutation.
func (m *UserMutation) RegisterIPCleared() bool {
	_, ok := m.clearedFields[user.FieldRegisterIP]
	return ok
}

// ResetRegisterIP resets all changes to the "register_ip" field.
func (m *UserMutation) ResetRegisterIP() {
	m.register_ip = nil
	delete(m.clearedFields, user.FieldRegisterIP)
}

// SetConstellation sets the "constellation" field.
func (m *UserMutation) SetConstellation(s string) {
	m.constellation = &s
}

// Constellation returns the value of the "constellation" field in the mutation.
func (m *UserMutation) Constellation() (r string, exists bool) {
	v := m.constellation
	if v == nil {
		return
	}
	return *v, true
}

// OldConstellation returns the old "constellation" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConstellation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstellation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstellation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstellation: %w", err)
	}
	return oldValue.Constellation, nil
}

// ClearConstellation clears the value of the "constellation" field.
func (m *UserMutation) ClearConstellation() {
	m.constellation = nil
	m.clearedFields[user.FieldConstellation] = struct{}{}
}

// ConstellationCleared returns if the "constellation" field was cleared in this mutation.
func (m *UserMutation) ConstellationCleared() bool {
	_, ok := m.clearedFields[user.FieldConstellation]
	return ok
}

// ResetConstellation resets all changes to the "constellation" field.
func (m *UserMutation) ResetConstellation() {
	m.constellation = nil
	delete(m.clearedFields, user.FieldConstellation)
}

// SetTotalConnections sets the "total_connections" field.
func (m *UserMutation) SetTotalConnections(i int) {
	m.total_connections = &i
	m.addtotal_connections = nil
}

// TotalConnections returns the value of the "total_connections" field in the mutation.
func (m *UserMutation) TotalConnections() (r int, exists bool) {
	v := m.total_connections
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalConnections returns the old "total_connections" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotalConnections(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalConnections is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalConnections requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalConnections: %w", err)
	}
	return oldValue.TotalConnections, nil
}

// AddTotalConnections adds i to the "total_connections" field.
func (m *UserMutation) AddTotalConnections(i int) {
	if m.addtotal_connections != nil {
		*m.addtotal_connections += i
	} else {
		m.addtotal_connections = &i
	}
}

// AddedTotalConnections returns the value that was added to the "total_connections" field in this mutation.
func (m *UserMutation) AddedTotalConnections() (r int, exists bool) {
	v := m.addtotal_connections
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalConnections clears the value of the "total_connections" field.
func (m *UserMutation) ClearTotalConnections() {
	m.total_connections = nil
	m.addtotal_connections = nil
	m.clearedFields[user.FieldTotalConnections] = struct{}{}
}

// TotalConnectionsCleared returns if the "total_connections" field was cleared in this mutation.
func (m *UserMutation) TotalConnectionsCleared() bool {
	_, ok := m.clearedFields[user.FieldTotalConnections]
	return ok
}

// ResetTotalConnections resets all changes to the "total_connections" field.
func (m *UserMutation) ResetTotalConnections() {
	m.total_connections = nil
	m.addtotal_connections = nil
	delete(m.clearedFields, user.FieldTotalConnections)
}

// AddUserAuthIDs adds the "user_auth" edge to the User_auth entity by ids.
func (m *UserMutation) AddUserAuthIDs(ids ...int) {
	if m.user_auth == nil {
		m.user_auth = make(map[int]struct{})
	}
	for i := range ids {
		m.user_auth[ids[i]] = struct{}{}
	}
}

// ClearUserAuth clears the "user_auth" edge to the User_auth entity.
func (m *UserMutation) ClearUserAuth() {
	m.cleareduser_auth = true
}

// UserAuthCleared reports if the "user_auth" edge to the User_auth entity was cleared.
func (m *UserMutation) UserAuthCleared() bool {
	return m.cleareduser_auth
}

// RemoveUserAuthIDs removes the "user_auth" edge to the User_auth entity by IDs.
func (m *UserMutation) RemoveUserAuthIDs(ids ...int) {
	if m.removeduser_auth == nil {
		m.removeduser_auth = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_auth, ids[i])
		m.removeduser_auth[ids[i]] = struct{}{}
	}
}

// RemovedUserAuth returns the removed IDs of the "user_auth" edge to the User_auth entity.
func (m *UserMutation) RemovedUserAuthIDs() (ids []int) {
	for id := range m.removeduser_auth {
		ids = append(ids, id)
	}
	return
}

// UserAuthIDs returns the "user_auth" edge IDs in the mutation.
func (m *UserMutation) UserAuthIDs() (ids []int) {
	for id := range m.user_auth {
		ids = append(ids, id)
	}
	return
}

// ResetUserAuth resets all changes to the "user_auth" edge.
func (m *UserMutation) ResetUserAuth() {
	m.user_auth = nil
	m.cleareduser_auth = false
	m.removeduser_auth = nil
}

// AddCardIDs adds the "card" edge to the Card entity by ids.
func (m *UserMutation) AddCardIDs(ids ...uint64) {
	if m.card == nil {
		m.card = make(map[uint64]struct{})
	}
	for i := range ids {
		m.card[ids[i]] = struct{}{}
	}
}

// ClearCard clears the "card" edge to the Card entity.
func (m *UserMutation) ClearCard() {
	m.clearedcard = true
}

// CardCleared reports if the "card" edge to the Card entity was cleared.
func (m *UserMutation) CardCleared() bool {
	return m.clearedcard
}

// RemoveCardIDs removes the "card" edge to the Card entity by IDs.
func (m *UserMutation) RemoveCardIDs(ids ...uint64) {
	if m.removedcard == nil {
		m.removedcard = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.card, ids[i])
		m.removedcard[ids[i]] = struct{}{}
	}
}

// RemovedCard returns the removed IDs of the "card" edge to the Card entity.
func (m *UserMutation) RemovedCardIDs() (ids []uint64) {
	for id := range m.removedcard {
		ids = append(ids, id)
	}
	return
}

// CardIDs returns the "card" edge IDs in the mutation.
func (m *UserMutation) CardIDs() (ids []uint64) {
	for id := range m.card {
		ids = append(ids, id)
	}
	return
}

// ResetCard resets all changes to the "card" edge.
func (m *UserMutation) ResetCard() {
	m.card = nil
	m.clearedcard = false
	m.removedcard = nil
}

// AddMessageIDs adds the "message" edge to the Message entity by ids.
func (m *UserMutation) AddMessageIDs(ids ...uint64) {
	if m.message == nil {
		m.message = make(map[uint64]struct{})
	}
	for i := range ids {
		m.message[ids[i]] = struct{}{}
	}
}

// ClearMessage clears the "message" edge to the Message entity.
func (m *UserMutation) ClearMessage() {
	m.clearedmessage = true
}

// MessageCleared reports if the "message" edge to the Message entity was cleared.
func (m *UserMutation) MessageCleared() bool {
	return m.clearedmessage
}

// RemoveMessageIDs removes the "message" edge to the Message entity by IDs.
func (m *UserMutation) RemoveMessageIDs(ids ...uint64) {
	if m.removedmessage == nil {
		m.removedmessage = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.message, ids[i])
		m.removedmessage[ids[i]] = struct{}{}
	}
}

// RemovedMessage returns the removed IDs of the "message" edge to the Message entity.
func (m *UserMutation) RemovedMessageIDs() (ids []uint64) {
	for id := range m.removedmessage {
		ids = append(ids, id)
	}
	return
}

// MessageIDs returns the "message" edge IDs in the mutation.
func (m *UserMutation) MessageIDs() (ids []uint64) {
	for id := range m.message {
		ids = append(ids, id)
	}
	return
}

// ResetMessage resets all changes to the "message" edge.
func (m *UserMutation) ResetMessage() {
	m.message = nil
	m.clearedmessage = false
	m.removedmessage = nil
}

// AddDeviceIDs adds the "device" edge to the Device entity by ids.
func (m *UserMutation) AddDeviceIDs(ids ...uint64) {
	if m.device == nil {
		m.device = make(map[uint64]struct{})
	}
	for i := range ids {
		m.device[ids[i]] = struct{}{}
	}
}

// ClearDevice clears the "device" edge to the Device entity.
func (m *UserMutation) ClearDevice() {
	m.cleareddevice = true
}

// DeviceCleared reports if the "device" edge to the Device entity was cleared.
func (m *UserMutation) DeviceCleared() bool {
	return m.cleareddevice
}

// RemoveDeviceIDs removes the "device" edge to the Device entity by IDs.
func (m *UserMutation) RemoveDeviceIDs(ids ...uint64) {
	if m.removeddevice == nil {
		m.removeddevice = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.device, ids[i])
		m.removeddevice[ids[i]] = struct{}{}
	}
}

// RemovedDevice returns the removed IDs of the "device" edge to the Device entity.
func (m *UserMutation) RemovedDeviceIDs() (ids []uint64) {
	for id := range m.removeddevice {
		ids = append(ids, id)
	}
	return
}

// DeviceIDs returns the "device" edge IDs in the mutation.
func (m *UserMutation) DeviceIDs() (ids []uint64) {
	for id := range m.device {
		ids = append(ids, id)
	}
	return
}

// ResetDevice resets all changes to the "device" edge.
func (m *UserMutation) ResetDevice() {
	m.device = nil
	m.cleareddevice = false
	m.removeddevice = nil
}

// AddJoinedCsfieldIDs adds the "joined_csfield" edge to the CSField entity by ids.
func (m *UserMutation) AddJoinedCsfieldIDs(ids ...uint64) {
	if m.joined_csfield == nil {
		m.joined_csfield = make(map[uint64]struct{})
	}
	for i := range ids {
		m.joined_csfield[ids[i]] = struct{}{}
	}
}

// ClearJoinedCsfield clears the "joined_csfield" edge to the CSField entity.
func (m *UserMutation) ClearJoinedCsfield() {
	m.clearedjoined_csfield = true
}

// JoinedCsfieldCleared reports if the "joined_csfield" edge to the CSField entity was cleared.
func (m *UserMutation) JoinedCsfieldCleared() bool {
	return m.clearedjoined_csfield
}

// RemoveJoinedCsfieldIDs removes the "joined_csfield" edge to the CSField entity by IDs.
func (m *UserMutation) RemoveJoinedCsfieldIDs(ids ...uint64) {
	if m.removedjoined_csfield == nil {
		m.removedjoined_csfield = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.joined_csfield, ids[i])
		m.removedjoined_csfield[ids[i]] = struct{}{}
	}
}

// RemovedJoinedCsfield returns the removed IDs of the "joined_csfield" edge to the CSField entity.
func (m *UserMutation) RemovedJoinedCsfieldIDs() (ids []uint64) {
	for id := range m.removedjoined_csfield {
		ids = append(ids, id)
	}
	return
}

// JoinedCsfieldIDs returns the "joined_csfield" edge IDs in the mutation.
func (m *UserMutation) JoinedCsfieldIDs() (ids []uint64) {
	for id := range m.joined_csfield {
		ids = append(ids, id)
	}
	return
}

// ResetJoinedCsfield resets all changes to the "joined_csfield" edge.
func (m *UserMutation) ResetJoinedCsfield() {
	m.joined_csfield = nil
	m.clearedjoined_csfield = false
	m.removedjoined_csfield = nil
}

// AddFriendIDs adds the "friends" edge to the User entity by ids.
func (m *UserMutation) AddFriendIDs(ids ...uint64) {
	if m.friends == nil {
		m.friends = make(map[uint64]struct{})
	}
	for i := range ids {
		m.friends[ids[i]] = struct{}{}
	}
}

// ClearFriends clears the "friends" edge to the User entity.
func (m *UserMutation) ClearFriends() {
	m.clearedfriends = true
}

// FriendsCleared reports if the "friends" edge to the User entity was cleared.
func (m *UserMutation) FriendsCleared() bool {
	return m.clearedfriends
}

// RemoveFriendIDs removes the "friends" edge to the User entity by IDs.
func (m *UserMutation) RemoveFriendIDs(ids ...uint64) {
	if m.removedfriends == nil {
		m.removedfriends = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.friends, ids[i])
		m.removedfriends[ids[i]] = struct{}{}
	}
}

// RemovedFriends returns the removed IDs of the "friends" edge to the User entity.
func (m *UserMutation) RemovedFriendsIDs() (ids []uint64) {
	for id := range m.removedfriends {
		ids = append(ids, id)
	}
	return
}

// FriendsIDs returns the "friends" edge IDs in the mutation.
func (m *UserMutation) FriendsIDs() (ids []uint64) {
	for id := range m.friends {
		ids = append(ids, id)
	}
	return
}

// ResetFriends resets all changes to the "friends" edge.
func (m *UserMutation) ResetFriends() {
	m.friends = nil
	m.clearedfriends = false
	m.removedfriends = nil
}

// AddHiddenIDs adds the "hidden" edge to the Hidden entity by ids.
func (m *UserMutation) AddHiddenIDs(ids ...int) {
	if m.hidden == nil {
		m.hidden = make(map[int]struct{})
	}
	for i := range ids {
		m.hidden[ids[i]] = struct{}{}
	}
}

// ClearHidden clears the "hidden" edge to the Hidden entity.
func (m *UserMutation) ClearHidden() {
	m.clearedhidden = true
}

// HiddenCleared reports if the "hidden" edge to the Hidden entity was cleared.
func (m *UserMutation) HiddenCleared() bool {
	return m.clearedhidden
}

// RemoveHiddenIDs removes the "hidden" edge to the Hidden entity by IDs.
func (m *UserMutation) RemoveHiddenIDs(ids ...int) {
	if m.removedhidden == nil {
		m.removedhidden = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.hidden, ids[i])
		m.removedhidden[ids[i]] = struct{}{}
	}
}

// RemovedHidden returns the removed IDs of the "hidden" edge to the Hidden entity.
func (m *UserMutation) RemovedHiddenIDs() (ids []int) {
	for id := range m.removedhidden {
		ids = append(ids, id)
	}
	return
}

// HiddenIDs returns the "hidden" edge IDs in the mutation.
func (m *UserMutation) HiddenIDs() (ids []int) {
	for id := range m.hidden {
		ids = append(ids, id)
	}
	return
}

// ResetHidden resets all changes to the "hidden" edge.
func (m *UserMutation) ResetHidden() {
	m.hidden = nil
	m.clearedhidden = false
	m.removedhidden = nil
}

// AddHistoryIDs adds the "history" edge to the User_history entity by ids.
func (m *UserMutation) AddHistoryIDs(ids ...uint64) {
	if m.history == nil {
		m.history = make(map[uint64]struct{})
	}
	for i := range ids {
		m.history[ids[i]] = struct{}{}
	}
}

// ClearHistory clears the "history" edge to the User_history entity.
func (m *UserMutation) ClearHistory() {
	m.clearedhistory = true
}

// HistoryCleared reports if the "history" edge to the User_history entity was cleared.
func (m *UserMutation) HistoryCleared() bool {
	return m.clearedhistory
}

// RemoveHistoryIDs removes the "history" edge to the User_history entity by IDs.
func (m *UserMutation) RemoveHistoryIDs(ids ...uint64) {
	if m.removedhistory == nil {
		m.removedhistory = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.history, ids[i])
		m.removedhistory[ids[i]] = struct{}{}
	}
}

// RemovedHistory returns the removed IDs of the "history" edge to the User_history entity.
func (m *UserMutation) RemovedHistoryIDs() (ids []uint64) {
	for id := range m.removedhistory {
		ids = append(ids, id)
	}
	return
}

// HistoryIDs returns the "history" edge IDs in the mutation.
func (m *UserMutation) HistoryIDs() (ids []uint64) {
	for id := range m.history {
		ids = append(ids, id)
	}
	return
}

// ResetHistory resets all changes to the "history" edge.
func (m *UserMutation) ResetHistory() {
	m.history = nil
	m.clearedhistory = false
	m.removedhistory = nil
}

// AddTokenIDs adds the "token" edge to the Agora_token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...uint64) {
	if m.token == nil {
		m.token = make(map[uint64]struct{})
	}
	for i := range ids {
		m.token[ids[i]] = struct{}{}
	}
}

// ClearToken clears the "token" edge to the Agora_token entity.
func (m *UserMutation) ClearToken() {
	m.clearedtoken = true
}

// TokenCleared reports if the "token" edge to the Agora_token entity was cleared.
func (m *UserMutation) TokenCleared() bool {
	return m.clearedtoken
}

// RemoveTokenIDs removes the "token" edge to the Agora_token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...uint64) {
	if m.removedtoken == nil {
		m.removedtoken = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.token, ids[i])
		m.removedtoken[ids[i]] = struct{}{}
	}
}

// RemovedToken returns the removed IDs of the "token" edge to the Agora_token entity.
func (m *UserMutation) RemovedTokenIDs() (ids []uint64) {
	for id := range m.removedtoken {
		ids = append(ids, id)
	}
	return
}

// TokenIDs returns the "token" edge IDs in the mutation.
func (m *UserMutation) TokenIDs() (ids []uint64) {
	for id := range m.token {
		ids = append(ids, id)
	}
	return
}

// ResetToken resets all changes to the "token" edge.
func (m *UserMutation) ResetToken() {
	m.token = nil
	m.clearedtoken = false
	m.removedtoken = nil
}

// AddCreationIDs adds the "creation" edge to the Creation entity by ids.
func (m *UserMutation) AddCreationIDs(ids ...uint64) {
	if m.creation == nil {
		m.creation = make(map[uint64]struct{})
	}
	for i := range ids {
		m.creation[ids[i]] = struct{}{}
	}
}

// ClearCreation clears the "creation" edge to the Creation entity.
func (m *UserMutation) ClearCreation() {
	m.clearedcreation = true
}

// CreationCleared reports if the "creation" edge to the Creation entity was cleared.
func (m *UserMutation) CreationCleared() bool {
	return m.clearedcreation
}

// RemoveCreationIDs removes the "creation" edge to the Creation entity by IDs.
func (m *UserMutation) RemoveCreationIDs(ids ...uint64) {
	if m.removedcreation == nil {
		m.removedcreation = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.creation, ids[i])
		m.removedcreation[ids[i]] = struct{}{}
	}
}

// RemovedCreation returns the removed IDs of the "creation" edge to the Creation entity.
func (m *UserMutation) RemovedCreationIDs() (ids []uint64) {
	for id := range m.removedcreation {
		ids = append(ids, id)
	}
	return
}

// CreationIDs returns the "creation" edge IDs in the mutation.
func (m *UserMutation) CreationIDs() (ids []uint64) {
	for id := range m.creation {
		ids = append(ids, id)
	}
	return
}

// ResetCreation resets all changes to the "creation" edge.
func (m *UserMutation) ResetCreation() {
	m.creation = nil
	m.clearedcreation = false
	m.removedcreation = nil
}

// AddContactIDs adds the "contact" edge to the Contact entity by ids.
func (m *UserMutation) AddContactIDs(ids ...uint64) {
	if m.contact == nil {
		m.contact = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contact[ids[i]] = struct{}{}
	}
}

// ClearContact clears the "contact" edge to the Contact entity.
func (m *UserMutation) ClearContact() {
	m.clearedcontact = true
}

// ContactCleared reports if the "contact" edge to the Contact entity was cleared.
func (m *UserMutation) ContactCleared() bool {
	return m.clearedcontact
}

// RemoveContactIDs removes the "contact" edge to the Contact entity by IDs.
func (m *UserMutation) RemoveContactIDs(ids ...uint64) {
	if m.removedcontact == nil {
		m.removedcontact = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contact, ids[i])
		m.removedcontact[ids[i]] = struct{}{}
	}
}

// RemovedContact returns the removed IDs of the "contact" edge to the Contact entity.
func (m *UserMutation) RemovedContactIDs() (ids []uint64) {
	for id := range m.removedcontact {
		ids = append(ids, id)
	}
	return
}

// ContactIDs returns the "contact" edge IDs in the mutation.
func (m *UserMutation) ContactIDs() (ids []uint64) {
	for id := range m.contact {
		ids = append(ids, id)
	}
	return
}

// ResetContact resets all changes to the "contact" edge.
func (m *UserMutation) ResetContact() {
	m.contact = nil
	m.clearedcontact = false
	m.removedcontact = nil
}

// AddSettingIDs adds the "setting" edge to the Setting entity by ids.
func (m *UserMutation) AddSettingIDs(ids ...uint64) {
	if m.setting == nil {
		m.setting = make(map[uint64]struct{})
	}
	for i := range ids {
		m.setting[ids[i]] = struct{}{}
	}
}

// ClearSetting clears the "setting" edge to the Setting entity.
func (m *UserMutation) ClearSetting() {
	m.clearedsetting = true
}

// SettingCleared reports if the "setting" edge to the Setting entity was cleared.
func (m *UserMutation) SettingCleared() bool {
	return m.clearedsetting
}

// RemoveSettingIDs removes the "setting" edge to the Setting entity by IDs.
func (m *UserMutation) RemoveSettingIDs(ids ...uint64) {
	if m.removedsetting == nil {
		m.removedsetting = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.setting, ids[i])
		m.removedsetting[ids[i]] = struct{}{}
	}
}

// RemovedSetting returns the removed IDs of the "setting" edge to the Setting entity.
func (m *UserMutation) RemovedSettingIDs() (ids []uint64) {
	for id := range m.removedsetting {
		ids = append(ids, id)
	}
	return
}

// SettingIDs returns the "setting" edge IDs in the mutation.
func (m *UserMutation) SettingIDs() (ids []uint64) {
	for id := range m.setting {
		ids = append(ids, id)
	}
	return
}

// ResetSetting resets all changes to the "setting" edge.
func (m *UserMutation) ResetSetting() {
	m.setting = nil
	m.clearedsetting = false
	m.removedsetting = nil
}

// AddNftIDs adds the "nft" edge to the NFT entity by ids.
func (m *UserMutation) AddNftIDs(ids ...uint64) {
	if m.nft == nil {
		m.nft = make(map[uint64]struct{})
	}
	for i := range ids {
		m.nft[ids[i]] = struct{}{}
	}
}

// ClearNft clears the "nft" edge to the NFT entity.
func (m *UserMutation) ClearNft() {
	m.clearednft = true
}

// NftCleared reports if the "nft" edge to the NFT entity was cleared.
func (m *UserMutation) NftCleared() bool {
	return m.clearednft
}

// RemoveNftIDs removes the "nft" edge to the NFT entity by IDs.
func (m *UserMutation) RemoveNftIDs(ids ...uint64) {
	if m.removednft == nil {
		m.removednft = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.nft, ids[i])
		m.removednft[ids[i]] = struct{}{}
	}
}

// RemovedNft returns the removed IDs of the "nft" edge to the NFT entity.
func (m *UserMutation) RemovedNftIDs() (ids []uint64) {
	for id := range m.removednft {
		ids = append(ids, id)
	}
	return
}

// NftIDs returns the "nft" edge IDs in the mutation.
func (m *UserMutation) NftIDs() (ids []uint64) {
	for id := range m.nft {
		ids = append(ids, id)
	}
	return
}

// ResetNft resets all changes to the "nft" edge.
func (m *UserMutation) ResetNft() {
	m.nft = nil
	m.clearednft = false
	m.removednft = nil
}

// AddStreamIDs adds the "stream" edge to the Stream entity by ids.
func (m *UserMutation) AddStreamIDs(ids ...uint64) {
	if m.stream == nil {
		m.stream = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stream[ids[i]] = struct{}{}
	}
}

// ClearStream clears the "stream" edge to the Stream entity.
func (m *UserMutation) ClearStream() {
	m.clearedstream = true
}

// StreamCleared reports if the "stream" edge to the Stream entity was cleared.
func (m *UserMutation) StreamCleared() bool {
	return m.clearedstream
}

// RemoveStreamIDs removes the "stream" edge to the Stream entity by IDs.
func (m *UserMutation) RemoveStreamIDs(ids ...uint64) {
	if m.removedstream == nil {
		m.removedstream = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stream, ids[i])
		m.removedstream[ids[i]] = struct{}{}
	}
}

// RemovedStream returns the removed IDs of the "stream" edge to the Stream entity.
func (m *UserMutation) RemovedStreamIDs() (ids []uint64) {
	for id := range m.removedstream {
		ids = append(ids, id)
	}
	return
}

// StreamIDs returns the "stream" edge IDs in the mutation.
func (m *UserMutation) StreamIDs() (ids []uint64) {
	for id := range m.stream {
		ids = append(ids, id)
	}
	return
}

// ResetStream resets all changes to the "stream" edge.
func (m *UserMutation) ResetStream() {
	m.stream = nil
	m.clearedstream = false
	m.removedstream = nil
}

// AddMaskIDs adds the "mask" edge to the Mask entity by ids.
func (m *UserMutation) AddMaskIDs(ids ...uint64) {
	if m.mask == nil {
		m.mask = make(map[uint64]struct{})
	}
	for i := range ids {
		m.mask[ids[i]] = struct{}{}
	}
}

// ClearMask clears the "mask" edge to the Mask entity.
func (m *UserMutation) ClearMask() {
	m.clearedmask = true
}

// MaskCleared reports if the "mask" edge to the Mask entity was cleared.
func (m *UserMutation) MaskCleared() bool {
	return m.clearedmask
}

// RemoveMaskIDs removes the "mask" edge to the Mask entity by IDs.
func (m *UserMutation) RemoveMaskIDs(ids ...uint64) {
	if m.removedmask == nil {
		m.removedmask = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.mask, ids[i])
		m.removedmask[ids[i]] = struct{}{}
	}
}

// RemovedMask returns the removed IDs of the "mask" edge to the Mask entity.
func (m *UserMutation) RemovedMaskIDs() (ids []uint64) {
	for id := range m.removedmask {
		ids = append(ids, id)
	}
	return
}

// MaskIDs returns the "mask" edge IDs in the mutation.
func (m *UserMutation) MaskIDs() (ids []uint64) {
	for id := range m.mask {
		ids = append(ids, id)
	}
	return
}

// ResetMask resets all changes to the "mask" edge.
func (m *UserMutation) ResetMask() {
	m.mask = nil
	m.clearedmask = false
	m.removedmask = nil
}

// AddTimedewIDs adds the "timedew" edge to the TimeDew entity by ids.
func (m *UserMutation) AddTimedewIDs(ids ...uint64) {
	if m.timedew == nil {
		m.timedew = make(map[uint64]struct{})
	}
	for i := range ids {
		m.timedew[ids[i]] = struct{}{}
	}
}

// ClearTimedew clears the "timedew" edge to the TimeDew entity.
func (m *UserMutation) ClearTimedew() {
	m.clearedtimedew = true
}

// TimedewCleared reports if the "timedew" edge to the TimeDew entity was cleared.
func (m *UserMutation) TimedewCleared() bool {
	return m.clearedtimedew
}

// RemoveTimedewIDs removes the "timedew" edge to the TimeDew entity by IDs.
func (m *UserMutation) RemoveTimedewIDs(ids ...uint64) {
	if m.removedtimedew == nil {
		m.removedtimedew = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.timedew, ids[i])
		m.removedtimedew[ids[i]] = struct{}{}
	}
}

// RemovedTimedew returns the removed IDs of the "timedew" edge to the TimeDew entity.
func (m *UserMutation) RemovedTimedewIDs() (ids []uint64) {
	for id := range m.removedtimedew {
		ids = append(ids, id)
	}
	return
}

// TimedewIDs returns the "timedew" edge IDs in the mutation.
func (m *UserMutation) TimedewIDs() (ids []uint64) {
	for id := range m.timedew {
		ids = append(ids, id)
	}
	return
}

// ResetTimedew resets all changes to the "timedew" edge.
func (m *UserMutation) ResetTimedew() {
	m.timedew = nil
	m.clearedtimedew = false
	m.removedtimedew = nil
}

// AddCollectionIDs adds the "collection" edge to the Collection entity by ids.
func (m *UserMutation) AddCollectionIDs(ids ...uint64) {
	if m.collection == nil {
		m.collection = make(map[uint64]struct{})
	}
	for i := range ids {
		m.collection[ids[i]] = struct{}{}
	}
}

// ClearCollection clears the "collection" edge to the Collection entity.
func (m *UserMutation) ClearCollection() {
	m.clearedcollection = true
}

// CollectionCleared reports if the "collection" edge to the Collection entity was cleared.
func (m *UserMutation) CollectionCleared() bool {
	return m.clearedcollection
}

// RemoveCollectionIDs removes the "collection" edge to the Collection entity by IDs.
func (m *UserMutation) RemoveCollectionIDs(ids ...uint64) {
	if m.removedcollection == nil {
		m.removedcollection = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.collection, ids[i])
		m.removedcollection[ids[i]] = struct{}{}
	}
}

// RemovedCollection returns the removed IDs of the "collection" edge to the Collection entity.
func (m *UserMutation) RemovedCollectionIDs() (ids []uint64) {
	for id := range m.removedcollection {
		ids = append(ids, id)
	}
	return
}

// CollectionIDs returns the "collection" edge IDs in the mutation.
func (m *UserMutation) CollectionIDs() (ids []uint64) {
	for id := range m.collection {
		ids = append(ids, id)
	}
	return
}

// ResetCollection resets all changes to the "collection" edge.
func (m *UserMutation) ResetCollection() {
	m.collection = nil
	m.clearedcollection = false
	m.removedcollection = nil
}

// AddInviteCodeIDs adds the "invite_code" edge to the Invite_Code entity by ids.
func (m *UserMutation) AddInviteCodeIDs(ids ...int) {
	if m.invite_code == nil {
		m.invite_code = make(map[int]struct{})
	}
	for i := range ids {
		m.invite_code[ids[i]] = struct{}{}
	}
}

// ClearInviteCode clears the "invite_code" edge to the Invite_Code entity.
func (m *UserMutation) ClearInviteCode() {
	m.clearedinvite_code = true
}

// InviteCodeCleared reports if the "invite_code" edge to the Invite_Code entity was cleared.
func (m *UserMutation) InviteCodeCleared() bool {
	return m.clearedinvite_code
}

// RemoveInviteCodeIDs removes the "invite_code" edge to the Invite_Code entity by IDs.
func (m *UserMutation) RemoveInviteCodeIDs(ids ...int) {
	if m.removedinvite_code == nil {
		m.removedinvite_code = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.invite_code, ids[i])
		m.removedinvite_code[ids[i]] = struct{}{}
	}
}

// RemovedInviteCode returns the removed IDs of the "invite_code" edge to the Invite_Code entity.
func (m *UserMutation) RemovedInviteCodeIDs() (ids []int) {
	for id := range m.removedinvite_code {
		ids = append(ids, id)
	}
	return
}

// InviteCodeIDs returns the "invite_code" edge IDs in the mutation.
func (m *UserMutation) InviteCodeIDs() (ids []int) {
	for id := range m.invite_code {
		ids = append(ids, id)
	}
	return
}

// ResetInviteCode resets all changes to the "invite_code" edge.
func (m *UserMutation) ResetInviteCode() {
	m.invite_code = nil
	m.clearedinvite_code = false
	m.removedinvite_code = nil
}

// AddFeedbackIDs adds the "feedback" edge to the Feedback entity by ids.
func (m *UserMutation) AddFeedbackIDs(ids ...int) {
	if m.feedback == nil {
		m.feedback = make(map[int]struct{})
	}
	for i := range ids {
		m.feedback[ids[i]] = struct{}{}
	}
}

// ClearFeedback clears the "feedback" edge to the Feedback entity.
func (m *UserMutation) ClearFeedback() {
	m.clearedfeedback = true
}

// FeedbackCleared reports if the "feedback" edge to the Feedback entity was cleared.
func (m *UserMutation) FeedbackCleared() bool {
	return m.clearedfeedback
}

// RemoveFeedbackIDs removes the "feedback" edge to the Feedback entity by IDs.
func (m *UserMutation) RemoveFeedbackIDs(ids ...int) {
	if m.removedfeedback == nil {
		m.removedfeedback = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.feedback, ids[i])
		m.removedfeedback[ids[i]] = struct{}{}
	}
}

// RemovedFeedback returns the removed IDs of the "feedback" edge to the Feedback entity.
func (m *UserMutation) RemovedFeedbackIDs() (ids []int) {
	for id := range m.removedfeedback {
		ids = append(ids, id)
	}
	return
}

// FeedbackIDs returns the "feedback" edge IDs in the mutation.
func (m *UserMutation) FeedbackIDs() (ids []int) {
	for id := range m.feedback {
		ids = append(ids, id)
	}
	return
}

// ResetFeedback resets all changes to the "feedback" edge.
func (m *UserMutation) ResetFeedback() {
	m.feedback = nil
	m.clearedfeedback = false
	m.removedfeedback = nil
}

// AddReactionTimedewIDs adds the "reaction_timedew" edge to the TimeDew entity by ids.
func (m *UserMutation) AddReactionTimedewIDs(ids ...uint64) {
	if m.reaction_timedew == nil {
		m.reaction_timedew = make(map[uint64]struct{})
	}
	for i := range ids {
		m.reaction_timedew[ids[i]] = struct{}{}
	}
}

// ClearReactionTimedew clears the "reaction_timedew" edge to the TimeDew entity.
func (m *UserMutation) ClearReactionTimedew() {
	m.clearedreaction_timedew = true
}

// ReactionTimedewCleared reports if the "reaction_timedew" edge to the TimeDew entity was cleared.
func (m *UserMutation) ReactionTimedewCleared() bool {
	return m.clearedreaction_timedew
}

// RemoveReactionTimedewIDs removes the "reaction_timedew" edge to the TimeDew entity by IDs.
func (m *UserMutation) RemoveReactionTimedewIDs(ids ...uint64) {
	if m.removedreaction_timedew == nil {
		m.removedreaction_timedew = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.reaction_timedew, ids[i])
		m.removedreaction_timedew[ids[i]] = struct{}{}
	}
}

// RemovedReactionTimedew returns the removed IDs of the "reaction_timedew" edge to the TimeDew entity.
func (m *UserMutation) RemovedReactionTimedewIDs() (ids []uint64) {
	for id := range m.removedreaction_timedew {
		ids = append(ids, id)
	}
	return
}

// ReactionTimedewIDs returns the "reaction_timedew" edge IDs in the mutation.
func (m *UserMutation) ReactionTimedewIDs() (ids []uint64) {
	for id := range m.reaction_timedew {
		ids = append(ids, id)
	}
	return
}

// ResetReactionTimedew resets all changes to the "reaction_timedew" edge.
func (m *UserMutation) ResetReactionTimedew() {
	m.reaction_timedew = nil
	m.clearedreaction_timedew = false
	m.removedreaction_timedew = nil
}

// AddJoinIDs adds the "joins" edge to the Join entity by ids.
func (m *UserMutation) AddJoinIDs(ids ...int) {
	if m.joins == nil {
		m.joins = make(map[int]struct{})
	}
	for i := range ids {
		m.joins[ids[i]] = struct{}{}
	}
}

// ClearJoins clears the "joins" edge to the Join entity.
func (m *UserMutation) ClearJoins() {
	m.clearedjoins = true
}

// JoinsCleared reports if the "joins" edge to the Join entity was cleared.
func (m *UserMutation) JoinsCleared() bool {
	return m.clearedjoins
}

// RemoveJoinIDs removes the "joins" edge to the Join entity by IDs.
func (m *UserMutation) RemoveJoinIDs(ids ...int) {
	if m.removedjoins == nil {
		m.removedjoins = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.joins, ids[i])
		m.removedjoins[ids[i]] = struct{}{}
	}
}

// RemovedJoins returns the removed IDs of the "joins" edge to the Join entity.
func (m *UserMutation) RemovedJoinsIDs() (ids []int) {
	for id := range m.removedjoins {
		ids = append(ids, id)
	}
	return
}

// JoinsIDs returns the "joins" edge IDs in the mutation.
func (m *UserMutation) JoinsIDs() (ids []int) {
	for id := range m.joins {
		ids = append(ids, id)
	}
	return
}

// ResetJoins resets all changes to the "joins" edge.
func (m *UserMutation) ResetJoins() {
	m.joins = nil
	m.clearedjoins = false
	m.removedjoins = nil
}

// AddFriendshipIDs adds the "friendships" edge to the Friendship entity by ids.
func (m *UserMutation) AddFriendshipIDs(ids ...int) {
	if m.friendships == nil {
		m.friendships = make(map[int]struct{})
	}
	for i := range ids {
		m.friendships[ids[i]] = struct{}{}
	}
}

// ClearFriendships clears the "friendships" edge to the Friendship entity.
func (m *UserMutation) ClearFriendships() {
	m.clearedfriendships = true
}

// FriendshipsCleared reports if the "friendships" edge to the Friendship entity was cleared.
func (m *UserMutation) FriendshipsCleared() bool {
	return m.clearedfriendships
}

// RemoveFriendshipIDs removes the "friendships" edge to the Friendship entity by IDs.
func (m *UserMutation) RemoveFriendshipIDs(ids ...int) {
	if m.removedfriendships == nil {
		m.removedfriendships = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.friendships, ids[i])
		m.removedfriendships[ids[i]] = struct{}{}
	}
}

// RemovedFriendships returns the removed IDs of the "friendships" edge to the Friendship entity.
func (m *UserMutation) RemovedFriendshipsIDs() (ids []int) {
	for id := range m.removedfriendships {
		ids = append(ids, id)
	}
	return
}

// FriendshipsIDs returns the "friendships" edge IDs in the mutation.
func (m *UserMutation) FriendshipsIDs() (ids []int) {
	for id := range m.friendships {
		ids = append(ids, id)
	}
	return
}

// ResetFriendships resets all changes to the "friendships" edge.
func (m *UserMutation) ResetFriendships() {
	m.friendships = nil
	m.clearedfriendships = false
	m.removedfriendships = nil
}

// AddReactionIDs adds the "reactions" edge to the Reaction entity by ids.
func (m *UserMutation) AddReactionIDs(ids ...int) {
	if m.reactions == nil {
		m.reactions = make(map[int]struct{})
	}
	for i := range ids {
		m.reactions[ids[i]] = struct{}{}
	}
}

// ClearReactions clears the "reactions" edge to the Reaction entity.
func (m *UserMutation) ClearReactions() {
	m.clearedreactions = true
}

// ReactionsCleared reports if the "reactions" edge to the Reaction entity was cleared.
func (m *UserMutation) ReactionsCleared() bool {
	return m.clearedreactions
}

// RemoveReactionIDs removes the "reactions" edge to the Reaction entity by IDs.
func (m *UserMutation) RemoveReactionIDs(ids ...int) {
	if m.removedreactions == nil {
		m.removedreactions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.reactions, ids[i])
		m.removedreactions[ids[i]] = struct{}{}
	}
}

// RemovedReactions returns the removed IDs of the "reactions" edge to the Reaction entity.
func (m *UserMutation) RemovedReactionsIDs() (ids []int) {
	for id := range m.removedreactions {
		ids = append(ids, id)
	}
	return
}

// ReactionsIDs returns the "reactions" edge IDs in the mutation.
func (m *UserMutation) ReactionsIDs() (ids []int) {
	for id := range m.reactions {
		ids = append(ids, id)
	}
	return
}

// ResetReactions resets all changes to the "reactions" edge.
func (m *UserMutation) ResetReactions() {
	m.reactions = nil
	m.clearedreactions = false
	m.removedreactions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 28)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.open_id != nil {
		fields = append(fields, user.FieldOpenID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.nick_name != nil {
		fields = append(fields, user.FieldNickName)
	}
	if m.system_name != nil {
		fields = append(fields, user.FieldSystemName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.thumbnail_url != nil {
		fields = append(fields, user.FieldThumbnailURL)
	}
	if m.sex != nil {
		fields = append(fields, user.FieldSex)
	}
	if m.mobile_no != nil {
		fields = append(fields, user.FieldMobileNo)
	}
	if m.region_code != nil {
		fields = append(fields, user.FieldRegionCode)
	}
	if m.email_address != nil {
		fields = append(fields, user.FieldEmailAddress)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	if m.school_name != nil {
		fields = append(fields, user.FieldSchoolName)
	}
	if m.bio != nil {
		fields = append(fields, user.FieldBio)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.is_online != nil {
		fields = append(fields, user.FieldIsOnline)
	}
	if m.is_show_collections != nil {
		fields = append(fields, user.FieldIsShowCollections)
	}
	if m.is_invited != nil {
		fields = append(fields, user.FieldIsInvited)
	}
	if m.need_privacy_confirm != nil {
		fields = append(fields, user.FieldNeedPrivacyConfirm)
	}
	if m.current_cs_field_id != nil {
		fields = append(fields, user.FieldCurrentCsFieldID)
	}
	if m.current_cs_field_name != nil {
		fields = append(fields, user.FieldCurrentCsFieldName)
	}
	if m.private_cs_field_id != nil {
		fields = append(fields, user.FieldPrivateCsFieldID)
	}
	if m.private_cs_field_name != nil {
		fields = append(fields, user.FieldPrivateCsFieldName)
	}
	if m.register_ip != nil {
		fields = append(fields, user.FieldRegisterIP)
	}
	if m.constellation != nil {
		fields = append(fields, user.FieldConstellation)
	}
	if m.total_connections != nil {
		fields = append(fields, user.FieldTotalConnections)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldOpenID:
		return m.OpenID()
	case user.FieldName:
		return m.Name()
	case user.FieldNickName:
		return m.NickName()
	case user.FieldSystemName:
		return m.SystemName()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldThumbnailURL:
		return m.ThumbnailURL()
	case user.FieldSex:
		return m.Sex()
	case user.FieldMobileNo:
		return m.MobileNo()
	case user.FieldRegionCode:
		return m.RegionCode()
	case user.FieldEmailAddress:
		return m.EmailAddress()
	case user.FieldBirthday:
		return m.Birthday()
	case user.FieldSchoolName:
		return m.SchoolName()
	case user.FieldBio:
		return m.Bio()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRole:
		return m.Role()
	case user.FieldIsOnline:
		return m.IsOnline()
	case user.FieldIsShowCollections:
		return m.IsShowCollections()
	case user.FieldIsInvited:
		return m.IsInvited()
	case user.FieldNeedPrivacyConfirm:
		return m.NeedPrivacyConfirm()
	case user.FieldCurrentCsFieldID:
		return m.CurrentCsFieldID()
	case user.FieldCurrentCsFieldName:
		return m.CurrentCsFieldName()
	case user.FieldPrivateCsFieldID:
		return m.PrivateCsFieldID()
	case user.FieldPrivateCsFieldName:
		return m.PrivateCsFieldName()
	case user.FieldRegisterIP:
		return m.RegisterIP()
	case user.FieldConstellation:
		return m.Constellation()
	case user.FieldTotalConnections:
		return m.TotalConnections()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldOpenID:
		return m.OldOpenID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldNickName:
		return m.OldNickName(ctx)
	case user.FieldSystemName:
		return m.OldSystemName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldThumbnailURL:
		return m.OldThumbnailURL(ctx)
	case user.FieldSex:
		return m.OldSex(ctx)
	case user.FieldMobileNo:
		return m.OldMobileNo(ctx)
	case user.FieldRegionCode:
		return m.OldRegionCode(ctx)
	case user.FieldEmailAddress:
		return m.OldEmailAddress(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	case user.FieldSchoolName:
		return m.OldSchoolName(ctx)
	case user.FieldBio:
		return m.OldBio(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldIsOnline:
		return m.OldIsOnline(ctx)
	case user.FieldIsShowCollections:
		return m.OldIsShowCollections(ctx)
	case user.FieldIsInvited:
		return m.OldIsInvited(ctx)
	case user.FieldNeedPrivacyConfirm:
		return m.OldNeedPrivacyConfirm(ctx)
	case user.FieldCurrentCsFieldID:
		return m.OldCurrentCsFieldID(ctx)
	case user.FieldCurrentCsFieldName:
		return m.OldCurrentCsFieldName(ctx)
	case user.FieldPrivateCsFieldID:
		return m.OldPrivateCsFieldID(ctx)
	case user.FieldPrivateCsFieldName:
		return m.OldPrivateCsFieldName(ctx)
	case user.FieldRegisterIP:
		return m.OldRegisterIP(ctx)
	case user.FieldConstellation:
		return m.OldConstellation(ctx)
	case user.FieldTotalConnections:
		return m.OldTotalConnections(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldOpenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case user.FieldSystemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldThumbnailURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThumbnailURL(v)
		return nil
	case user.FieldSex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSex(v)
		return nil
	case user.FieldMobileNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNo(v)
		return nil
	case user.FieldRegionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case user.FieldEmailAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAddress(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case user.FieldSchoolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchoolName(v)
		return nil
	case user.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(user.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldIsOnline:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOnline(v)
		return nil
	case user.FieldIsShowCollections:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsShowCollections(v)
		return nil
	case user.FieldIsInvited:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInvited(v)
		return nil
	case user.FieldNeedPrivacyConfirm:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedPrivacyConfirm(v)
		return nil
	case user.FieldCurrentCsFieldID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentCsFieldID(v)
		return nil
	case user.FieldCurrentCsFieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentCsFieldName(v)
		return nil
	case user.FieldPrivateCsFieldID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateCsFieldID(v)
		return nil
	case user.FieldPrivateCsFieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateCsFieldName(v)
		return nil
	case user.FieldRegisterIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterIP(v)
		return nil
	case user.FieldConstellation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstellation(v)
		return nil
	case user.FieldTotalConnections:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalConnections(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcurrent_cs_field_id != nil {
		fields = append(fields, user.FieldCurrentCsFieldID)
	}
	if m.addprivate_cs_field_id != nil {
		fields = append(fields, user.FieldPrivateCsFieldID)
	}
	if m.addtotal_connections != nil {
		fields = append(fields, user.FieldTotalConnections)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCurrentCsFieldID:
		return m.AddedCurrentCsFieldID()
	case user.FieldPrivateCsFieldID:
		return m.AddedPrivateCsFieldID()
	case user.FieldTotalConnections:
		return m.AddedTotalConnections()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCurrentCsFieldID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentCsFieldID(v)
		return nil
	case user.FieldPrivateCsFieldID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrivateCsFieldID(v)
		return nil
	case user.FieldTotalConnections:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalConnections(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldOpenID) {
		fields = append(fields, user.FieldOpenID)
	}
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldNickName) {
		fields = append(fields, user.FieldNickName)
	}
	if m.FieldCleared(user.FieldSystemName) {
		fields = append(fields, user.FieldSystemName)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldSex) {
		fields = append(fields, user.FieldSex)
	}
	if m.FieldCleared(user.FieldMobileNo) {
		fields = append(fields, user.FieldMobileNo)
	}
	if m.FieldCleared(user.FieldRegionCode) {
		fields = append(fields, user.FieldRegionCode)
	}
	if m.FieldCleared(user.FieldEmailAddress) {
		fields = append(fields, user.FieldEmailAddress)
	}
	if m.FieldCleared(user.FieldBirthday) {
		fields = append(fields, user.FieldBirthday)
	}
	if m.FieldCleared(user.FieldSchoolName) {
		fields = append(fields, user.FieldSchoolName)
	}
	if m.FieldCleared(user.FieldBio) {
		fields = append(fields, user.FieldBio)
	}
	if m.FieldCleared(user.FieldIsOnline) {
		fields = append(fields, user.FieldIsOnline)
	}
	if m.FieldCleared(user.FieldCurrentCsFieldID) {
		fields = append(fields, user.FieldCurrentCsFieldID)
	}
	if m.FieldCleared(user.FieldCurrentCsFieldName) {
		fields = append(fields, user.FieldCurrentCsFieldName)
	}
	if m.FieldCleared(user.FieldPrivateCsFieldID) {
		fields = append(fields, user.FieldPrivateCsFieldID)
	}
	if m.FieldCleared(user.FieldPrivateCsFieldName) {
		fields = append(fields, user.FieldPrivateCsFieldName)
	}
	if m.FieldCleared(user.FieldRegisterIP) {
		fields = append(fields, user.FieldRegisterIP)
	}
	if m.FieldCleared(user.FieldConstellation) {
		fields = append(fields, user.FieldConstellation)
	}
	if m.FieldCleared(user.FieldTotalConnections) {
		fields = append(fields, user.FieldTotalConnections)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldOpenID:
		m.ClearOpenID()
		return nil
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldNickName:
		m.ClearNickName()
		return nil
	case user.FieldSystemName:
		m.ClearSystemName()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldSex:
		m.ClearSex()
		return nil
	case user.FieldMobileNo:
		m.ClearMobileNo()
		return nil
	case user.FieldRegionCode:
		m.ClearRegionCode()
		return nil
	case user.FieldEmailAddress:
		m.ClearEmailAddress()
		return nil
	case user.FieldBirthday:
		m.ClearBirthday()
		return nil
	case user.FieldSchoolName:
		m.ClearSchoolName()
		return nil
	case user.FieldBio:
		m.ClearBio()
		return nil
	case user.FieldIsOnline:
		m.ClearIsOnline()
		return nil
	case user.FieldCurrentCsFieldID:
		m.ClearCurrentCsFieldID()
		return nil
	case user.FieldCurrentCsFieldName:
		m.ClearCurrentCsFieldName()
		return nil
	case user.FieldPrivateCsFieldID:
		m.ClearPrivateCsFieldID()
		return nil
	case user.FieldPrivateCsFieldName:
		m.ClearPrivateCsFieldName()
		return nil
	case user.FieldRegisterIP:
		m.ClearRegisterIP()
		return nil
	case user.FieldConstellation:
		m.ClearConstellation()
		return nil
	case user.FieldTotalConnections:
		m.ClearTotalConnections()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldOpenID:
		m.ResetOpenID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldNickName:
		m.ResetNickName()
		return nil
	case user.FieldSystemName:
		m.ResetSystemName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldThumbnailURL:
		m.ResetThumbnailURL()
		return nil
	case user.FieldSex:
		m.ResetSex()
		return nil
	case user.FieldMobileNo:
		m.ResetMobileNo()
		return nil
	case user.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case user.FieldEmailAddress:
		m.ResetEmailAddress()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	case user.FieldSchoolName:
		m.ResetSchoolName()
		return nil
	case user.FieldBio:
		m.ResetBio()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldIsOnline:
		m.ResetIsOnline()
		return nil
	case user.FieldIsShowCollections:
		m.ResetIsShowCollections()
		return nil
	case user.FieldIsInvited:
		m.ResetIsInvited()
		return nil
	case user.FieldNeedPrivacyConfirm:
		m.ResetNeedPrivacyConfirm()
		return nil
	case user.FieldCurrentCsFieldID:
		m.ResetCurrentCsFieldID()
		return nil
	case user.FieldCurrentCsFieldName:
		m.ResetCurrentCsFieldName()
		return nil
	case user.FieldPrivateCsFieldID:
		m.ResetPrivateCsFieldID()
		return nil
	case user.FieldPrivateCsFieldName:
		m.ResetPrivateCsFieldName()
		return nil
	case user.FieldRegisterIP:
		m.ResetRegisterIP()
		return nil
	case user.FieldConstellation:
		m.ResetConstellation()
		return nil
	case user.FieldTotalConnections:
		m.ResetTotalConnections()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 23)
	if m.user_auth != nil {
		edges = append(edges, user.EdgeUserAuth)
	}
	if m.card != nil {
		edges = append(edges, user.EdgeCard)
	}
	if m.message != nil {
		edges = append(edges, user.EdgeMessage)
	}
	if m.device != nil {
		edges = append(edges, user.EdgeDevice)
	}
	if m.joined_csfield != nil {
		edges = append(edges, user.EdgeJoinedCsfield)
	}
	if m.friends != nil {
		edges = append(edges, user.EdgeFriends)
	}
	if m.hidden != nil {
		edges = append(edges, user.EdgeHidden)
	}
	if m.history != nil {
		edges = append(edges, user.EdgeHistory)
	}
	if m.token != nil {
		edges = append(edges, user.EdgeToken)
	}
	if m.creation != nil {
		edges = append(edges, user.EdgeCreation)
	}
	if m.contact != nil {
		edges = append(edges, user.EdgeContact)
	}
	if m.setting != nil {
		edges = append(edges, user.EdgeSetting)
	}
	if m.nft != nil {
		edges = append(edges, user.EdgeNft)
	}
	if m.stream != nil {
		edges = append(edges, user.EdgeStream)
	}
	if m.mask != nil {
		edges = append(edges, user.EdgeMask)
	}
	if m.timedew != nil {
		edges = append(edges, user.EdgeTimedew)
	}
	if m.collection != nil {
		edges = append(edges, user.EdgeCollection)
	}
	if m.invite_code != nil {
		edges = append(edges, user.EdgeInviteCode)
	}
	if m.feedback != nil {
		edges = append(edges, user.EdgeFeedback)
	}
	if m.reaction_timedew != nil {
		edges = append(edges, user.EdgeReactionTimedew)
	}
	if m.joins != nil {
		edges = append(edges, user.EdgeJoins)
	}
	if m.friendships != nil {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.reactions != nil {
		edges = append(edges, user.EdgeReactions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserAuth:
		ids := make([]ent.Value, 0, len(m.user_auth))
		for id := range m.user_auth {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCard:
		ids := make([]ent.Value, 0, len(m.card))
		for id := range m.card {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.message))
		for id := range m.message {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevice:
		ids := make([]ent.Value, 0, len(m.device))
		for id := range m.device {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJoinedCsfield:
		ids := make([]ent.Value, 0, len(m.joined_csfield))
		for id := range m.joined_csfield {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.friends))
		for id := range m.friends {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHidden:
		ids := make([]ent.Value, 0, len(m.hidden))
		for id := range m.hidden {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.history))
		for id := range m.history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeToken:
		ids := make([]ent.Value, 0, len(m.token))
		for id := range m.token {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreation:
		ids := make([]ent.Value, 0, len(m.creation))
		for id := range m.creation {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContact:
		ids := make([]ent.Value, 0, len(m.contact))
		for id := range m.contact {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSetting:
		ids := make([]ent.Value, 0, len(m.setting))
		for id := range m.setting {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNft:
		ids := make([]ent.Value, 0, len(m.nft))
		for id := range m.nft {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStream:
		ids := make([]ent.Value, 0, len(m.stream))
		for id := range m.stream {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMask:
		ids := make([]ent.Value, 0, len(m.mask))
		for id := range m.mask {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTimedew:
		ids := make([]ent.Value, 0, len(m.timedew))
		for id := range m.timedew {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollection:
		ids := make([]ent.Value, 0, len(m.collection))
		for id := range m.collection {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInviteCode:
		ids := make([]ent.Value, 0, len(m.invite_code))
		for id := range m.invite_code {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedback:
		ids := make([]ent.Value, 0, len(m.feedback))
		for id := range m.feedback {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReactionTimedew:
		ids := make([]ent.Value, 0, len(m.reaction_timedew))
		for id := range m.reaction_timedew {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJoins:
		ids := make([]ent.Value, 0, len(m.joins))
		for id := range m.joins {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.friendships))
		for id := range m.friendships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.reactions))
		for id := range m.reactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 23)
	if m.removeduser_auth != nil {
		edges = append(edges, user.EdgeUserAuth)
	}
	if m.removedcard != nil {
		edges = append(edges, user.EdgeCard)
	}
	if m.removedmessage != nil {
		edges = append(edges, user.EdgeMessage)
	}
	if m.removeddevice != nil {
		edges = append(edges, user.EdgeDevice)
	}
	if m.removedjoined_csfield != nil {
		edges = append(edges, user.EdgeJoinedCsfield)
	}
	if m.removedfriends != nil {
		edges = append(edges, user.EdgeFriends)
	}
	if m.removedhidden != nil {
		edges = append(edges, user.EdgeHidden)
	}
	if m.removedhistory != nil {
		edges = append(edges, user.EdgeHistory)
	}
	if m.removedtoken != nil {
		edges = append(edges, user.EdgeToken)
	}
	if m.removedcreation != nil {
		edges = append(edges, user.EdgeCreation)
	}
	if m.removedcontact != nil {
		edges = append(edges, user.EdgeContact)
	}
	if m.removedsetting != nil {
		edges = append(edges, user.EdgeSetting)
	}
	if m.removednft != nil {
		edges = append(edges, user.EdgeNft)
	}
	if m.removedstream != nil {
		edges = append(edges, user.EdgeStream)
	}
	if m.removedmask != nil {
		edges = append(edges, user.EdgeMask)
	}
	if m.removedtimedew != nil {
		edges = append(edges, user.EdgeTimedew)
	}
	if m.removedcollection != nil {
		edges = append(edges, user.EdgeCollection)
	}
	if m.removedinvite_code != nil {
		edges = append(edges, user.EdgeInviteCode)
	}
	if m.removedfeedback != nil {
		edges = append(edges, user.EdgeFeedback)
	}
	if m.removedreaction_timedew != nil {
		edges = append(edges, user.EdgeReactionTimedew)
	}
	if m.removedjoins != nil {
		edges = append(edges, user.EdgeJoins)
	}
	if m.removedfriendships != nil {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.removedreactions != nil {
		edges = append(edges, user.EdgeReactions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserAuth:
		ids := make([]ent.Value, 0, len(m.removeduser_auth))
		for id := range m.removeduser_auth {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCard:
		ids := make([]ent.Value, 0, len(m.removedcard))
		for id := range m.removedcard {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMessage:
		ids := make([]ent.Value, 0, len(m.removedmessage))
		for id := range m.removedmessage {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeDevice:
		ids := make([]ent.Value, 0, len(m.removeddevice))
		for id := range m.removeddevice {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJoinedCsfield:
		ids := make([]ent.Value, 0, len(m.removedjoined_csfield))
		for id := range m.removedjoined_csfield {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriends:
		ids := make([]ent.Value, 0, len(m.removedfriends))
		for id := range m.removedfriends {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHidden:
		ids := make([]ent.Value, 0, len(m.removedhidden))
		for id := range m.removedhidden {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeHistory:
		ids := make([]ent.Value, 0, len(m.removedhistory))
		for id := range m.removedhistory {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeToken:
		ids := make([]ent.Value, 0, len(m.removedtoken))
		for id := range m.removedtoken {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreation:
		ids := make([]ent.Value, 0, len(m.removedcreation))
		for id := range m.removedcreation {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContact:
		ids := make([]ent.Value, 0, len(m.removedcontact))
		for id := range m.removedcontact {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSetting:
		ids := make([]ent.Value, 0, len(m.removedsetting))
		for id := range m.removedsetting {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNft:
		ids := make([]ent.Value, 0, len(m.removednft))
		for id := range m.removednft {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStream:
		ids := make([]ent.Value, 0, len(m.removedstream))
		for id := range m.removedstream {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeMask:
		ids := make([]ent.Value, 0, len(m.removedmask))
		for id := range m.removedmask {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTimedew:
		ids := make([]ent.Value, 0, len(m.removedtimedew))
		for id := range m.removedtimedew {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCollection:
		ids := make([]ent.Value, 0, len(m.removedcollection))
		for id := range m.removedcollection {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInviteCode:
		ids := make([]ent.Value, 0, len(m.removedinvite_code))
		for id := range m.removedinvite_code {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFeedback:
		ids := make([]ent.Value, 0, len(m.removedfeedback))
		for id := range m.removedfeedback {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReactionTimedew:
		ids := make([]ent.Value, 0, len(m.removedreaction_timedew))
		for id := range m.removedreaction_timedew {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJoins:
		ids := make([]ent.Value, 0, len(m.removedjoins))
		for id := range m.removedjoins {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriendships:
		ids := make([]ent.Value, 0, len(m.removedfriendships))
		for id := range m.removedfriendships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReactions:
		ids := make([]ent.Value, 0, len(m.removedreactions))
		for id := range m.removedreactions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 23)
	if m.cleareduser_auth {
		edges = append(edges, user.EdgeUserAuth)
	}
	if m.clearedcard {
		edges = append(edges, user.EdgeCard)
	}
	if m.clearedmessage {
		edges = append(edges, user.EdgeMessage)
	}
	if m.cleareddevice {
		edges = append(edges, user.EdgeDevice)
	}
	if m.clearedjoined_csfield {
		edges = append(edges, user.EdgeJoinedCsfield)
	}
	if m.clearedfriends {
		edges = append(edges, user.EdgeFriends)
	}
	if m.clearedhidden {
		edges = append(edges, user.EdgeHidden)
	}
	if m.clearedhistory {
		edges = append(edges, user.EdgeHistory)
	}
	if m.clearedtoken {
		edges = append(edges, user.EdgeToken)
	}
	if m.clearedcreation {
		edges = append(edges, user.EdgeCreation)
	}
	if m.clearedcontact {
		edges = append(edges, user.EdgeContact)
	}
	if m.clearedsetting {
		edges = append(edges, user.EdgeSetting)
	}
	if m.clearednft {
		edges = append(edges, user.EdgeNft)
	}
	if m.clearedstream {
		edges = append(edges, user.EdgeStream)
	}
	if m.clearedmask {
		edges = append(edges, user.EdgeMask)
	}
	if m.clearedtimedew {
		edges = append(edges, user.EdgeTimedew)
	}
	if m.clearedcollection {
		edges = append(edges, user.EdgeCollection)
	}
	if m.clearedinvite_code {
		edges = append(edges, user.EdgeInviteCode)
	}
	if m.clearedfeedback {
		edges = append(edges, user.EdgeFeedback)
	}
	if m.clearedreaction_timedew {
		edges = append(edges, user.EdgeReactionTimedew)
	}
	if m.clearedjoins {
		edges = append(edges, user.EdgeJoins)
	}
	if m.clearedfriendships {
		edges = append(edges, user.EdgeFriendships)
	}
	if m.clearedreactions {
		edges = append(edges, user.EdgeReactions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserAuth:
		return m.cleareduser_auth
	case user.EdgeCard:
		return m.clearedcard
	case user.EdgeMessage:
		return m.clearedmessage
	case user.EdgeDevice:
		return m.cleareddevice
	case user.EdgeJoinedCsfield:
		return m.clearedjoined_csfield
	case user.EdgeFriends:
		return m.clearedfriends
	case user.EdgeHidden:
		return m.clearedhidden
	case user.EdgeHistory:
		return m.clearedhistory
	case user.EdgeToken:
		return m.clearedtoken
	case user.EdgeCreation:
		return m.clearedcreation
	case user.EdgeContact:
		return m.clearedcontact
	case user.EdgeSetting:
		return m.clearedsetting
	case user.EdgeNft:
		return m.clearednft
	case user.EdgeStream:
		return m.clearedstream
	case user.EdgeMask:
		return m.clearedmask
	case user.EdgeTimedew:
		return m.clearedtimedew
	case user.EdgeCollection:
		return m.clearedcollection
	case user.EdgeInviteCode:
		return m.clearedinvite_code
	case user.EdgeFeedback:
		return m.clearedfeedback
	case user.EdgeReactionTimedew:
		return m.clearedreaction_timedew
	case user.EdgeJoins:
		return m.clearedjoins
	case user.EdgeFriendships:
		return m.clearedfriendships
	case user.EdgeReactions:
		return m.clearedreactions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserAuth:
		m.ResetUserAuth()
		return nil
	case user.EdgeCard:
		m.ResetCard()
		return nil
	case user.EdgeMessage:
		m.ResetMessage()
		return nil
	case user.EdgeDevice:
		m.ResetDevice()
		return nil
	case user.EdgeJoinedCsfield:
		m.ResetJoinedCsfield()
		return nil
	case user.EdgeFriends:
		m.ResetFriends()
		return nil
	case user.EdgeHidden:
		m.ResetHidden()
		return nil
	case user.EdgeHistory:
		m.ResetHistory()
		return nil
	case user.EdgeToken:
		m.ResetToken()
		return nil
	case user.EdgeCreation:
		m.ResetCreation()
		return nil
	case user.EdgeContact:
		m.ResetContact()
		return nil
	case user.EdgeSetting:
		m.ResetSetting()
		return nil
	case user.EdgeNft:
		m.ResetNft()
		return nil
	case user.EdgeStream:
		m.ResetStream()
		return nil
	case user.EdgeMask:
		m.ResetMask()
		return nil
	case user.EdgeTimedew:
		m.ResetTimedew()
		return nil
	case user.EdgeCollection:
		m.ResetCollection()
		return nil
	case user.EdgeInviteCode:
		m.ResetInviteCode()
		return nil
	case user.EdgeFeedback:
		m.ResetFeedback()
		return nil
	case user.EdgeReactionTimedew:
		m.ResetReactionTimedew()
		return nil
	case user.EdgeJoins:
		m.ResetJoins()
		return nil
	case user.EdgeFriendships:
		m.ResetFriendships()
		return nil
	case user.EdgeReactions:
		m.ResetReactions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAuthMutation represents an operation that mutates the User_auth nodes in the graph.
type UserAuthMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	create_time         *time.Time
	update_time         *time.Time
	_type               *user_auth.Type
	oauth_source        *string
	email               *string
	mobile_no           *string
	password            *string
	access_token        *string
	oauth_token_type    *string
	oauth_refresh_token *string
	oauth_id            *string
	is_finished         *bool
	oauth_expiry        *time.Time
	clearedFields       map[string]struct{}
	owner               *uint64
	clearedowner        bool
	done                bool
	oldValue            func(context.Context) (*User_auth, error)
	predicates          []predicate.User_auth
}

var _ ent.Mutation = (*UserAuthMutation)(nil)

// userAuthOption allows management of the mutation configuration using functional options.
type userAuthOption func(*UserAuthMutation)

// newUserAuthMutation creates new mutation for the User_auth entity.
func newUserAuthMutation(c config, op Op, opts ...userAuthOption) *UserAuthMutation {
	m := &UserAuthMutation{
		config:        c,
		op:            op,
		typ:           TypeUser_auth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUser_authID sets the ID field of the mutation.
func withUser_authID(id int) userAuthOption {
	return func(m *UserAuthMutation) {
		var (
			err   error
			once  sync.Once
			value *User_auth
		)
		m.oldValue = func(ctx context.Context) (*User_auth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User_auth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser_auth sets the old User_auth of the mutation.
func withUser_auth(node *User_auth) userAuthOption {
	return func(m *UserAuthMutation) {
		m.oldValue = func(context.Context) (*User_auth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAuthMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAuthMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User_auth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserAuthMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserAuthMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserAuthMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserAuthMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserAuthMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserAuthMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *UserAuthMutation) SetType(ua user_auth.Type) {
	m._type = &ua
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserAuthMutation) GetType() (r user_auth.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldType(ctx context.Context) (v user_auth.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserAuthMutation) ResetType() {
	m._type = nil
}

// SetOauthSource sets the "oauth_source" field.
func (m *UserAuthMutation) SetOauthSource(s string) {
	m.oauth_source = &s
}

// OauthSource returns the value of the "oauth_source" field in the mutation.
func (m *UserAuthMutation) OauthSource() (r string, exists bool) {
	v := m.oauth_source
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthSource returns the old "oauth_source" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldOauthSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthSource: %w", err)
	}
	return oldValue.OauthSource, nil
}

// ClearOauthSource clears the value of the "oauth_source" field.
func (m *UserAuthMutation) ClearOauthSource() {
	m.oauth_source = nil
	m.clearedFields[user_auth.FieldOauthSource] = struct{}{}
}

// OauthSourceCleared returns if the "oauth_source" field was cleared in this mutation.
func (m *UserAuthMutation) OauthSourceCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldOauthSource]
	return ok
}

// ResetOauthSource resets all changes to the "oauth_source" field.
func (m *UserAuthMutation) ResetOauthSource() {
	m.oauth_source = nil
	delete(m.clearedFields, user_auth.FieldOauthSource)
}

// SetEmail sets the "email" field.
func (m *UserAuthMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserAuthMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserAuthMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user_auth.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserAuthMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserAuthMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user_auth.FieldEmail)
}

// SetMobileNo sets the "mobile_no" field.
func (m *UserAuthMutation) SetMobileNo(s string) {
	m.mobile_no = &s
}

// MobileNo returns the value of the "mobile_no" field in the mutation.
func (m *UserAuthMutation) MobileNo() (r string, exists bool) {
	v := m.mobile_no
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNo returns the old "mobile_no" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldMobileNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNo: %w", err)
	}
	return oldValue.MobileNo, nil
}

// ClearMobileNo clears the value of the "mobile_no" field.
func (m *UserAuthMutation) ClearMobileNo() {
	m.mobile_no = nil
	m.clearedFields[user_auth.FieldMobileNo] = struct{}{}
}

// MobileNoCleared returns if the "mobile_no" field was cleared in this mutation.
func (m *UserAuthMutation) MobileNoCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldMobileNo]
	return ok
}

// ResetMobileNo resets all changes to the "mobile_no" field.
func (m *UserAuthMutation) ResetMobileNo() {
	m.mobile_no = nil
	delete(m.clearedFields, user_auth.FieldMobileNo)
}

// SetPassword sets the "password" field.
func (m *UserAuthMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserAuthMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserAuthMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user_auth.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserAuthMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserAuthMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user_auth.FieldPassword)
}

// SetAccessToken sets the "access_token" field.
func (m *UserAuthMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *UserAuthMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *UserAuthMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[user_auth.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *UserAuthMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *UserAuthMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, user_auth.FieldAccessToken)
}

// SetOauthTokenType sets the "oauth_token_type" field.
func (m *UserAuthMutation) SetOauthTokenType(s string) {
	m.oauth_token_type = &s
}

// OauthTokenType returns the value of the "oauth_token_type" field in the mutation.
func (m *UserAuthMutation) OauthTokenType() (r string, exists bool) {
	v := m.oauth_token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthTokenType returns the old "oauth_token_type" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldOauthTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthTokenType: %w", err)
	}
	return oldValue.OauthTokenType, nil
}

// ClearOauthTokenType clears the value of the "oauth_token_type" field.
func (m *UserAuthMutation) ClearOauthTokenType() {
	m.oauth_token_type = nil
	m.clearedFields[user_auth.FieldOauthTokenType] = struct{}{}
}

// OauthTokenTypeCleared returns if the "oauth_token_type" field was cleared in this mutation.
func (m *UserAuthMutation) OauthTokenTypeCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldOauthTokenType]
	return ok
}

// ResetOauthTokenType resets all changes to the "oauth_token_type" field.
func (m *UserAuthMutation) ResetOauthTokenType() {
	m.oauth_token_type = nil
	delete(m.clearedFields, user_auth.FieldOauthTokenType)
}

// SetOauthRefreshToken sets the "oauth_refresh_token" field.
func (m *UserAuthMutation) SetOauthRefreshToken(s string) {
	m.oauth_refresh_token = &s
}

// OauthRefreshToken returns the value of the "oauth_refresh_token" field in the mutation.
func (m *UserAuthMutation) OauthRefreshToken() (r string, exists bool) {
	v := m.oauth_refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthRefreshToken returns the old "oauth_refresh_token" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldOauthRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthRefreshToken: %w", err)
	}
	return oldValue.OauthRefreshToken, nil
}

// ClearOauthRefreshToken clears the value of the "oauth_refresh_token" field.
func (m *UserAuthMutation) ClearOauthRefreshToken() {
	m.oauth_refresh_token = nil
	m.clearedFields[user_auth.FieldOauthRefreshToken] = struct{}{}
}

// OauthRefreshTokenCleared returns if the "oauth_refresh_token" field was cleared in this mutation.
func (m *UserAuthMutation) OauthRefreshTokenCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldOauthRefreshToken]
	return ok
}

// ResetOauthRefreshToken resets all changes to the "oauth_refresh_token" field.
func (m *UserAuthMutation) ResetOauthRefreshToken() {
	m.oauth_refresh_token = nil
	delete(m.clearedFields, user_auth.FieldOauthRefreshToken)
}

// SetOauthID sets the "oauth_id" field.
func (m *UserAuthMutation) SetOauthID(s string) {
	m.oauth_id = &s
}

// OauthID returns the value of the "oauth_id" field in the mutation.
func (m *UserAuthMutation) OauthID() (r string, exists bool) {
	v := m.oauth_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthID returns the old "oauth_id" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldOauthID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthID: %w", err)
	}
	return oldValue.OauthID, nil
}

// ClearOauthID clears the value of the "oauth_id" field.
func (m *UserAuthMutation) ClearOauthID() {
	m.oauth_id = nil
	m.clearedFields[user_auth.FieldOauthID] = struct{}{}
}

// OauthIDCleared returns if the "oauth_id" field was cleared in this mutation.
func (m *UserAuthMutation) OauthIDCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldOauthID]
	return ok
}

// ResetOauthID resets all changes to the "oauth_id" field.
func (m *UserAuthMutation) ResetOauthID() {
	m.oauth_id = nil
	delete(m.clearedFields, user_auth.FieldOauthID)
}

// SetIsFinished sets the "is_finished" field.
func (m *UserAuthMutation) SetIsFinished(b bool) {
	m.is_finished = &b
}

// IsFinished returns the value of the "is_finished" field in the mutation.
func (m *UserAuthMutation) IsFinished() (r bool, exists bool) {
	v := m.is_finished
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFinished returns the old "is_finished" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldIsFinished(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFinished is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFinished requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFinished: %w", err)
	}
	return oldValue.IsFinished, nil
}

// ClearIsFinished clears the value of the "is_finished" field.
func (m *UserAuthMutation) ClearIsFinished() {
	m.is_finished = nil
	m.clearedFields[user_auth.FieldIsFinished] = struct{}{}
}

// IsFinishedCleared returns if the "is_finished" field was cleared in this mutation.
func (m *UserAuthMutation) IsFinishedCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldIsFinished]
	return ok
}

// ResetIsFinished resets all changes to the "is_finished" field.
func (m *UserAuthMutation) ResetIsFinished() {
	m.is_finished = nil
	delete(m.clearedFields, user_auth.FieldIsFinished)
}

// SetOauthExpiry sets the "oauth_expiry" field.
func (m *UserAuthMutation) SetOauthExpiry(t time.Time) {
	m.oauth_expiry = &t
}

// OauthExpiry returns the value of the "oauth_expiry" field in the mutation.
func (m *UserAuthMutation) OauthExpiry() (r time.Time, exists bool) {
	v := m.oauth_expiry
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthExpiry returns the old "oauth_expiry" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldOauthExpiry(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthExpiry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthExpiry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthExpiry: %w", err)
	}
	return oldValue.OauthExpiry, nil
}

// ClearOauthExpiry clears the value of the "oauth_expiry" field.
func (m *UserAuthMutation) ClearOauthExpiry() {
	m.oauth_expiry = nil
	m.clearedFields[user_auth.FieldOauthExpiry] = struct{}{}
}

// OauthExpiryCleared returns if the "oauth_expiry" field was cleared in this mutation.
func (m *UserAuthMutation) OauthExpiryCleared() bool {
	_, ok := m.clearedFields[user_auth.FieldOauthExpiry]
	return ok
}

// ResetOauthExpiry resets all changes to the "oauth_expiry" field.
func (m *UserAuthMutation) ResetOauthExpiry() {
	m.oauth_expiry = nil
	delete(m.clearedFields, user_auth.FieldOauthExpiry)
}

// SetUserID sets the "user_id" field.
func (m *UserAuthMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAuthMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the User_auth entity.
// If the User_auth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAuthMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *UserAuthMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *UserAuthMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *UserAuthMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UserAuthMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UserAuthMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UserAuthMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UserAuthMutation builder.
func (m *UserAuthMutation) Where(ps ...predicate.User_auth) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserAuthMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User_auth).
func (m *UserAuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAuthMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, user_auth.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user_auth.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, user_auth.FieldType)
	}
	if m.oauth_source != nil {
		fields = append(fields, user_auth.FieldOauthSource)
	}
	if m.email != nil {
		fields = append(fields, user_auth.FieldEmail)
	}
	if m.mobile_no != nil {
		fields = append(fields, user_auth.FieldMobileNo)
	}
	if m.password != nil {
		fields = append(fields, user_auth.FieldPassword)
	}
	if m.access_token != nil {
		fields = append(fields, user_auth.FieldAccessToken)
	}
	if m.oauth_token_type != nil {
		fields = append(fields, user_auth.FieldOauthTokenType)
	}
	if m.oauth_refresh_token != nil {
		fields = append(fields, user_auth.FieldOauthRefreshToken)
	}
	if m.oauth_id != nil {
		fields = append(fields, user_auth.FieldOauthID)
	}
	if m.is_finished != nil {
		fields = append(fields, user_auth.FieldIsFinished)
	}
	if m.oauth_expiry != nil {
		fields = append(fields, user_auth.FieldOauthExpiry)
	}
	if m.owner != nil {
		fields = append(fields, user_auth.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user_auth.FieldCreateTime:
		return m.CreateTime()
	case user_auth.FieldUpdateTime:
		return m.UpdateTime()
	case user_auth.FieldType:
		return m.GetType()
	case user_auth.FieldOauthSource:
		return m.OauthSource()
	case user_auth.FieldEmail:
		return m.Email()
	case user_auth.FieldMobileNo:
		return m.MobileNo()
	case user_auth.FieldPassword:
		return m.Password()
	case user_auth.FieldAccessToken:
		return m.AccessToken()
	case user_auth.FieldOauthTokenType:
		return m.OauthTokenType()
	case user_auth.FieldOauthRefreshToken:
		return m.OauthRefreshToken()
	case user_auth.FieldOauthID:
		return m.OauthID()
	case user_auth.FieldIsFinished:
		return m.IsFinished()
	case user_auth.FieldOauthExpiry:
		return m.OauthExpiry()
	case user_auth.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user_auth.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user_auth.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user_auth.FieldType:
		return m.OldType(ctx)
	case user_auth.FieldOauthSource:
		return m.OldOauthSource(ctx)
	case user_auth.FieldEmail:
		return m.OldEmail(ctx)
	case user_auth.FieldMobileNo:
		return m.OldMobileNo(ctx)
	case user_auth.FieldPassword:
		return m.OldPassword(ctx)
	case user_auth.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case user_auth.FieldOauthTokenType:
		return m.OldOauthTokenType(ctx)
	case user_auth.FieldOauthRefreshToken:
		return m.OldOauthRefreshToken(ctx)
	case user_auth.FieldOauthID:
		return m.OldOauthID(ctx)
	case user_auth.FieldIsFinished:
		return m.OldIsFinished(ctx)
	case user_auth.FieldOauthExpiry:
		return m.OldOauthExpiry(ctx)
	case user_auth.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown User_auth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user_auth.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user_auth.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user_auth.FieldType:
		v, ok := value.(user_auth.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user_auth.FieldOauthSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthSource(v)
		return nil
	case user_auth.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user_auth.FieldMobileNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNo(v)
		return nil
	case user_auth.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user_auth.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case user_auth.FieldOauthTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthTokenType(v)
		return nil
	case user_auth.FieldOauthRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthRefreshToken(v)
		return nil
	case user_auth.FieldOauthID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthID(v)
		return nil
	case user_auth.FieldIsFinished:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFinished(v)
		return nil
	case user_auth.FieldOauthExpiry:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthExpiry(v)
		return nil
	case user_auth.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown User_auth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAuthMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User_auth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAuthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user_auth.FieldOauthSource) {
		fields = append(fields, user_auth.FieldOauthSource)
	}
	if m.FieldCleared(user_auth.FieldEmail) {
		fields = append(fields, user_auth.FieldEmail)
	}
	if m.FieldCleared(user_auth.FieldMobileNo) {
		fields = append(fields, user_auth.FieldMobileNo)
	}
	if m.FieldCleared(user_auth.FieldPassword) {
		fields = append(fields, user_auth.FieldPassword)
	}
	if m.FieldCleared(user_auth.FieldAccessToken) {
		fields = append(fields, user_auth.FieldAccessToken)
	}
	if m.FieldCleared(user_auth.FieldOauthTokenType) {
		fields = append(fields, user_auth.FieldOauthTokenType)
	}
	if m.FieldCleared(user_auth.FieldOauthRefreshToken) {
		fields = append(fields, user_auth.FieldOauthRefreshToken)
	}
	if m.FieldCleared(user_auth.FieldOauthID) {
		fields = append(fields, user_auth.FieldOauthID)
	}
	if m.FieldCleared(user_auth.FieldIsFinished) {
		fields = append(fields, user_auth.FieldIsFinished)
	}
	if m.FieldCleared(user_auth.FieldOauthExpiry) {
		fields = append(fields, user_auth.FieldOauthExpiry)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAuthMutation) ClearField(name string) error {
	switch name {
	case user_auth.FieldOauthSource:
		m.ClearOauthSource()
		return nil
	case user_auth.FieldEmail:
		m.ClearEmail()
		return nil
	case user_auth.FieldMobileNo:
		m.ClearMobileNo()
		return nil
	case user_auth.FieldPassword:
		m.ClearPassword()
		return nil
	case user_auth.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	case user_auth.FieldOauthTokenType:
		m.ClearOauthTokenType()
		return nil
	case user_auth.FieldOauthRefreshToken:
		m.ClearOauthRefreshToken()
		return nil
	case user_auth.FieldOauthID:
		m.ClearOauthID()
		return nil
	case user_auth.FieldIsFinished:
		m.ClearIsFinished()
		return nil
	case user_auth.FieldOauthExpiry:
		m.ClearOauthExpiry()
		return nil
	}
	return fmt.Errorf("unknown User_auth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAuthMutation) ResetField(name string) error {
	switch name {
	case user_auth.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user_auth.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user_auth.FieldType:
		m.ResetType()
		return nil
	case user_auth.FieldOauthSource:
		m.ResetOauthSource()
		return nil
	case user_auth.FieldEmail:
		m.ResetEmail()
		return nil
	case user_auth.FieldMobileNo:
		m.ResetMobileNo()
		return nil
	case user_auth.FieldPassword:
		m.ResetPassword()
		return nil
	case user_auth.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case user_auth.FieldOauthTokenType:
		m.ResetOauthTokenType()
		return nil
	case user_auth.FieldOauthRefreshToken:
		m.ResetOauthRefreshToken()
		return nil
	case user_auth.FieldOauthID:
		m.ResetOauthID()
		return nil
	case user_auth.FieldIsFinished:
		m.ResetIsFinished()
		return nil
	case user_auth.FieldOauthExpiry:
		m.ResetOauthExpiry()
		return nil
	case user_auth.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown User_auth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, user_auth.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user_auth.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, user_auth.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAuthMutation) EdgeCleared(name string) bool {
	switch name {
	case user_auth.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAuthMutation) ClearEdge(name string) error {
	switch name {
	case user_auth.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown User_auth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAuthMutation) ResetEdge(name string) error {
	switch name {
	case user_auth.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown User_auth edge %s", name)
}

// UserHistoryMutation represents an operation that mutates the User_history nodes in the graph.
type UserHistoryMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	create_time   *time.Time
	update_time   *time.Time
	_type         *user_history.Type
	name          *string
	resource_url  *string
	clearedFields map[string]struct{}
	owner         *uint64
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*User_history, error)
	predicates    []predicate.User_history
}

var _ ent.Mutation = (*UserHistoryMutation)(nil)

// userHistoryOption allows management of the mutation configuration using functional options.
type userHistoryOption func(*UserHistoryMutation)

// newUserHistoryMutation creates new mutation for the User_history entity.
func newUserHistoryMutation(c config, op Op, opts ...userHistoryOption) *UserHistoryMutation {
	m := &UserHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUser_history,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUser_historyID sets the ID field of the mutation.
func withUser_historyID(id uint64) userHistoryOption {
	return func(m *UserHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *User_history
		)
		m.oldValue = func(ctx context.Context) (*User_history, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User_history.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser_history sets the old User_history of the mutation.
func withUser_history(node *User_history) userHistoryOption {
	return func(m *UserHistoryMutation) {
		m.oldValue = func(context.Context) (*User_history, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User_history entities.
func (m *UserHistoryMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserHistoryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserHistoryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User_history.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserHistoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserHistoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User_history entity.
// If the User_history object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserHistoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserHistoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserHistoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User_history entity.
// If the User_history object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserHistoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *UserHistoryMutation) SetType(uh user_history.Type) {
	m._type = &uh
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserHistoryMutation) GetType() (r user_history.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the User_history entity.
// If the User_history object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldType(ctx context.Context) (v user_history.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserHistoryMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *UserHistoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserHistoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User_history entity.
// If the User_history object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserHistoryMutation) ResetName() {
	m.name = nil
}

// SetResourceURL sets the "resource_url" field.
func (m *UserHistoryMutation) SetResourceURL(s string) {
	m.resource_url = &s
}

// ResourceURL returns the value of the "resource_url" field in the mutation.
func (m *UserHistoryMutation) ResourceURL() (r string, exists bool) {
	v := m.resource_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResourceURL returns the old "resource_url" field's value of the User_history entity.
// If the User_history object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldResourceURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourceURL: %w", err)
	}
	return oldValue.ResourceURL, nil
}

// ClearResourceURL clears the value of the "resource_url" field.
func (m *UserHistoryMutation) ClearResourceURL() {
	m.resource_url = nil
	m.clearedFields[user_history.FieldResourceURL] = struct{}{}
}

// ResourceURLCleared returns if the "resource_url" field was cleared in this mutation.
func (m *UserHistoryMutation) ResourceURLCleared() bool {
	_, ok := m.clearedFields[user_history.FieldResourceURL]
	return ok
}

// ResetResourceURL resets all changes to the "resource_url" field.
func (m *UserHistoryMutation) ResetResourceURL() {
	m.resource_url = nil
	delete(m.clearedFields, user_history.FieldResourceURL)
}

// SetUserID sets the "user_id" field.
func (m *UserHistoryMutation) SetUserID(u uint64) {
	m.owner = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserHistoryMutation) UserID() (r uint64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the User_history entity.
// If the User_history object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserHistoryMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserHistoryMutation) ResetUserID() {
	m.owner = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *UserHistoryMutation) SetOwnerID(id uint64) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *UserHistoryMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *UserHistoryMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *UserHistoryMutation) OwnerID() (id uint64, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *UserHistoryMutation) OwnerIDs() (ids []uint64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *UserHistoryMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the UserHistoryMutation builder.
func (m *UserHistoryMutation) Where(ps ...predicate.User_history) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserHistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User_history).
func (m *UserHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserHistoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, user_history.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user_history.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, user_history.FieldType)
	}
	if m.name != nil {
		fields = append(fields, user_history.FieldName)
	}
	if m.resource_url != nil {
		fields = append(fields, user_history.FieldResourceURL)
	}
	if m.owner != nil {
		fields = append(fields, user_history.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user_history.FieldCreateTime:
		return m.CreateTime()
	case user_history.FieldUpdateTime:
		return m.UpdateTime()
	case user_history.FieldType:
		return m.GetType()
	case user_history.FieldName:
		return m.Name()
	case user_history.FieldResourceURL:
		return m.ResourceURL()
	case user_history.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user_history.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user_history.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user_history.FieldType:
		return m.OldType(ctx)
	case user_history.FieldName:
		return m.OldName(ctx)
	case user_history.FieldResourceURL:
		return m.OldResourceURL(ctx)
	case user_history.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown User_history field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user_history.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user_history.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user_history.FieldType:
		v, ok := value.(user_history.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case user_history.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user_history.FieldResourceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourceURL(v)
		return nil
	case user_history.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown User_history field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserHistoryMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserHistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User_history numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user_history.FieldResourceURL) {
		fields = append(fields, user_history.FieldResourceURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserHistoryMutation) ClearField(name string) error {
	switch name {
	case user_history.FieldResourceURL:
		m.ClearResourceURL()
		return nil
	}
	return fmt.Errorf("unknown User_history nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserHistoryMutation) ResetField(name string) error {
	switch name {
	case user_history.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user_history.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user_history.FieldType:
		m.ResetType()
		return nil
	case user_history.FieldName:
		m.ResetName()
		return nil
	case user_history.FieldResourceURL:
		m.ResetResourceURL()
		return nil
	case user_history.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown User_history field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, user_history.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user_history.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, user_history.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case user_history.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserHistoryMutation) ClearEdge(name string) error {
	switch name {
	case user_history.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown User_history unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserHistoryMutation) ResetEdge(name string) error {
	switch name {
	case user_history.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown User_history edge %s", name)
}
