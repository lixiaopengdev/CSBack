// Code generated by ent, DO NOT EDIT.

package ent

import (
	"CSBackendTmp/ent/nft"
	"CSBackendTmp/ent/user"
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// NFTCreate is the builder for creating a NFT entity.
type NFTCreate struct {
	config
	mutation *NFTMutation
	hooks    []Hook
	conflict []sql.ConflictOption
}

// SetCreateTime sets the "create_time" field.
func (nc *NFTCreate) SetCreateTime(t time.Time) *NFTCreate {
	nc.mutation.SetCreateTime(t)
	return nc
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (nc *NFTCreate) SetNillableCreateTime(t *time.Time) *NFTCreate {
	if t != nil {
		nc.SetCreateTime(*t)
	}
	return nc
}

// SetUpdateTime sets the "update_time" field.
func (nc *NFTCreate) SetUpdateTime(t time.Time) *NFTCreate {
	nc.mutation.SetUpdateTime(t)
	return nc
}

// SetNillableUpdateTime sets the "update_time" field if the given value is not nil.
func (nc *NFTCreate) SetNillableUpdateTime(t *time.Time) *NFTCreate {
	if t != nil {
		nc.SetUpdateTime(*t)
	}
	return nc
}

// SetName sets the "name" field.
func (nc *NFTCreate) SetName(s string) *NFTCreate {
	nc.mutation.SetName(s)
	return nc
}

// SetNillableName sets the "name" field if the given value is not nil.
func (nc *NFTCreate) SetNillableName(s *string) *NFTCreate {
	if s != nil {
		nc.SetName(*s)
	}
	return nc
}

// SetDesc sets the "desc" field.
func (nc *NFTCreate) SetDesc(s string) *NFTCreate {
	nc.mutation.SetDesc(s)
	return nc
}

// SetNillableDesc sets the "desc" field if the given value is not nil.
func (nc *NFTCreate) SetNillableDesc(s *string) *NFTCreate {
	if s != nil {
		nc.SetDesc(*s)
	}
	return nc
}

// SetUserID sets the "user_id" field.
func (nc *NFTCreate) SetUserID(u uint64) *NFTCreate {
	nc.mutation.SetUserID(u)
	return nc
}

// SetNillableUserID sets the "user_id" field if the given value is not nil.
func (nc *NFTCreate) SetNillableUserID(u *uint64) *NFTCreate {
	if u != nil {
		nc.SetUserID(*u)
	}
	return nc
}

// SetCreatorID sets the "creator_id" field.
func (nc *NFTCreate) SetCreatorID(u uint64) *NFTCreate {
	nc.mutation.SetCreatorID(u)
	return nc
}

// SetNillableCreatorID sets the "creator_id" field if the given value is not nil.
func (nc *NFTCreate) SetNillableCreatorID(u *uint64) *NFTCreate {
	if u != nil {
		nc.SetCreatorID(*u)
	}
	return nc
}

// SetMediaInfoJSON sets the "media_info_json" field.
func (nc *NFTCreate) SetMediaInfoJSON(s []string) *NFTCreate {
	nc.mutation.SetMediaInfoJSON(s)
	return nc
}

// SetMediaURL sets the "media_url" field.
func (nc *NFTCreate) SetMediaURL(s string) *NFTCreate {
	nc.mutation.SetMediaURL(s)
	return nc
}

// SetNillableMediaURL sets the "media_url" field if the given value is not nil.
func (nc *NFTCreate) SetNillableMediaURL(s *string) *NFTCreate {
	if s != nil {
		nc.SetMediaURL(*s)
	}
	return nc
}

// SetMediaDurl sets the "media_durl" field.
func (nc *NFTCreate) SetMediaDurl(s string) *NFTCreate {
	nc.mutation.SetMediaDurl(s)
	return nc
}

// SetNillableMediaDurl sets the "media_durl" field if the given value is not nil.
func (nc *NFTCreate) SetNillableMediaDurl(s *string) *NFTCreate {
	if s != nil {
		nc.SetMediaDurl(*s)
	}
	return nc
}

// SetTokenID sets the "token_id" field.
func (nc *NFTCreate) SetTokenID(s string) *NFTCreate {
	nc.mutation.SetTokenID(s)
	return nc
}

// SetNillableTokenID sets the "token_id" field if the given value is not nil.
func (nc *NFTCreate) SetNillableTokenID(s *string) *NFTCreate {
	if s != nil {
		nc.SetTokenID(*s)
	}
	return nc
}

// SetStatus sets the "status" field.
func (nc *NFTCreate) SetStatus(n nft.Status) *NFTCreate {
	nc.mutation.SetStatus(n)
	return nc
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (nc *NFTCreate) SetNillableStatus(n *nft.Status) *NFTCreate {
	if n != nil {
		nc.SetStatus(*n)
	}
	return nc
}

// SetDescJSONURL sets the "desc_json_url" field.
func (nc *NFTCreate) SetDescJSONURL(s string) *NFTCreate {
	nc.mutation.SetDescJSONURL(s)
	return nc
}

// SetNillableDescJSONURL sets the "desc_json_url" field if the given value is not nil.
func (nc *NFTCreate) SetNillableDescJSONURL(s *string) *NFTCreate {
	if s != nil {
		nc.SetDescJSONURL(*s)
	}
	return nc
}

// SetDescJSONDurl sets the "desc_json_durl" field.
func (nc *NFTCreate) SetDescJSONDurl(s string) *NFTCreate {
	nc.mutation.SetDescJSONDurl(s)
	return nc
}

// SetNillableDescJSONDurl sets the "desc_json_durl" field if the given value is not nil.
func (nc *NFTCreate) SetNillableDescJSONDurl(s *string) *NFTCreate {
	if s != nil {
		nc.SetDescJSONDurl(*s)
	}
	return nc
}

// SetPinStatus sets the "pin_status" field.
func (nc *NFTCreate) SetPinStatus(ns nft.PinStatus) *NFTCreate {
	nc.mutation.SetPinStatus(ns)
	return nc
}

// SetNillablePinStatus sets the "pin_status" field if the given value is not nil.
func (nc *NFTCreate) SetNillablePinStatus(ns *nft.PinStatus) *NFTCreate {
	if ns != nil {
		nc.SetPinStatus(*ns)
	}
	return nc
}

// SetContractAddress sets the "contract_address" field.
func (nc *NFTCreate) SetContractAddress(s string) *NFTCreate {
	nc.mutation.SetContractAddress(s)
	return nc
}

// SetNillableContractAddress sets the "contract_address" field if the given value is not nil.
func (nc *NFTCreate) SetNillableContractAddress(s *string) *NFTCreate {
	if s != nil {
		nc.SetContractAddress(*s)
	}
	return nc
}

// SetMintCardNum sets the "mint_card_num" field.
func (nc *NFTCreate) SetMintCardNum(u uint64) *NFTCreate {
	nc.mutation.SetMintCardNum(u)
	return nc
}

// SetNillableMintCardNum sets the "mint_card_num" field if the given value is not nil.
func (nc *NFTCreate) SetNillableMintCardNum(u *uint64) *NFTCreate {
	if u != nil {
		nc.SetMintCardNum(*u)
	}
	return nc
}

// SetID sets the "id" field.
func (nc *NFTCreate) SetID(u uint64) *NFTCreate {
	nc.mutation.SetID(u)
	return nc
}

// SetOwnerID sets the "owner" edge to the User entity by ID.
func (nc *NFTCreate) SetOwnerID(id uint64) *NFTCreate {
	nc.mutation.SetOwnerID(id)
	return nc
}

// SetNillableOwnerID sets the "owner" edge to the User entity by ID if the given value is not nil.
func (nc *NFTCreate) SetNillableOwnerID(id *uint64) *NFTCreate {
	if id != nil {
		nc = nc.SetOwnerID(*id)
	}
	return nc
}

// SetOwner sets the "owner" edge to the User entity.
func (nc *NFTCreate) SetOwner(u *User) *NFTCreate {
	return nc.SetOwnerID(u.ID)
}

// Mutation returns the NFTMutation object of the builder.
func (nc *NFTCreate) Mutation() *NFTMutation {
	return nc.mutation
}

// Save creates the NFT in the database.
func (nc *NFTCreate) Save(ctx context.Context) (*NFT, error) {
	var (
		err  error
		node *NFT
	)
	nc.defaults()
	if len(nc.hooks) == 0 {
		if err = nc.check(); err != nil {
			return nil, err
		}
		node, err = nc.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*NFTMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = nc.check(); err != nil {
				return nil, err
			}
			nc.mutation = mutation
			if node, err = nc.sqlSave(ctx); err != nil {
				return nil, err
			}
			mutation.id = &node.ID
			mutation.done = true
			return node, err
		})
		for i := len(nc.hooks) - 1; i >= 0; i-- {
			if nc.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = nc.hooks[i](mut)
		}
		v, err := mut.Mutate(ctx, nc.mutation)
		if err != nil {
			return nil, err
		}
		nv, ok := v.(*NFT)
		if !ok {
			return nil, fmt.Errorf("unexpected node type %T returned from NFTMutation", v)
		}
		node = nv
	}
	return node, err
}

// SaveX calls Save and panics if Save returns an error.
func (nc *NFTCreate) SaveX(ctx context.Context) *NFT {
	v, err := nc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (nc *NFTCreate) Exec(ctx context.Context) error {
	_, err := nc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (nc *NFTCreate) ExecX(ctx context.Context) {
	if err := nc.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (nc *NFTCreate) defaults() {
	if _, ok := nc.mutation.CreateTime(); !ok {
		v := nft.DefaultCreateTime()
		nc.mutation.SetCreateTime(v)
	}
	if _, ok := nc.mutation.UpdateTime(); !ok {
		v := nft.DefaultUpdateTime()
		nc.mutation.SetUpdateTime(v)
	}
	if _, ok := nc.mutation.Name(); !ok {
		v := nft.DefaultName
		nc.mutation.SetName(v)
	}
	if _, ok := nc.mutation.Desc(); !ok {
		v := nft.DefaultDesc
		nc.mutation.SetDesc(v)
	}
	if _, ok := nc.mutation.Status(); !ok {
		v := nft.DefaultStatus
		nc.mutation.SetStatus(v)
	}
	if _, ok := nc.mutation.PinStatus(); !ok {
		v := nft.DefaultPinStatus
		nc.mutation.SetPinStatus(v)
	}
	if _, ok := nc.mutation.ContractAddress(); !ok {
		v := nft.DefaultContractAddress
		nc.mutation.SetContractAddress(v)
	}
	if _, ok := nc.mutation.MintCardNum(); !ok {
		v := nft.DefaultMintCardNum
		nc.mutation.SetMintCardNum(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (nc *NFTCreate) check() error {
	if _, ok := nc.mutation.CreateTime(); !ok {
		return &ValidationError{Name: "create_time", err: errors.New(`ent: missing required field "NFT.create_time"`)}
	}
	if _, ok := nc.mutation.UpdateTime(); !ok {
		return &ValidationError{Name: "update_time", err: errors.New(`ent: missing required field "NFT.update_time"`)}
	}
	if _, ok := nc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`ent: missing required field "NFT.name"`)}
	}
	if _, ok := nc.mutation.Desc(); !ok {
		return &ValidationError{Name: "desc", err: errors.New(`ent: missing required field "NFT.desc"`)}
	}
	if _, ok := nc.mutation.MediaInfoJSON(); !ok {
		return &ValidationError{Name: "media_info_json", err: errors.New(`ent: missing required field "NFT.media_info_json"`)}
	}
	if _, ok := nc.mutation.Status(); !ok {
		return &ValidationError{Name: "status", err: errors.New(`ent: missing required field "NFT.status"`)}
	}
	if v, ok := nc.mutation.Status(); ok {
		if err := nft.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`ent: validator failed for field "NFT.status": %w`, err)}
		}
	}
	if _, ok := nc.mutation.PinStatus(); !ok {
		return &ValidationError{Name: "pin_status", err: errors.New(`ent: missing required field "NFT.pin_status"`)}
	}
	if v, ok := nc.mutation.PinStatus(); ok {
		if err := nft.PinStatusValidator(v); err != nil {
			return &ValidationError{Name: "pin_status", err: fmt.Errorf(`ent: validator failed for field "NFT.pin_status": %w`, err)}
		}
	}
	if _, ok := nc.mutation.ContractAddress(); !ok {
		return &ValidationError{Name: "contract_address", err: errors.New(`ent: missing required field "NFT.contract_address"`)}
	}
	if _, ok := nc.mutation.MintCardNum(); !ok {
		return &ValidationError{Name: "mint_card_num", err: errors.New(`ent: missing required field "NFT.mint_card_num"`)}
	}
	return nil
}

func (nc *NFTCreate) sqlSave(ctx context.Context) (*NFT, error) {
	_node, _spec := nc.createSpec()
	if err := sqlgraph.CreateNode(ctx, nc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != _node.ID {
		id := _spec.ID.Value.(int64)
		_node.ID = uint64(id)
	}
	return _node, nil
}

func (nc *NFTCreate) createSpec() (*NFT, *sqlgraph.CreateSpec) {
	var (
		_node = &NFT{config: nc.config}
		_spec = &sqlgraph.CreateSpec{
			Table: nft.Table,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUint64,
				Column: nft.FieldID,
			},
		}
	)
	_spec.OnConflict = nc.conflict
	if id, ok := nc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := nc.mutation.CreateTime(); ok {
		_spec.SetField(nft.FieldCreateTime, field.TypeTime, value)
		_node.CreateTime = value
	}
	if value, ok := nc.mutation.UpdateTime(); ok {
		_spec.SetField(nft.FieldUpdateTime, field.TypeTime, value)
		_node.UpdateTime = value
	}
	if value, ok := nc.mutation.Name(); ok {
		_spec.SetField(nft.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := nc.mutation.Desc(); ok {
		_spec.SetField(nft.FieldDesc, field.TypeString, value)
		_node.Desc = value
	}
	if value, ok := nc.mutation.CreatorID(); ok {
		_spec.SetField(nft.FieldCreatorID, field.TypeUint64, value)
		_node.CreatorID = value
	}
	if value, ok := nc.mutation.MediaInfoJSON(); ok {
		_spec.SetField(nft.FieldMediaInfoJSON, field.TypeJSON, value)
		_node.MediaInfoJSON = value
	}
	if value, ok := nc.mutation.MediaURL(); ok {
		_spec.SetField(nft.FieldMediaURL, field.TypeString, value)
		_node.MediaURL = value
	}
	if value, ok := nc.mutation.MediaDurl(); ok {
		_spec.SetField(nft.FieldMediaDurl, field.TypeString, value)
		_node.MediaDurl = value
	}
	if value, ok := nc.mutation.TokenID(); ok {
		_spec.SetField(nft.FieldTokenID, field.TypeString, value)
		_node.TokenID = value
	}
	if value, ok := nc.mutation.Status(); ok {
		_spec.SetField(nft.FieldStatus, field.TypeEnum, value)
		_node.Status = value
	}
	if value, ok := nc.mutation.DescJSONURL(); ok {
		_spec.SetField(nft.FieldDescJSONURL, field.TypeString, value)
		_node.DescJSONURL = value
	}
	if value, ok := nc.mutation.DescJSONDurl(); ok {
		_spec.SetField(nft.FieldDescJSONDurl, field.TypeString, value)
		_node.DescJSONDurl = value
	}
	if value, ok := nc.mutation.PinStatus(); ok {
		_spec.SetField(nft.FieldPinStatus, field.TypeEnum, value)
		_node.PinStatus = value
	}
	if value, ok := nc.mutation.ContractAddress(); ok {
		_spec.SetField(nft.FieldContractAddress, field.TypeString, value)
		_node.ContractAddress = value
	}
	if value, ok := nc.mutation.MintCardNum(); ok {
		_spec.SetField(nft.FieldMintCardNum, field.TypeUint64, value)
		_node.MintCardNum = value
	}
	if nodes := nc.mutation.OwnerIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   nft.OwnerTable,
			Columns: []string{nft.OwnerColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_node.UserID = nodes[0]
		_spec.Edges = append(_spec.Edges, edge)
	}
	return _node, _spec
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.NFT.Create().
//		SetCreateTime(v).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.NFTUpsert) {
//			SetCreateTime(v+v).
//		}).
//		Exec(ctx)
func (nc *NFTCreate) OnConflict(opts ...sql.ConflictOption) *NFTUpsertOne {
	nc.conflict = opts
	return &NFTUpsertOne{
		create: nc,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.NFT.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (nc *NFTCreate) OnConflictColumns(columns ...string) *NFTUpsertOne {
	nc.conflict = append(nc.conflict, sql.ConflictColumns(columns...))
	return &NFTUpsertOne{
		create: nc,
	}
}

type (
	// NFTUpsertOne is the builder for "upsert"-ing
	//  one NFT node.
	NFTUpsertOne struct {
		create *NFTCreate
	}

	// NFTUpsert is the "OnConflict" setter.
	NFTUpsert struct {
		*sql.UpdateSet
	}
)

// SetUpdateTime sets the "update_time" field.
func (u *NFTUpsert) SetUpdateTime(v time.Time) *NFTUpsert {
	u.Set(nft.FieldUpdateTime, v)
	return u
}

// UpdateUpdateTime sets the "update_time" field to the value that was provided on create.
func (u *NFTUpsert) UpdateUpdateTime() *NFTUpsert {
	u.SetExcluded(nft.FieldUpdateTime)
	return u
}

// SetName sets the "name" field.
func (u *NFTUpsert) SetName(v string) *NFTUpsert {
	u.Set(nft.FieldName, v)
	return u
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *NFTUpsert) UpdateName() *NFTUpsert {
	u.SetExcluded(nft.FieldName)
	return u
}

// SetDesc sets the "desc" field.
func (u *NFTUpsert) SetDesc(v string) *NFTUpsert {
	u.Set(nft.FieldDesc, v)
	return u
}

// UpdateDesc sets the "desc" field to the value that was provided on create.
func (u *NFTUpsert) UpdateDesc() *NFTUpsert {
	u.SetExcluded(nft.FieldDesc)
	return u
}

// SetUserID sets the "user_id" field.
func (u *NFTUpsert) SetUserID(v uint64) *NFTUpsert {
	u.Set(nft.FieldUserID, v)
	return u
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *NFTUpsert) UpdateUserID() *NFTUpsert {
	u.SetExcluded(nft.FieldUserID)
	return u
}

// ClearUserID clears the value of the "user_id" field.
func (u *NFTUpsert) ClearUserID() *NFTUpsert {
	u.SetNull(nft.FieldUserID)
	return u
}

// SetCreatorID sets the "creator_id" field.
func (u *NFTUpsert) SetCreatorID(v uint64) *NFTUpsert {
	u.Set(nft.FieldCreatorID, v)
	return u
}

// UpdateCreatorID sets the "creator_id" field to the value that was provided on create.
func (u *NFTUpsert) UpdateCreatorID() *NFTUpsert {
	u.SetExcluded(nft.FieldCreatorID)
	return u
}

// AddCreatorID adds v to the "creator_id" field.
func (u *NFTUpsert) AddCreatorID(v uint64) *NFTUpsert {
	u.Add(nft.FieldCreatorID, v)
	return u
}

// ClearCreatorID clears the value of the "creator_id" field.
func (u *NFTUpsert) ClearCreatorID() *NFTUpsert {
	u.SetNull(nft.FieldCreatorID)
	return u
}

// SetMediaInfoJSON sets the "media_info_json" field.
func (u *NFTUpsert) SetMediaInfoJSON(v []string) *NFTUpsert {
	u.Set(nft.FieldMediaInfoJSON, v)
	return u
}

// UpdateMediaInfoJSON sets the "media_info_json" field to the value that was provided on create.
func (u *NFTUpsert) UpdateMediaInfoJSON() *NFTUpsert {
	u.SetExcluded(nft.FieldMediaInfoJSON)
	return u
}

// SetMediaURL sets the "media_url" field.
func (u *NFTUpsert) SetMediaURL(v string) *NFTUpsert {
	u.Set(nft.FieldMediaURL, v)
	return u
}

// UpdateMediaURL sets the "media_url" field to the value that was provided on create.
func (u *NFTUpsert) UpdateMediaURL() *NFTUpsert {
	u.SetExcluded(nft.FieldMediaURL)
	return u
}

// ClearMediaURL clears the value of the "media_url" field.
func (u *NFTUpsert) ClearMediaURL() *NFTUpsert {
	u.SetNull(nft.FieldMediaURL)
	return u
}

// SetMediaDurl sets the "media_durl" field.
func (u *NFTUpsert) SetMediaDurl(v string) *NFTUpsert {
	u.Set(nft.FieldMediaDurl, v)
	return u
}

// UpdateMediaDurl sets the "media_durl" field to the value that was provided on create.
func (u *NFTUpsert) UpdateMediaDurl() *NFTUpsert {
	u.SetExcluded(nft.FieldMediaDurl)
	return u
}

// ClearMediaDurl clears the value of the "media_durl" field.
func (u *NFTUpsert) ClearMediaDurl() *NFTUpsert {
	u.SetNull(nft.FieldMediaDurl)
	return u
}

// SetTokenID sets the "token_id" field.
func (u *NFTUpsert) SetTokenID(v string) *NFTUpsert {
	u.Set(nft.FieldTokenID, v)
	return u
}

// UpdateTokenID sets the "token_id" field to the value that was provided on create.
func (u *NFTUpsert) UpdateTokenID() *NFTUpsert {
	u.SetExcluded(nft.FieldTokenID)
	return u
}

// ClearTokenID clears the value of the "token_id" field.
func (u *NFTUpsert) ClearTokenID() *NFTUpsert {
	u.SetNull(nft.FieldTokenID)
	return u
}

// SetStatus sets the "status" field.
func (u *NFTUpsert) SetStatus(v nft.Status) *NFTUpsert {
	u.Set(nft.FieldStatus, v)
	return u
}

// UpdateStatus sets the "status" field to the value that was provided on create.
func (u *NFTUpsert) UpdateStatus() *NFTUpsert {
	u.SetExcluded(nft.FieldStatus)
	return u
}

// SetDescJSONURL sets the "desc_json_url" field.
func (u *NFTUpsert) SetDescJSONURL(v string) *NFTUpsert {
	u.Set(nft.FieldDescJSONURL, v)
	return u
}

// UpdateDescJSONURL sets the "desc_json_url" field to the value that was provided on create.
func (u *NFTUpsert) UpdateDescJSONURL() *NFTUpsert {
	u.SetExcluded(nft.FieldDescJSONURL)
	return u
}

// ClearDescJSONURL clears the value of the "desc_json_url" field.
func (u *NFTUpsert) ClearDescJSONURL() *NFTUpsert {
	u.SetNull(nft.FieldDescJSONURL)
	return u
}

// SetDescJSONDurl sets the "desc_json_durl" field.
func (u *NFTUpsert) SetDescJSONDurl(v string) *NFTUpsert {
	u.Set(nft.FieldDescJSONDurl, v)
	return u
}

// UpdateDescJSONDurl sets the "desc_json_durl" field to the value that was provided on create.
func (u *NFTUpsert) UpdateDescJSONDurl() *NFTUpsert {
	u.SetExcluded(nft.FieldDescJSONDurl)
	return u
}

// ClearDescJSONDurl clears the value of the "desc_json_durl" field.
func (u *NFTUpsert) ClearDescJSONDurl() *NFTUpsert {
	u.SetNull(nft.FieldDescJSONDurl)
	return u
}

// SetPinStatus sets the "pin_status" field.
func (u *NFTUpsert) SetPinStatus(v nft.PinStatus) *NFTUpsert {
	u.Set(nft.FieldPinStatus, v)
	return u
}

// UpdatePinStatus sets the "pin_status" field to the value that was provided on create.
func (u *NFTUpsert) UpdatePinStatus() *NFTUpsert {
	u.SetExcluded(nft.FieldPinStatus)
	return u
}

// SetContractAddress sets the "contract_address" field.
func (u *NFTUpsert) SetContractAddress(v string) *NFTUpsert {
	u.Set(nft.FieldContractAddress, v)
	return u
}

// UpdateContractAddress sets the "contract_address" field to the value that was provided on create.
func (u *NFTUpsert) UpdateContractAddress() *NFTUpsert {
	u.SetExcluded(nft.FieldContractAddress)
	return u
}

// SetMintCardNum sets the "mint_card_num" field.
func (u *NFTUpsert) SetMintCardNum(v uint64) *NFTUpsert {
	u.Set(nft.FieldMintCardNum, v)
	return u
}

// UpdateMintCardNum sets the "mint_card_num" field to the value that was provided on create.
func (u *NFTUpsert) UpdateMintCardNum() *NFTUpsert {
	u.SetExcluded(nft.FieldMintCardNum)
	return u
}

// AddMintCardNum adds v to the "mint_card_num" field.
func (u *NFTUpsert) AddMintCardNum(v uint64) *NFTUpsert {
	u.Add(nft.FieldMintCardNum, v)
	return u
}

// UpdateNewValues updates the mutable fields using the new values that were set on create except the ID field.
// Using this option is equivalent to using:
//
//	client.NFT.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(nft.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *NFTUpsertOne) UpdateNewValues() *NFTUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		if _, exists := u.create.mutation.ID(); exists {
			s.SetIgnore(nft.FieldID)
		}
		if _, exists := u.create.mutation.CreateTime(); exists {
			s.SetIgnore(nft.FieldCreateTime)
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.NFT.Create().
//	    OnConflict(sql.ResolveWithIgnore()).
//	    Exec(ctx)
func (u *NFTUpsertOne) Ignore() *NFTUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *NFTUpsertOne) DoNothing() *NFTUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the NFTCreate.OnConflict
// documentation for more info.
func (u *NFTUpsertOne) Update(set func(*NFTUpsert)) *NFTUpsertOne {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&NFTUpsert{UpdateSet: update})
	}))
	return u
}

// SetUpdateTime sets the "update_time" field.
func (u *NFTUpsertOne) SetUpdateTime(v time.Time) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetUpdateTime(v)
	})
}

// UpdateUpdateTime sets the "update_time" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateUpdateTime() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateUpdateTime()
	})
}

// SetName sets the "name" field.
func (u *NFTUpsertOne) SetName(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateName() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateName()
	})
}

// SetDesc sets the "desc" field.
func (u *NFTUpsertOne) SetDesc(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetDesc(v)
	})
}

// UpdateDesc sets the "desc" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateDesc() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateDesc()
	})
}

// SetUserID sets the "user_id" field.
func (u *NFTUpsertOne) SetUserID(v uint64) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetUserID(v)
	})
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateUserID() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateUserID()
	})
}

// ClearUserID clears the value of the "user_id" field.
func (u *NFTUpsertOne) ClearUserID() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.ClearUserID()
	})
}

// SetCreatorID sets the "creator_id" field.
func (u *NFTUpsertOne) SetCreatorID(v uint64) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetCreatorID(v)
	})
}

// AddCreatorID adds v to the "creator_id" field.
func (u *NFTUpsertOne) AddCreatorID(v uint64) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.AddCreatorID(v)
	})
}

// UpdateCreatorID sets the "creator_id" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateCreatorID() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateCreatorID()
	})
}

// ClearCreatorID clears the value of the "creator_id" field.
func (u *NFTUpsertOne) ClearCreatorID() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.ClearCreatorID()
	})
}

// SetMediaInfoJSON sets the "media_info_json" field.
func (u *NFTUpsertOne) SetMediaInfoJSON(v []string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetMediaInfoJSON(v)
	})
}

// UpdateMediaInfoJSON sets the "media_info_json" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateMediaInfoJSON() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMediaInfoJSON()
	})
}

// SetMediaURL sets the "media_url" field.
func (u *NFTUpsertOne) SetMediaURL(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetMediaURL(v)
	})
}

// UpdateMediaURL sets the "media_url" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateMediaURL() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMediaURL()
	})
}

// ClearMediaURL clears the value of the "media_url" field.
func (u *NFTUpsertOne) ClearMediaURL() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.ClearMediaURL()
	})
}

// SetMediaDurl sets the "media_durl" field.
func (u *NFTUpsertOne) SetMediaDurl(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetMediaDurl(v)
	})
}

// UpdateMediaDurl sets the "media_durl" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateMediaDurl() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMediaDurl()
	})
}

// ClearMediaDurl clears the value of the "media_durl" field.
func (u *NFTUpsertOne) ClearMediaDurl() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.ClearMediaDurl()
	})
}

// SetTokenID sets the "token_id" field.
func (u *NFTUpsertOne) SetTokenID(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetTokenID(v)
	})
}

// UpdateTokenID sets the "token_id" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateTokenID() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateTokenID()
	})
}

// ClearTokenID clears the value of the "token_id" field.
func (u *NFTUpsertOne) ClearTokenID() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.ClearTokenID()
	})
}

// SetStatus sets the "status" field.
func (u *NFTUpsertOne) SetStatus(v nft.Status) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetStatus(v)
	})
}

// UpdateStatus sets the "status" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateStatus() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateStatus()
	})
}

// SetDescJSONURL sets the "desc_json_url" field.
func (u *NFTUpsertOne) SetDescJSONURL(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetDescJSONURL(v)
	})
}

// UpdateDescJSONURL sets the "desc_json_url" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateDescJSONURL() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateDescJSONURL()
	})
}

// ClearDescJSONURL clears the value of the "desc_json_url" field.
func (u *NFTUpsertOne) ClearDescJSONURL() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.ClearDescJSONURL()
	})
}

// SetDescJSONDurl sets the "desc_json_durl" field.
func (u *NFTUpsertOne) SetDescJSONDurl(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetDescJSONDurl(v)
	})
}

// UpdateDescJSONDurl sets the "desc_json_durl" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateDescJSONDurl() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateDescJSONDurl()
	})
}

// ClearDescJSONDurl clears the value of the "desc_json_durl" field.
func (u *NFTUpsertOne) ClearDescJSONDurl() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.ClearDescJSONDurl()
	})
}

// SetPinStatus sets the "pin_status" field.
func (u *NFTUpsertOne) SetPinStatus(v nft.PinStatus) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetPinStatus(v)
	})
}

// UpdatePinStatus sets the "pin_status" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdatePinStatus() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdatePinStatus()
	})
}

// SetContractAddress sets the "contract_address" field.
func (u *NFTUpsertOne) SetContractAddress(v string) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetContractAddress(v)
	})
}

// UpdateContractAddress sets the "contract_address" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateContractAddress() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateContractAddress()
	})
}

// SetMintCardNum sets the "mint_card_num" field.
func (u *NFTUpsertOne) SetMintCardNum(v uint64) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.SetMintCardNum(v)
	})
}

// AddMintCardNum adds v to the "mint_card_num" field.
func (u *NFTUpsertOne) AddMintCardNum(v uint64) *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.AddMintCardNum(v)
	})
}

// UpdateMintCardNum sets the "mint_card_num" field to the value that was provided on create.
func (u *NFTUpsertOne) UpdateMintCardNum() *NFTUpsertOne {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMintCardNum()
	})
}

// Exec executes the query.
func (u *NFTUpsertOne) Exec(ctx context.Context) error {
	if len(u.create.conflict) == 0 {
		return errors.New("ent: missing options for NFTCreate.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *NFTUpsertOne) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}

// Exec executes the UPSERT query and returns the inserted/updated ID.
func (u *NFTUpsertOne) ID(ctx context.Context) (id uint64, err error) {
	node, err := u.create.Save(ctx)
	if err != nil {
		return id, err
	}
	return node.ID, nil
}

// IDX is like ID, but panics if an error occurs.
func (u *NFTUpsertOne) IDX(ctx context.Context) uint64 {
	id, err := u.ID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// NFTCreateBulk is the builder for creating many NFT entities in bulk.
type NFTCreateBulk struct {
	config
	builders []*NFTCreate
	conflict []sql.ConflictOption
}

// Save creates the NFT entities in the database.
func (ncb *NFTCreateBulk) Save(ctx context.Context) ([]*NFT, error) {
	specs := make([]*sqlgraph.CreateSpec, len(ncb.builders))
	nodes := make([]*NFT, len(ncb.builders))
	mutators := make([]Mutator, len(ncb.builders))
	for i := range ncb.builders {
		func(i int, root context.Context) {
			builder := ncb.builders[i]
			builder.defaults()
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*NFTMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, ncb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					spec.OnConflict = ncb.conflict
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, ncb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				if specs[i].ID.Value != nil && nodes[i].ID == 0 {
					id := specs[i].ID.Value.(int64)
					nodes[i].ID = uint64(id)
				}
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, ncb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (ncb *NFTCreateBulk) SaveX(ctx context.Context) []*NFT {
	v, err := ncb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (ncb *NFTCreateBulk) Exec(ctx context.Context) error {
	_, err := ncb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (ncb *NFTCreateBulk) ExecX(ctx context.Context) {
	if err := ncb.Exec(ctx); err != nil {
		panic(err)
	}
}

// OnConflict allows configuring the `ON CONFLICT` / `ON DUPLICATE KEY` clause
// of the `INSERT` statement. For example:
//
//	client.NFT.CreateBulk(builders...).
//		OnConflict(
//			// Update the row with the new values
//			// the was proposed for insertion.
//			sql.ResolveWithNewValues(),
//		).
//		// Override some of the fields with custom
//		// update values.
//		Update(func(u *ent.NFTUpsert) {
//			SetCreateTime(v+v).
//		}).
//		Exec(ctx)
func (ncb *NFTCreateBulk) OnConflict(opts ...sql.ConflictOption) *NFTUpsertBulk {
	ncb.conflict = opts
	return &NFTUpsertBulk{
		create: ncb,
	}
}

// OnConflictColumns calls `OnConflict` and configures the columns
// as conflict target. Using this option is equivalent to using:
//
//	client.NFT.Create().
//		OnConflict(sql.ConflictColumns(columns...)).
//		Exec(ctx)
func (ncb *NFTCreateBulk) OnConflictColumns(columns ...string) *NFTUpsertBulk {
	ncb.conflict = append(ncb.conflict, sql.ConflictColumns(columns...))
	return &NFTUpsertBulk{
		create: ncb,
	}
}

// NFTUpsertBulk is the builder for "upsert"-ing
// a bulk of NFT nodes.
type NFTUpsertBulk struct {
	create *NFTCreateBulk
}

// UpdateNewValues updates the mutable fields using the new values that
// were set on create. Using this option is equivalent to using:
//
//	client.NFT.Create().
//		OnConflict(
//			sql.ResolveWithNewValues(),
//			sql.ResolveWith(func(u *sql.UpdateSet) {
//				u.SetIgnore(nft.FieldID)
//			}),
//		).
//		Exec(ctx)
func (u *NFTUpsertBulk) UpdateNewValues() *NFTUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithNewValues())
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(s *sql.UpdateSet) {
		for _, b := range u.create.builders {
			if _, exists := b.mutation.ID(); exists {
				s.SetIgnore(nft.FieldID)
			}
			if _, exists := b.mutation.CreateTime(); exists {
				s.SetIgnore(nft.FieldCreateTime)
			}
		}
	}))
	return u
}

// Ignore sets each column to itself in case of conflict.
// Using this option is equivalent to using:
//
//	client.NFT.Create().
//		OnConflict(sql.ResolveWithIgnore()).
//		Exec(ctx)
func (u *NFTUpsertBulk) Ignore() *NFTUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWithIgnore())
	return u
}

// DoNothing configures the conflict_action to `DO NOTHING`.
// Supported only by SQLite and PostgreSQL.
func (u *NFTUpsertBulk) DoNothing() *NFTUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.DoNothing())
	return u
}

// Update allows overriding fields `UPDATE` values. See the NFTCreateBulk.OnConflict
// documentation for more info.
func (u *NFTUpsertBulk) Update(set func(*NFTUpsert)) *NFTUpsertBulk {
	u.create.conflict = append(u.create.conflict, sql.ResolveWith(func(update *sql.UpdateSet) {
		set(&NFTUpsert{UpdateSet: update})
	}))
	return u
}

// SetUpdateTime sets the "update_time" field.
func (u *NFTUpsertBulk) SetUpdateTime(v time.Time) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetUpdateTime(v)
	})
}

// UpdateUpdateTime sets the "update_time" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateUpdateTime() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateUpdateTime()
	})
}

// SetName sets the "name" field.
func (u *NFTUpsertBulk) SetName(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetName(v)
	})
}

// UpdateName sets the "name" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateName() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateName()
	})
}

// SetDesc sets the "desc" field.
func (u *NFTUpsertBulk) SetDesc(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetDesc(v)
	})
}

// UpdateDesc sets the "desc" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateDesc() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateDesc()
	})
}

// SetUserID sets the "user_id" field.
func (u *NFTUpsertBulk) SetUserID(v uint64) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetUserID(v)
	})
}

// UpdateUserID sets the "user_id" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateUserID() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateUserID()
	})
}

// ClearUserID clears the value of the "user_id" field.
func (u *NFTUpsertBulk) ClearUserID() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.ClearUserID()
	})
}

// SetCreatorID sets the "creator_id" field.
func (u *NFTUpsertBulk) SetCreatorID(v uint64) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetCreatorID(v)
	})
}

// AddCreatorID adds v to the "creator_id" field.
func (u *NFTUpsertBulk) AddCreatorID(v uint64) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.AddCreatorID(v)
	})
}

// UpdateCreatorID sets the "creator_id" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateCreatorID() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateCreatorID()
	})
}

// ClearCreatorID clears the value of the "creator_id" field.
func (u *NFTUpsertBulk) ClearCreatorID() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.ClearCreatorID()
	})
}

// SetMediaInfoJSON sets the "media_info_json" field.
func (u *NFTUpsertBulk) SetMediaInfoJSON(v []string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetMediaInfoJSON(v)
	})
}

// UpdateMediaInfoJSON sets the "media_info_json" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateMediaInfoJSON() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMediaInfoJSON()
	})
}

// SetMediaURL sets the "media_url" field.
func (u *NFTUpsertBulk) SetMediaURL(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetMediaURL(v)
	})
}

// UpdateMediaURL sets the "media_url" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateMediaURL() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMediaURL()
	})
}

// ClearMediaURL clears the value of the "media_url" field.
func (u *NFTUpsertBulk) ClearMediaURL() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.ClearMediaURL()
	})
}

// SetMediaDurl sets the "media_durl" field.
func (u *NFTUpsertBulk) SetMediaDurl(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetMediaDurl(v)
	})
}

// UpdateMediaDurl sets the "media_durl" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateMediaDurl() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMediaDurl()
	})
}

// ClearMediaDurl clears the value of the "media_durl" field.
func (u *NFTUpsertBulk) ClearMediaDurl() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.ClearMediaDurl()
	})
}

// SetTokenID sets the "token_id" field.
func (u *NFTUpsertBulk) SetTokenID(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetTokenID(v)
	})
}

// UpdateTokenID sets the "token_id" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateTokenID() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateTokenID()
	})
}

// ClearTokenID clears the value of the "token_id" field.
func (u *NFTUpsertBulk) ClearTokenID() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.ClearTokenID()
	})
}

// SetStatus sets the "status" field.
func (u *NFTUpsertBulk) SetStatus(v nft.Status) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetStatus(v)
	})
}

// UpdateStatus sets the "status" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateStatus() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateStatus()
	})
}

// SetDescJSONURL sets the "desc_json_url" field.
func (u *NFTUpsertBulk) SetDescJSONURL(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetDescJSONURL(v)
	})
}

// UpdateDescJSONURL sets the "desc_json_url" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateDescJSONURL() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateDescJSONURL()
	})
}

// ClearDescJSONURL clears the value of the "desc_json_url" field.
func (u *NFTUpsertBulk) ClearDescJSONURL() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.ClearDescJSONURL()
	})
}

// SetDescJSONDurl sets the "desc_json_durl" field.
func (u *NFTUpsertBulk) SetDescJSONDurl(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetDescJSONDurl(v)
	})
}

// UpdateDescJSONDurl sets the "desc_json_durl" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateDescJSONDurl() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateDescJSONDurl()
	})
}

// ClearDescJSONDurl clears the value of the "desc_json_durl" field.
func (u *NFTUpsertBulk) ClearDescJSONDurl() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.ClearDescJSONDurl()
	})
}

// SetPinStatus sets the "pin_status" field.
func (u *NFTUpsertBulk) SetPinStatus(v nft.PinStatus) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetPinStatus(v)
	})
}

// UpdatePinStatus sets the "pin_status" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdatePinStatus() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdatePinStatus()
	})
}

// SetContractAddress sets the "contract_address" field.
func (u *NFTUpsertBulk) SetContractAddress(v string) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetContractAddress(v)
	})
}

// UpdateContractAddress sets the "contract_address" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateContractAddress() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateContractAddress()
	})
}

// SetMintCardNum sets the "mint_card_num" field.
func (u *NFTUpsertBulk) SetMintCardNum(v uint64) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.SetMintCardNum(v)
	})
}

// AddMintCardNum adds v to the "mint_card_num" field.
func (u *NFTUpsertBulk) AddMintCardNum(v uint64) *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.AddMintCardNum(v)
	})
}

// UpdateMintCardNum sets the "mint_card_num" field to the value that was provided on create.
func (u *NFTUpsertBulk) UpdateMintCardNum() *NFTUpsertBulk {
	return u.Update(func(s *NFTUpsert) {
		s.UpdateMintCardNum()
	})
}

// Exec executes the query.
func (u *NFTUpsertBulk) Exec(ctx context.Context) error {
	for i, b := range u.create.builders {
		if len(b.conflict) != 0 {
			return fmt.Errorf("ent: OnConflict was set for builder %d. Set it on the NFTCreateBulk instead", i)
		}
	}
	if len(u.create.conflict) == 0 {
		return errors.New("ent: missing options for NFTCreateBulk.OnConflict")
	}
	return u.create.Exec(ctx)
}

// ExecX is like Exec, but panics if an error occurs.
func (u *NFTUpsertBulk) ExecX(ctx context.Context) {
	if err := u.create.Exec(ctx); err != nil {
		panic(err)
	}
}
