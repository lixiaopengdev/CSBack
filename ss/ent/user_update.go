// Code generated by ent, DO NOT EDIT.

package ent

import (
	"CSBackendTmp/ent/agora_token"
	"CSBackendTmp/ent/card"
	"CSBackendTmp/ent/collection"
	"CSBackendTmp/ent/contact"
	"CSBackendTmp/ent/creation"
	"CSBackendTmp/ent/csfield"
	"CSBackendTmp/ent/device"
	"CSBackendTmp/ent/feedback"
	"CSBackendTmp/ent/friendship"
	"CSBackendTmp/ent/hidden"
	"CSBackendTmp/ent/invite_code"
	"CSBackendTmp/ent/join"
	"CSBackendTmp/ent/mask"
	"CSBackendTmp/ent/message"
	"CSBackendTmp/ent/nft"
	"CSBackendTmp/ent/predicate"
	"CSBackendTmp/ent/reaction"
	"CSBackendTmp/ent/setting"
	"CSBackendTmp/ent/stream"
	"CSBackendTmp/ent/timedew"
	"CSBackendTmp/ent/user"
	"CSBackendTmp/ent/user_auth"
	"CSBackendTmp/ent/user_history"
	"context"
	"errors"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// UserUpdate is the builder for updating User entities.
type UserUpdate struct {
	config
	hooks    []Hook
	mutation *UserMutation
}

// Where appends a list predicates to the UserUpdate builder.
func (uu *UserUpdate) Where(ps ...predicate.User) *UserUpdate {
	uu.mutation.Where(ps...)
	return uu
}

// SetUpdateTime sets the "update_time" field.
func (uu *UserUpdate) SetUpdateTime(t time.Time) *UserUpdate {
	uu.mutation.SetUpdateTime(t)
	return uu
}

// SetOpenID sets the "open_id" field.
func (uu *UserUpdate) SetOpenID(s string) *UserUpdate {
	uu.mutation.SetOpenID(s)
	return uu
}

// SetNillableOpenID sets the "open_id" field if the given value is not nil.
func (uu *UserUpdate) SetNillableOpenID(s *string) *UserUpdate {
	if s != nil {
		uu.SetOpenID(*s)
	}
	return uu
}

// ClearOpenID clears the value of the "open_id" field.
func (uu *UserUpdate) ClearOpenID() *UserUpdate {
	uu.mutation.ClearOpenID()
	return uu
}

// SetName sets the "name" field.
func (uu *UserUpdate) SetName(s string) *UserUpdate {
	uu.mutation.SetName(s)
	return uu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (uu *UserUpdate) SetNillableName(s *string) *UserUpdate {
	if s != nil {
		uu.SetName(*s)
	}
	return uu
}

// ClearName clears the value of the "name" field.
func (uu *UserUpdate) ClearName() *UserUpdate {
	uu.mutation.ClearName()
	return uu
}

// SetNickName sets the "nick_name" field.
func (uu *UserUpdate) SetNickName(s string) *UserUpdate {
	uu.mutation.SetNickName(s)
	return uu
}

// SetNillableNickName sets the "nick_name" field if the given value is not nil.
func (uu *UserUpdate) SetNillableNickName(s *string) *UserUpdate {
	if s != nil {
		uu.SetNickName(*s)
	}
	return uu
}

// ClearNickName clears the value of the "nick_name" field.
func (uu *UserUpdate) ClearNickName() *UserUpdate {
	uu.mutation.ClearNickName()
	return uu
}

// SetSystemName sets the "system_name" field.
func (uu *UserUpdate) SetSystemName(s string) *UserUpdate {
	uu.mutation.SetSystemName(s)
	return uu
}

// SetNillableSystemName sets the "system_name" field if the given value is not nil.
func (uu *UserUpdate) SetNillableSystemName(s *string) *UserUpdate {
	if s != nil {
		uu.SetSystemName(*s)
	}
	return uu
}

// ClearSystemName clears the value of the "system_name" field.
func (uu *UserUpdate) ClearSystemName() *UserUpdate {
	uu.mutation.ClearSystemName()
	return uu
}

// SetAvatar sets the "avatar" field.
func (uu *UserUpdate) SetAvatar(s string) *UserUpdate {
	uu.mutation.SetAvatar(s)
	return uu
}

// SetNillableAvatar sets the "avatar" field if the given value is not nil.
func (uu *UserUpdate) SetNillableAvatar(s *string) *UserUpdate {
	if s != nil {
		uu.SetAvatar(*s)
	}
	return uu
}

// ClearAvatar clears the value of the "avatar" field.
func (uu *UserUpdate) ClearAvatar() *UserUpdate {
	uu.mutation.ClearAvatar()
	return uu
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (uu *UserUpdate) SetThumbnailURL(s string) *UserUpdate {
	uu.mutation.SetThumbnailURL(s)
	return uu
}

// SetNillableThumbnailURL sets the "thumbnail_url" field if the given value is not nil.
func (uu *UserUpdate) SetNillableThumbnailURL(s *string) *UserUpdate {
	if s != nil {
		uu.SetThumbnailURL(*s)
	}
	return uu
}

// SetSex sets the "sex" field.
func (uu *UserUpdate) SetSex(s string) *UserUpdate {
	uu.mutation.SetSex(s)
	return uu
}

// SetNillableSex sets the "sex" field if the given value is not nil.
func (uu *UserUpdate) SetNillableSex(s *string) *UserUpdate {
	if s != nil {
		uu.SetSex(*s)
	}
	return uu
}

// ClearSex clears the value of the "sex" field.
func (uu *UserUpdate) ClearSex() *UserUpdate {
	uu.mutation.ClearSex()
	return uu
}

// SetMobileNo sets the "mobile_no" field.
func (uu *UserUpdate) SetMobileNo(s string) *UserUpdate {
	uu.mutation.SetMobileNo(s)
	return uu
}

// SetNillableMobileNo sets the "mobile_no" field if the given value is not nil.
func (uu *UserUpdate) SetNillableMobileNo(s *string) *UserUpdate {
	if s != nil {
		uu.SetMobileNo(*s)
	}
	return uu
}

// ClearMobileNo clears the value of the "mobile_no" field.
func (uu *UserUpdate) ClearMobileNo() *UserUpdate {
	uu.mutation.ClearMobileNo()
	return uu
}

// SetRegionCode sets the "region_code" field.
func (uu *UserUpdate) SetRegionCode(s string) *UserUpdate {
	uu.mutation.SetRegionCode(s)
	return uu
}

// SetNillableRegionCode sets the "region_code" field if the given value is not nil.
func (uu *UserUpdate) SetNillableRegionCode(s *string) *UserUpdate {
	if s != nil {
		uu.SetRegionCode(*s)
	}
	return uu
}

// ClearRegionCode clears the value of the "region_code" field.
func (uu *UserUpdate) ClearRegionCode() *UserUpdate {
	uu.mutation.ClearRegionCode()
	return uu
}

// SetEmailAddress sets the "email_address" field.
func (uu *UserUpdate) SetEmailAddress(s string) *UserUpdate {
	uu.mutation.SetEmailAddress(s)
	return uu
}

// SetNillableEmailAddress sets the "email_address" field if the given value is not nil.
func (uu *UserUpdate) SetNillableEmailAddress(s *string) *UserUpdate {
	if s != nil {
		uu.SetEmailAddress(*s)
	}
	return uu
}

// ClearEmailAddress clears the value of the "email_address" field.
func (uu *UserUpdate) ClearEmailAddress() *UserUpdate {
	uu.mutation.ClearEmailAddress()
	return uu
}

// SetBirthday sets the "birthday" field.
func (uu *UserUpdate) SetBirthday(s string) *UserUpdate {
	uu.mutation.SetBirthday(s)
	return uu
}

// SetNillableBirthday sets the "birthday" field if the given value is not nil.
func (uu *UserUpdate) SetNillableBirthday(s *string) *UserUpdate {
	if s != nil {
		uu.SetBirthday(*s)
	}
	return uu
}

// ClearBirthday clears the value of the "birthday" field.
func (uu *UserUpdate) ClearBirthday() *UserUpdate {
	uu.mutation.ClearBirthday()
	return uu
}

// SetSchoolName sets the "school_name" field.
func (uu *UserUpdate) SetSchoolName(s string) *UserUpdate {
	uu.mutation.SetSchoolName(s)
	return uu
}

// SetNillableSchoolName sets the "school_name" field if the given value is not nil.
func (uu *UserUpdate) SetNillableSchoolName(s *string) *UserUpdate {
	if s != nil {
		uu.SetSchoolName(*s)
	}
	return uu
}

// ClearSchoolName clears the value of the "school_name" field.
func (uu *UserUpdate) ClearSchoolName() *UserUpdate {
	uu.mutation.ClearSchoolName()
	return uu
}

// SetBio sets the "bio" field.
func (uu *UserUpdate) SetBio(s string) *UserUpdate {
	uu.mutation.SetBio(s)
	return uu
}

// SetNillableBio sets the "bio" field if the given value is not nil.
func (uu *UserUpdate) SetNillableBio(s *string) *UserUpdate {
	if s != nil {
		uu.SetBio(*s)
	}
	return uu
}

// ClearBio clears the value of the "bio" field.
func (uu *UserUpdate) ClearBio() *UserUpdate {
	uu.mutation.ClearBio()
	return uu
}

// SetStatus sets the "status" field.
func (uu *UserUpdate) SetStatus(u user.Status) *UserUpdate {
	uu.mutation.SetStatus(u)
	return uu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (uu *UserUpdate) SetNillableStatus(u *user.Status) *UserUpdate {
	if u != nil {
		uu.SetStatus(*u)
	}
	return uu
}

// SetRole sets the "role" field.
func (uu *UserUpdate) SetRole(u user.Role) *UserUpdate {
	uu.mutation.SetRole(u)
	return uu
}

// SetNillableRole sets the "role" field if the given value is not nil.
func (uu *UserUpdate) SetNillableRole(u *user.Role) *UserUpdate {
	if u != nil {
		uu.SetRole(*u)
	}
	return uu
}

// SetIsOnline sets the "is_online" field.
func (uu *UserUpdate) SetIsOnline(b bool) *UserUpdate {
	uu.mutation.SetIsOnline(b)
	return uu
}

// SetNillableIsOnline sets the "is_online" field if the given value is not nil.
func (uu *UserUpdate) SetNillableIsOnline(b *bool) *UserUpdate {
	if b != nil {
		uu.SetIsOnline(*b)
	}
	return uu
}

// ClearIsOnline clears the value of the "is_online" field.
func (uu *UserUpdate) ClearIsOnline() *UserUpdate {
	uu.mutation.ClearIsOnline()
	return uu
}

// SetIsShowCollections sets the "is_show_collections" field.
func (uu *UserUpdate) SetIsShowCollections(b bool) *UserUpdate {
	uu.mutation.SetIsShowCollections(b)
	return uu
}

// SetNillableIsShowCollections sets the "is_show_collections" field if the given value is not nil.
func (uu *UserUpdate) SetNillableIsShowCollections(b *bool) *UserUpdate {
	if b != nil {
		uu.SetIsShowCollections(*b)
	}
	return uu
}

// SetIsInvited sets the "is_invited" field.
func (uu *UserUpdate) SetIsInvited(b bool) *UserUpdate {
	uu.mutation.SetIsInvited(b)
	return uu
}

// SetNillableIsInvited sets the "is_invited" field if the given value is not nil.
func (uu *UserUpdate) SetNillableIsInvited(b *bool) *UserUpdate {
	if b != nil {
		uu.SetIsInvited(*b)
	}
	return uu
}

// SetNeedPrivacyConfirm sets the "need_privacy_confirm" field.
func (uu *UserUpdate) SetNeedPrivacyConfirm(b bool) *UserUpdate {
	uu.mutation.SetNeedPrivacyConfirm(b)
	return uu
}

// SetNillableNeedPrivacyConfirm sets the "need_privacy_confirm" field if the given value is not nil.
func (uu *UserUpdate) SetNillableNeedPrivacyConfirm(b *bool) *UserUpdate {
	if b != nil {
		uu.SetNeedPrivacyConfirm(*b)
	}
	return uu
}

// SetCurrentCsFieldID sets the "current_cs_field_id" field.
func (uu *UserUpdate) SetCurrentCsFieldID(u uint64) *UserUpdate {
	uu.mutation.ResetCurrentCsFieldID()
	uu.mutation.SetCurrentCsFieldID(u)
	return uu
}

// SetNillableCurrentCsFieldID sets the "current_cs_field_id" field if the given value is not nil.
func (uu *UserUpdate) SetNillableCurrentCsFieldID(u *uint64) *UserUpdate {
	if u != nil {
		uu.SetCurrentCsFieldID(*u)
	}
	return uu
}

// AddCurrentCsFieldID adds u to the "current_cs_field_id" field.
func (uu *UserUpdate) AddCurrentCsFieldID(u int64) *UserUpdate {
	uu.mutation.AddCurrentCsFieldID(u)
	return uu
}

// ClearCurrentCsFieldID clears the value of the "current_cs_field_id" field.
func (uu *UserUpdate) ClearCurrentCsFieldID() *UserUpdate {
	uu.mutation.ClearCurrentCsFieldID()
	return uu
}

// SetCurrentCsFieldName sets the "current_cs_field_name" field.
func (uu *UserUpdate) SetCurrentCsFieldName(s string) *UserUpdate {
	uu.mutation.SetCurrentCsFieldName(s)
	return uu
}

// SetNillableCurrentCsFieldName sets the "current_cs_field_name" field if the given value is not nil.
func (uu *UserUpdate) SetNillableCurrentCsFieldName(s *string) *UserUpdate {
	if s != nil {
		uu.SetCurrentCsFieldName(*s)
	}
	return uu
}

// ClearCurrentCsFieldName clears the value of the "current_cs_field_name" field.
func (uu *UserUpdate) ClearCurrentCsFieldName() *UserUpdate {
	uu.mutation.ClearCurrentCsFieldName()
	return uu
}

// SetPrivateCsFieldID sets the "private_cs_field_id" field.
func (uu *UserUpdate) SetPrivateCsFieldID(u uint64) *UserUpdate {
	uu.mutation.ResetPrivateCsFieldID()
	uu.mutation.SetPrivateCsFieldID(u)
	return uu
}

// SetNillablePrivateCsFieldID sets the "private_cs_field_id" field if the given value is not nil.
func (uu *UserUpdate) SetNillablePrivateCsFieldID(u *uint64) *UserUpdate {
	if u != nil {
		uu.SetPrivateCsFieldID(*u)
	}
	return uu
}

// AddPrivateCsFieldID adds u to the "private_cs_field_id" field.
func (uu *UserUpdate) AddPrivateCsFieldID(u int64) *UserUpdate {
	uu.mutation.AddPrivateCsFieldID(u)
	return uu
}

// ClearPrivateCsFieldID clears the value of the "private_cs_field_id" field.
func (uu *UserUpdate) ClearPrivateCsFieldID() *UserUpdate {
	uu.mutation.ClearPrivateCsFieldID()
	return uu
}

// SetPrivateCsFieldName sets the "private_cs_field_name" field.
func (uu *UserUpdate) SetPrivateCsFieldName(s string) *UserUpdate {
	uu.mutation.SetPrivateCsFieldName(s)
	return uu
}

// SetNillablePrivateCsFieldName sets the "private_cs_field_name" field if the given value is not nil.
func (uu *UserUpdate) SetNillablePrivateCsFieldName(s *string) *UserUpdate {
	if s != nil {
		uu.SetPrivateCsFieldName(*s)
	}
	return uu
}

// ClearPrivateCsFieldName clears the value of the "private_cs_field_name" field.
func (uu *UserUpdate) ClearPrivateCsFieldName() *UserUpdate {
	uu.mutation.ClearPrivateCsFieldName()
	return uu
}

// SetRegisterIP sets the "register_ip" field.
func (uu *UserUpdate) SetRegisterIP(s string) *UserUpdate {
	uu.mutation.SetRegisterIP(s)
	return uu
}

// SetNillableRegisterIP sets the "register_ip" field if the given value is not nil.
func (uu *UserUpdate) SetNillableRegisterIP(s *string) *UserUpdate {
	if s != nil {
		uu.SetRegisterIP(*s)
	}
	return uu
}

// ClearRegisterIP clears the value of the "register_ip" field.
func (uu *UserUpdate) ClearRegisterIP() *UserUpdate {
	uu.mutation.ClearRegisterIP()
	return uu
}

// SetConstellation sets the "constellation" field.
func (uu *UserUpdate) SetConstellation(s string) *UserUpdate {
	uu.mutation.SetConstellation(s)
	return uu
}

// SetNillableConstellation sets the "constellation" field if the given value is not nil.
func (uu *UserUpdate) SetNillableConstellation(s *string) *UserUpdate {
	if s != nil {
		uu.SetConstellation(*s)
	}
	return uu
}

// ClearConstellation clears the value of the "constellation" field.
func (uu *UserUpdate) ClearConstellation() *UserUpdate {
	uu.mutation.ClearConstellation()
	return uu
}

// SetTotalConnections sets the "total_connections" field.
func (uu *UserUpdate) SetTotalConnections(i int) *UserUpdate {
	uu.mutation.ResetTotalConnections()
	uu.mutation.SetTotalConnections(i)
	return uu
}

// SetNillableTotalConnections sets the "total_connections" field if the given value is not nil.
func (uu *UserUpdate) SetNillableTotalConnections(i *int) *UserUpdate {
	if i != nil {
		uu.SetTotalConnections(*i)
	}
	return uu
}

// AddTotalConnections adds i to the "total_connections" field.
func (uu *UserUpdate) AddTotalConnections(i int) *UserUpdate {
	uu.mutation.AddTotalConnections(i)
	return uu
}

// ClearTotalConnections clears the value of the "total_connections" field.
func (uu *UserUpdate) ClearTotalConnections() *UserUpdate {
	uu.mutation.ClearTotalConnections()
	return uu
}

// AddUserAuthIDs adds the "user_auth" edge to the User_auth entity by IDs.
func (uu *UserUpdate) AddUserAuthIDs(ids ...int) *UserUpdate {
	uu.mutation.AddUserAuthIDs(ids...)
	return uu
}

// AddUserAuth adds the "user_auth" edges to the User_auth entity.
func (uu *UserUpdate) AddUserAuth(u ...*User_auth) *UserUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.AddUserAuthIDs(ids...)
}

// AddCardIDs adds the "card" edge to the Card entity by IDs.
func (uu *UserUpdate) AddCardIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddCardIDs(ids...)
	return uu
}

// AddCard adds the "card" edges to the Card entity.
func (uu *UserUpdate) AddCard(c ...*Card) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.AddCardIDs(ids...)
}

// AddMessageIDs adds the "message" edge to the Message entity by IDs.
func (uu *UserUpdate) AddMessageIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddMessageIDs(ids...)
	return uu
}

// AddMessage adds the "message" edges to the Message entity.
func (uu *UserUpdate) AddMessage(m ...*Message) *UserUpdate {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uu.AddMessageIDs(ids...)
}

// AddDeviceIDs adds the "device" edge to the Device entity by IDs.
func (uu *UserUpdate) AddDeviceIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddDeviceIDs(ids...)
	return uu
}

// AddDevice adds the "device" edges to the Device entity.
func (uu *UserUpdate) AddDevice(d ...*Device) *UserUpdate {
	ids := make([]uint64, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return uu.AddDeviceIDs(ids...)
}

// AddJoinedCsfieldIDs adds the "joined_csfield" edge to the CSField entity by IDs.
func (uu *UserUpdate) AddJoinedCsfieldIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddJoinedCsfieldIDs(ids...)
	return uu
}

// AddJoinedCsfield adds the "joined_csfield" edges to the CSField entity.
func (uu *UserUpdate) AddJoinedCsfield(c ...*CSField) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.AddJoinedCsfieldIDs(ids...)
}

// AddFriendIDs adds the "friends" edge to the User entity by IDs.
func (uu *UserUpdate) AddFriendIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddFriendIDs(ids...)
	return uu
}

// AddFriends adds the "friends" edges to the User entity.
func (uu *UserUpdate) AddFriends(u ...*User) *UserUpdate {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.AddFriendIDs(ids...)
}

// AddHiddenIDs adds the "hidden" edge to the Hidden entity by IDs.
func (uu *UserUpdate) AddHiddenIDs(ids ...int) *UserUpdate {
	uu.mutation.AddHiddenIDs(ids...)
	return uu
}

// AddHidden adds the "hidden" edges to the Hidden entity.
func (uu *UserUpdate) AddHidden(h ...*Hidden) *UserUpdate {
	ids := make([]int, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return uu.AddHiddenIDs(ids...)
}

// AddHistoryIDs adds the "history" edge to the User_history entity by IDs.
func (uu *UserUpdate) AddHistoryIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddHistoryIDs(ids...)
	return uu
}

// AddHistory adds the "history" edges to the User_history entity.
func (uu *UserUpdate) AddHistory(u ...*User_history) *UserUpdate {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.AddHistoryIDs(ids...)
}

// AddTokenIDs adds the "token" edge to the Agora_token entity by IDs.
func (uu *UserUpdate) AddTokenIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddTokenIDs(ids...)
	return uu
}

// AddToken adds the "token" edges to the Agora_token entity.
func (uu *UserUpdate) AddToken(a ...*Agora_token) *UserUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uu.AddTokenIDs(ids...)
}

// AddCreationIDs adds the "creation" edge to the Creation entity by IDs.
func (uu *UserUpdate) AddCreationIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddCreationIDs(ids...)
	return uu
}

// AddCreation adds the "creation" edges to the Creation entity.
func (uu *UserUpdate) AddCreation(c ...*Creation) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.AddCreationIDs(ids...)
}

// AddContactIDs adds the "contact" edge to the Contact entity by IDs.
func (uu *UserUpdate) AddContactIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddContactIDs(ids...)
	return uu
}

// AddContact adds the "contact" edges to the Contact entity.
func (uu *UserUpdate) AddContact(c ...*Contact) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.AddContactIDs(ids...)
}

// AddSettingIDs adds the "setting" edge to the Setting entity by IDs.
func (uu *UserUpdate) AddSettingIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddSettingIDs(ids...)
	return uu
}

// AddSetting adds the "setting" edges to the Setting entity.
func (uu *UserUpdate) AddSetting(s ...*Setting) *UserUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uu.AddSettingIDs(ids...)
}

// AddNftIDs adds the "nft" edge to the NFT entity by IDs.
func (uu *UserUpdate) AddNftIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddNftIDs(ids...)
	return uu
}

// AddNft adds the "nft" edges to the NFT entity.
func (uu *UserUpdate) AddNft(n ...*NFT) *UserUpdate {
	ids := make([]uint64, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return uu.AddNftIDs(ids...)
}

// AddStreamIDs adds the "stream" edge to the Stream entity by IDs.
func (uu *UserUpdate) AddStreamIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddStreamIDs(ids...)
	return uu
}

// AddStream adds the "stream" edges to the Stream entity.
func (uu *UserUpdate) AddStream(s ...*Stream) *UserUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uu.AddStreamIDs(ids...)
}

// AddMaskIDs adds the "mask" edge to the Mask entity by IDs.
func (uu *UserUpdate) AddMaskIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddMaskIDs(ids...)
	return uu
}

// AddMask adds the "mask" edges to the Mask entity.
func (uu *UserUpdate) AddMask(m ...*Mask) *UserUpdate {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uu.AddMaskIDs(ids...)
}

// AddTimedewIDs adds the "timedew" edge to the TimeDew entity by IDs.
func (uu *UserUpdate) AddTimedewIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddTimedewIDs(ids...)
	return uu
}

// AddTimedew adds the "timedew" edges to the TimeDew entity.
func (uu *UserUpdate) AddTimedew(t ...*TimeDew) *UserUpdate {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.AddTimedewIDs(ids...)
}

// AddCollectionIDs adds the "collection" edge to the Collection entity by IDs.
func (uu *UserUpdate) AddCollectionIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddCollectionIDs(ids...)
	return uu
}

// AddCollection adds the "collection" edges to the Collection entity.
func (uu *UserUpdate) AddCollection(c ...*Collection) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.AddCollectionIDs(ids...)
}

// AddInviteCodeIDs adds the "invite_code" edge to the Invite_Code entity by IDs.
func (uu *UserUpdate) AddInviteCodeIDs(ids ...int) *UserUpdate {
	uu.mutation.AddInviteCodeIDs(ids...)
	return uu
}

// AddInviteCode adds the "invite_code" edges to the Invite_Code entity.
func (uu *UserUpdate) AddInviteCode(i ...*Invite_Code) *UserUpdate {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return uu.AddInviteCodeIDs(ids...)
}

// AddFeedbackIDs adds the "feedback" edge to the Feedback entity by IDs.
func (uu *UserUpdate) AddFeedbackIDs(ids ...int) *UserUpdate {
	uu.mutation.AddFeedbackIDs(ids...)
	return uu
}

// AddFeedback adds the "feedback" edges to the Feedback entity.
func (uu *UserUpdate) AddFeedback(f ...*Feedback) *UserUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uu.AddFeedbackIDs(ids...)
}

// AddReactionTimedewIDs adds the "reaction_timedew" edge to the TimeDew entity by IDs.
func (uu *UserUpdate) AddReactionTimedewIDs(ids ...uint64) *UserUpdate {
	uu.mutation.AddReactionTimedewIDs(ids...)
	return uu
}

// AddReactionTimedew adds the "reaction_timedew" edges to the TimeDew entity.
func (uu *UserUpdate) AddReactionTimedew(t ...*TimeDew) *UserUpdate {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.AddReactionTimedewIDs(ids...)
}

// AddJoinIDs adds the "joins" edge to the Join entity by IDs.
func (uu *UserUpdate) AddJoinIDs(ids ...int) *UserUpdate {
	uu.mutation.AddJoinIDs(ids...)
	return uu
}

// AddJoins adds the "joins" edges to the Join entity.
func (uu *UserUpdate) AddJoins(j ...*Join) *UserUpdate {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return uu.AddJoinIDs(ids...)
}

// AddFriendshipIDs adds the "friendships" edge to the Friendship entity by IDs.
func (uu *UserUpdate) AddFriendshipIDs(ids ...int) *UserUpdate {
	uu.mutation.AddFriendshipIDs(ids...)
	return uu
}

// AddFriendships adds the "friendships" edges to the Friendship entity.
func (uu *UserUpdate) AddFriendships(f ...*Friendship) *UserUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uu.AddFriendshipIDs(ids...)
}

// AddReactionIDs adds the "reactions" edge to the Reaction entity by IDs.
func (uu *UserUpdate) AddReactionIDs(ids ...int) *UserUpdate {
	uu.mutation.AddReactionIDs(ids...)
	return uu
}

// AddReactions adds the "reactions" edges to the Reaction entity.
func (uu *UserUpdate) AddReactions(r ...*Reaction) *UserUpdate {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return uu.AddReactionIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uu *UserUpdate) Mutation() *UserMutation {
	return uu.mutation
}

// ClearUserAuth clears all "user_auth" edges to the User_auth entity.
func (uu *UserUpdate) ClearUserAuth() *UserUpdate {
	uu.mutation.ClearUserAuth()
	return uu
}

// RemoveUserAuthIDs removes the "user_auth" edge to User_auth entities by IDs.
func (uu *UserUpdate) RemoveUserAuthIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveUserAuthIDs(ids...)
	return uu
}

// RemoveUserAuth removes "user_auth" edges to User_auth entities.
func (uu *UserUpdate) RemoveUserAuth(u ...*User_auth) *UserUpdate {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.RemoveUserAuthIDs(ids...)
}

// ClearCard clears all "card" edges to the Card entity.
func (uu *UserUpdate) ClearCard() *UserUpdate {
	uu.mutation.ClearCard()
	return uu
}

// RemoveCardIDs removes the "card" edge to Card entities by IDs.
func (uu *UserUpdate) RemoveCardIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveCardIDs(ids...)
	return uu
}

// RemoveCard removes "card" edges to Card entities.
func (uu *UserUpdate) RemoveCard(c ...*Card) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.RemoveCardIDs(ids...)
}

// ClearMessage clears all "message" edges to the Message entity.
func (uu *UserUpdate) ClearMessage() *UserUpdate {
	uu.mutation.ClearMessage()
	return uu
}

// RemoveMessageIDs removes the "message" edge to Message entities by IDs.
func (uu *UserUpdate) RemoveMessageIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveMessageIDs(ids...)
	return uu
}

// RemoveMessage removes "message" edges to Message entities.
func (uu *UserUpdate) RemoveMessage(m ...*Message) *UserUpdate {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uu.RemoveMessageIDs(ids...)
}

// ClearDevice clears all "device" edges to the Device entity.
func (uu *UserUpdate) ClearDevice() *UserUpdate {
	uu.mutation.ClearDevice()
	return uu
}

// RemoveDeviceIDs removes the "device" edge to Device entities by IDs.
func (uu *UserUpdate) RemoveDeviceIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveDeviceIDs(ids...)
	return uu
}

// RemoveDevice removes "device" edges to Device entities.
func (uu *UserUpdate) RemoveDevice(d ...*Device) *UserUpdate {
	ids := make([]uint64, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return uu.RemoveDeviceIDs(ids...)
}

// ClearJoinedCsfield clears all "joined_csfield" edges to the CSField entity.
func (uu *UserUpdate) ClearJoinedCsfield() *UserUpdate {
	uu.mutation.ClearJoinedCsfield()
	return uu
}

// RemoveJoinedCsfieldIDs removes the "joined_csfield" edge to CSField entities by IDs.
func (uu *UserUpdate) RemoveJoinedCsfieldIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveJoinedCsfieldIDs(ids...)
	return uu
}

// RemoveJoinedCsfield removes "joined_csfield" edges to CSField entities.
func (uu *UserUpdate) RemoveJoinedCsfield(c ...*CSField) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.RemoveJoinedCsfieldIDs(ids...)
}

// ClearFriends clears all "friends" edges to the User entity.
func (uu *UserUpdate) ClearFriends() *UserUpdate {
	uu.mutation.ClearFriends()
	return uu
}

// RemoveFriendIDs removes the "friends" edge to User entities by IDs.
func (uu *UserUpdate) RemoveFriendIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveFriendIDs(ids...)
	return uu
}

// RemoveFriends removes "friends" edges to User entities.
func (uu *UserUpdate) RemoveFriends(u ...*User) *UserUpdate {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.RemoveFriendIDs(ids...)
}

// ClearHidden clears all "hidden" edges to the Hidden entity.
func (uu *UserUpdate) ClearHidden() *UserUpdate {
	uu.mutation.ClearHidden()
	return uu
}

// RemoveHiddenIDs removes the "hidden" edge to Hidden entities by IDs.
func (uu *UserUpdate) RemoveHiddenIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveHiddenIDs(ids...)
	return uu
}

// RemoveHidden removes "hidden" edges to Hidden entities.
func (uu *UserUpdate) RemoveHidden(h ...*Hidden) *UserUpdate {
	ids := make([]int, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return uu.RemoveHiddenIDs(ids...)
}

// ClearHistory clears all "history" edges to the User_history entity.
func (uu *UserUpdate) ClearHistory() *UserUpdate {
	uu.mutation.ClearHistory()
	return uu
}

// RemoveHistoryIDs removes the "history" edge to User_history entities by IDs.
func (uu *UserUpdate) RemoveHistoryIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveHistoryIDs(ids...)
	return uu
}

// RemoveHistory removes "history" edges to User_history entities.
func (uu *UserUpdate) RemoveHistory(u ...*User_history) *UserUpdate {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uu.RemoveHistoryIDs(ids...)
}

// ClearToken clears all "token" edges to the Agora_token entity.
func (uu *UserUpdate) ClearToken() *UserUpdate {
	uu.mutation.ClearToken()
	return uu
}

// RemoveTokenIDs removes the "token" edge to Agora_token entities by IDs.
func (uu *UserUpdate) RemoveTokenIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveTokenIDs(ids...)
	return uu
}

// RemoveToken removes "token" edges to Agora_token entities.
func (uu *UserUpdate) RemoveToken(a ...*Agora_token) *UserUpdate {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uu.RemoveTokenIDs(ids...)
}

// ClearCreation clears all "creation" edges to the Creation entity.
func (uu *UserUpdate) ClearCreation() *UserUpdate {
	uu.mutation.ClearCreation()
	return uu
}

// RemoveCreationIDs removes the "creation" edge to Creation entities by IDs.
func (uu *UserUpdate) RemoveCreationIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveCreationIDs(ids...)
	return uu
}

// RemoveCreation removes "creation" edges to Creation entities.
func (uu *UserUpdate) RemoveCreation(c ...*Creation) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.RemoveCreationIDs(ids...)
}

// ClearContact clears all "contact" edges to the Contact entity.
func (uu *UserUpdate) ClearContact() *UserUpdate {
	uu.mutation.ClearContact()
	return uu
}

// RemoveContactIDs removes the "contact" edge to Contact entities by IDs.
func (uu *UserUpdate) RemoveContactIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveContactIDs(ids...)
	return uu
}

// RemoveContact removes "contact" edges to Contact entities.
func (uu *UserUpdate) RemoveContact(c ...*Contact) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.RemoveContactIDs(ids...)
}

// ClearSetting clears all "setting" edges to the Setting entity.
func (uu *UserUpdate) ClearSetting() *UserUpdate {
	uu.mutation.ClearSetting()
	return uu
}

// RemoveSettingIDs removes the "setting" edge to Setting entities by IDs.
func (uu *UserUpdate) RemoveSettingIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveSettingIDs(ids...)
	return uu
}

// RemoveSetting removes "setting" edges to Setting entities.
func (uu *UserUpdate) RemoveSetting(s ...*Setting) *UserUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uu.RemoveSettingIDs(ids...)
}

// ClearNft clears all "nft" edges to the NFT entity.
func (uu *UserUpdate) ClearNft() *UserUpdate {
	uu.mutation.ClearNft()
	return uu
}

// RemoveNftIDs removes the "nft" edge to NFT entities by IDs.
func (uu *UserUpdate) RemoveNftIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveNftIDs(ids...)
	return uu
}

// RemoveNft removes "nft" edges to NFT entities.
func (uu *UserUpdate) RemoveNft(n ...*NFT) *UserUpdate {
	ids := make([]uint64, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return uu.RemoveNftIDs(ids...)
}

// ClearStream clears all "stream" edges to the Stream entity.
func (uu *UserUpdate) ClearStream() *UserUpdate {
	uu.mutation.ClearStream()
	return uu
}

// RemoveStreamIDs removes the "stream" edge to Stream entities by IDs.
func (uu *UserUpdate) RemoveStreamIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveStreamIDs(ids...)
	return uu
}

// RemoveStream removes "stream" edges to Stream entities.
func (uu *UserUpdate) RemoveStream(s ...*Stream) *UserUpdate {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uu.RemoveStreamIDs(ids...)
}

// ClearMask clears all "mask" edges to the Mask entity.
func (uu *UserUpdate) ClearMask() *UserUpdate {
	uu.mutation.ClearMask()
	return uu
}

// RemoveMaskIDs removes the "mask" edge to Mask entities by IDs.
func (uu *UserUpdate) RemoveMaskIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveMaskIDs(ids...)
	return uu
}

// RemoveMask removes "mask" edges to Mask entities.
func (uu *UserUpdate) RemoveMask(m ...*Mask) *UserUpdate {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uu.RemoveMaskIDs(ids...)
}

// ClearTimedew clears all "timedew" edges to the TimeDew entity.
func (uu *UserUpdate) ClearTimedew() *UserUpdate {
	uu.mutation.ClearTimedew()
	return uu
}

// RemoveTimedewIDs removes the "timedew" edge to TimeDew entities by IDs.
func (uu *UserUpdate) RemoveTimedewIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveTimedewIDs(ids...)
	return uu
}

// RemoveTimedew removes "timedew" edges to TimeDew entities.
func (uu *UserUpdate) RemoveTimedew(t ...*TimeDew) *UserUpdate {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.RemoveTimedewIDs(ids...)
}

// ClearCollection clears all "collection" edges to the Collection entity.
func (uu *UserUpdate) ClearCollection() *UserUpdate {
	uu.mutation.ClearCollection()
	return uu
}

// RemoveCollectionIDs removes the "collection" edge to Collection entities by IDs.
func (uu *UserUpdate) RemoveCollectionIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveCollectionIDs(ids...)
	return uu
}

// RemoveCollection removes "collection" edges to Collection entities.
func (uu *UserUpdate) RemoveCollection(c ...*Collection) *UserUpdate {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uu.RemoveCollectionIDs(ids...)
}

// ClearInviteCode clears all "invite_code" edges to the Invite_Code entity.
func (uu *UserUpdate) ClearInviteCode() *UserUpdate {
	uu.mutation.ClearInviteCode()
	return uu
}

// RemoveInviteCodeIDs removes the "invite_code" edge to Invite_Code entities by IDs.
func (uu *UserUpdate) RemoveInviteCodeIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveInviteCodeIDs(ids...)
	return uu
}

// RemoveInviteCode removes "invite_code" edges to Invite_Code entities.
func (uu *UserUpdate) RemoveInviteCode(i ...*Invite_Code) *UserUpdate {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return uu.RemoveInviteCodeIDs(ids...)
}

// ClearFeedback clears all "feedback" edges to the Feedback entity.
func (uu *UserUpdate) ClearFeedback() *UserUpdate {
	uu.mutation.ClearFeedback()
	return uu
}

// RemoveFeedbackIDs removes the "feedback" edge to Feedback entities by IDs.
func (uu *UserUpdate) RemoveFeedbackIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveFeedbackIDs(ids...)
	return uu
}

// RemoveFeedback removes "feedback" edges to Feedback entities.
func (uu *UserUpdate) RemoveFeedback(f ...*Feedback) *UserUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uu.RemoveFeedbackIDs(ids...)
}

// ClearReactionTimedew clears all "reaction_timedew" edges to the TimeDew entity.
func (uu *UserUpdate) ClearReactionTimedew() *UserUpdate {
	uu.mutation.ClearReactionTimedew()
	return uu
}

// RemoveReactionTimedewIDs removes the "reaction_timedew" edge to TimeDew entities by IDs.
func (uu *UserUpdate) RemoveReactionTimedewIDs(ids ...uint64) *UserUpdate {
	uu.mutation.RemoveReactionTimedewIDs(ids...)
	return uu
}

// RemoveReactionTimedew removes "reaction_timedew" edges to TimeDew entities.
func (uu *UserUpdate) RemoveReactionTimedew(t ...*TimeDew) *UserUpdate {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uu.RemoveReactionTimedewIDs(ids...)
}

// ClearJoins clears all "joins" edges to the Join entity.
func (uu *UserUpdate) ClearJoins() *UserUpdate {
	uu.mutation.ClearJoins()
	return uu
}

// RemoveJoinIDs removes the "joins" edge to Join entities by IDs.
func (uu *UserUpdate) RemoveJoinIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveJoinIDs(ids...)
	return uu
}

// RemoveJoins removes "joins" edges to Join entities.
func (uu *UserUpdate) RemoveJoins(j ...*Join) *UserUpdate {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return uu.RemoveJoinIDs(ids...)
}

// ClearFriendships clears all "friendships" edges to the Friendship entity.
func (uu *UserUpdate) ClearFriendships() *UserUpdate {
	uu.mutation.ClearFriendships()
	return uu
}

// RemoveFriendshipIDs removes the "friendships" edge to Friendship entities by IDs.
func (uu *UserUpdate) RemoveFriendshipIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveFriendshipIDs(ids...)
	return uu
}

// RemoveFriendships removes "friendships" edges to Friendship entities.
func (uu *UserUpdate) RemoveFriendships(f ...*Friendship) *UserUpdate {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uu.RemoveFriendshipIDs(ids...)
}

// ClearReactions clears all "reactions" edges to the Reaction entity.
func (uu *UserUpdate) ClearReactions() *UserUpdate {
	uu.mutation.ClearReactions()
	return uu
}

// RemoveReactionIDs removes the "reactions" edge to Reaction entities by IDs.
func (uu *UserUpdate) RemoveReactionIDs(ids ...int) *UserUpdate {
	uu.mutation.RemoveReactionIDs(ids...)
	return uu
}

// RemoveReactions removes "reactions" edges to Reaction entities.
func (uu *UserUpdate) RemoveReactions(r ...*Reaction) *UserUpdate {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return uu.RemoveReactionIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (uu *UserUpdate) Save(ctx context.Context) (int, error) {
	var (
		err      error
		affected int
	)
	uu.defaults()
	if len(uu.hooks) == 0 {
		if err = uu.check(); err != nil {
			return 0, err
		}
		affected, err = uu.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*UserMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = uu.check(); err != nil {
				return 0, err
			}
			uu.mutation = mutation
			affected, err = uu.sqlSave(ctx)
			mutation.done = true
			return affected, err
		})
		for i := len(uu.hooks) - 1; i >= 0; i-- {
			if uu.hooks[i] == nil {
				return 0, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = uu.hooks[i](mut)
		}
		if _, err := mut.Mutate(ctx, uu.mutation); err != nil {
			return 0, err
		}
	}
	return affected, err
}

// SaveX is like Save, but panics if an error occurs.
func (uu *UserUpdate) SaveX(ctx context.Context) int {
	affected, err := uu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (uu *UserUpdate) Exec(ctx context.Context) error {
	_, err := uu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uu *UserUpdate) ExecX(ctx context.Context) {
	if err := uu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (uu *UserUpdate) defaults() {
	if _, ok := uu.mutation.UpdateTime(); !ok {
		v := user.UpdateDefaultUpdateTime()
		uu.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (uu *UserUpdate) check() error {
	if v, ok := uu.mutation.Status(); ok {
		if err := user.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`ent: validator failed for field "User.status": %w`, err)}
		}
	}
	if v, ok := uu.mutation.Role(); ok {
		if err := user.RoleValidator(v); err != nil {
			return &ValidationError{Name: "role", err: fmt.Errorf(`ent: validator failed for field "User.role": %w`, err)}
		}
	}
	return nil
}

func (uu *UserUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUint64,
				Column: user.FieldID,
			},
		},
	}
	if ps := uu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uu.mutation.UpdateTime(); ok {
		_spec.SetField(user.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := uu.mutation.OpenID(); ok {
		_spec.SetField(user.FieldOpenID, field.TypeString, value)
	}
	if uu.mutation.OpenIDCleared() {
		_spec.ClearField(user.FieldOpenID, field.TypeString)
	}
	if value, ok := uu.mutation.Name(); ok {
		_spec.SetField(user.FieldName, field.TypeString, value)
	}
	if uu.mutation.NameCleared() {
		_spec.ClearField(user.FieldName, field.TypeString)
	}
	if value, ok := uu.mutation.NickName(); ok {
		_spec.SetField(user.FieldNickName, field.TypeString, value)
	}
	if uu.mutation.NickNameCleared() {
		_spec.ClearField(user.FieldNickName, field.TypeString)
	}
	if value, ok := uu.mutation.SystemName(); ok {
		_spec.SetField(user.FieldSystemName, field.TypeString, value)
	}
	if uu.mutation.SystemNameCleared() {
		_spec.ClearField(user.FieldSystemName, field.TypeString)
	}
	if value, ok := uu.mutation.Avatar(); ok {
		_spec.SetField(user.FieldAvatar, field.TypeString, value)
	}
	if uu.mutation.AvatarCleared() {
		_spec.ClearField(user.FieldAvatar, field.TypeString)
	}
	if value, ok := uu.mutation.ThumbnailURL(); ok {
		_spec.SetField(user.FieldThumbnailURL, field.TypeString, value)
	}
	if value, ok := uu.mutation.Sex(); ok {
		_spec.SetField(user.FieldSex, field.TypeString, value)
	}
	if uu.mutation.SexCleared() {
		_spec.ClearField(user.FieldSex, field.TypeString)
	}
	if value, ok := uu.mutation.MobileNo(); ok {
		_spec.SetField(user.FieldMobileNo, field.TypeString, value)
	}
	if uu.mutation.MobileNoCleared() {
		_spec.ClearField(user.FieldMobileNo, field.TypeString)
	}
	if value, ok := uu.mutation.RegionCode(); ok {
		_spec.SetField(user.FieldRegionCode, field.TypeString, value)
	}
	if uu.mutation.RegionCodeCleared() {
		_spec.ClearField(user.FieldRegionCode, field.TypeString)
	}
	if value, ok := uu.mutation.EmailAddress(); ok {
		_spec.SetField(user.FieldEmailAddress, field.TypeString, value)
	}
	if uu.mutation.EmailAddressCleared() {
		_spec.ClearField(user.FieldEmailAddress, field.TypeString)
	}
	if value, ok := uu.mutation.Birthday(); ok {
		_spec.SetField(user.FieldBirthday, field.TypeString, value)
	}
	if uu.mutation.BirthdayCleared() {
		_spec.ClearField(user.FieldBirthday, field.TypeString)
	}
	if value, ok := uu.mutation.SchoolName(); ok {
		_spec.SetField(user.FieldSchoolName, field.TypeString, value)
	}
	if uu.mutation.SchoolNameCleared() {
		_spec.ClearField(user.FieldSchoolName, field.TypeString)
	}
	if value, ok := uu.mutation.Bio(); ok {
		_spec.SetField(user.FieldBio, field.TypeString, value)
	}
	if uu.mutation.BioCleared() {
		_spec.ClearField(user.FieldBio, field.TypeString)
	}
	if value, ok := uu.mutation.Status(); ok {
		_spec.SetField(user.FieldStatus, field.TypeEnum, value)
	}
	if value, ok := uu.mutation.Role(); ok {
		_spec.SetField(user.FieldRole, field.TypeEnum, value)
	}
	if value, ok := uu.mutation.IsOnline(); ok {
		_spec.SetField(user.FieldIsOnline, field.TypeBool, value)
	}
	if uu.mutation.IsOnlineCleared() {
		_spec.ClearField(user.FieldIsOnline, field.TypeBool)
	}
	if value, ok := uu.mutation.IsShowCollections(); ok {
		_spec.SetField(user.FieldIsShowCollections, field.TypeBool, value)
	}
	if value, ok := uu.mutation.IsInvited(); ok {
		_spec.SetField(user.FieldIsInvited, field.TypeBool, value)
	}
	if value, ok := uu.mutation.NeedPrivacyConfirm(); ok {
		_spec.SetField(user.FieldNeedPrivacyConfirm, field.TypeBool, value)
	}
	if value, ok := uu.mutation.CurrentCsFieldID(); ok {
		_spec.SetField(user.FieldCurrentCsFieldID, field.TypeUint64, value)
	}
	if value, ok := uu.mutation.AddedCurrentCsFieldID(); ok {
		_spec.AddField(user.FieldCurrentCsFieldID, field.TypeUint64, value)
	}
	if uu.mutation.CurrentCsFieldIDCleared() {
		_spec.ClearField(user.FieldCurrentCsFieldID, field.TypeUint64)
	}
	if value, ok := uu.mutation.CurrentCsFieldName(); ok {
		_spec.SetField(user.FieldCurrentCsFieldName, field.TypeString, value)
	}
	if uu.mutation.CurrentCsFieldNameCleared() {
		_spec.ClearField(user.FieldCurrentCsFieldName, field.TypeString)
	}
	if value, ok := uu.mutation.PrivateCsFieldID(); ok {
		_spec.SetField(user.FieldPrivateCsFieldID, field.TypeUint64, value)
	}
	if value, ok := uu.mutation.AddedPrivateCsFieldID(); ok {
		_spec.AddField(user.FieldPrivateCsFieldID, field.TypeUint64, value)
	}
	if uu.mutation.PrivateCsFieldIDCleared() {
		_spec.ClearField(user.FieldPrivateCsFieldID, field.TypeUint64)
	}
	if value, ok := uu.mutation.PrivateCsFieldName(); ok {
		_spec.SetField(user.FieldPrivateCsFieldName, field.TypeString, value)
	}
	if uu.mutation.PrivateCsFieldNameCleared() {
		_spec.ClearField(user.FieldPrivateCsFieldName, field.TypeString)
	}
	if value, ok := uu.mutation.RegisterIP(); ok {
		_spec.SetField(user.FieldRegisterIP, field.TypeString, value)
	}
	if uu.mutation.RegisterIPCleared() {
		_spec.ClearField(user.FieldRegisterIP, field.TypeString)
	}
	if value, ok := uu.mutation.Constellation(); ok {
		_spec.SetField(user.FieldConstellation, field.TypeString, value)
	}
	if uu.mutation.ConstellationCleared() {
		_spec.ClearField(user.FieldConstellation, field.TypeString)
	}
	if value, ok := uu.mutation.TotalConnections(); ok {
		_spec.SetField(user.FieldTotalConnections, field.TypeInt, value)
	}
	if value, ok := uu.mutation.AddedTotalConnections(); ok {
		_spec.AddField(user.FieldTotalConnections, field.TypeInt, value)
	}
	if uu.mutation.TotalConnectionsCleared() {
		_spec.ClearField(user.FieldTotalConnections, field.TypeInt)
	}
	if uu.mutation.UserAuthCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserAuthTable,
			Columns: []string{user.UserAuthColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user_auth.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedUserAuthIDs(); len(nodes) > 0 && !uu.mutation.UserAuthCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserAuthTable,
			Columns: []string{user.UserAuthColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user_auth.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.UserAuthIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserAuthTable,
			Columns: []string{user.UserAuthColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user_auth.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.CardCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CardTable,
			Columns: []string{user.CardColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: card.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedCardIDs(); len(nodes) > 0 && !uu.mutation.CardCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CardTable,
			Columns: []string{user.CardColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: card.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.CardIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CardTable,
			Columns: []string{user.CardColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: card.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.MessageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MessageTable,
			Columns: []string{user.MessageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: message.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedMessageIDs(); len(nodes) > 0 && !uu.mutation.MessageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MessageTable,
			Columns: []string{user.MessageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.MessageIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MessageTable,
			Columns: []string{user.MessageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.DeviceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceTable,
			Columns: []string{user.DeviceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: device.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedDeviceIDs(); len(nodes) > 0 && !uu.mutation.DeviceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceTable,
			Columns: []string{user.DeviceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: device.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.DeviceIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceTable,
			Columns: []string{user.DeviceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: device.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.JoinedCsfieldCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.JoinedCsfieldTable,
			Columns: user.JoinedCsfieldPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: csfield.FieldID,
				},
			},
		}
		createE := &JoinCreate{config: uu.config, mutation: newJoinMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedJoinedCsfieldIDs(); len(nodes) > 0 && !uu.mutation.JoinedCsfieldCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.JoinedCsfieldTable,
			Columns: user.JoinedCsfieldPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: csfield.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &JoinCreate{config: uu.config, mutation: newJoinMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.JoinedCsfieldIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.JoinedCsfieldTable,
			Columns: user.JoinedCsfieldPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: csfield.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &JoinCreate{config: uu.config, mutation: newJoinMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.FriendsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.FriendsTable,
			Columns: user.FriendsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user.FieldID,
				},
			},
		}
		createE := &FriendshipCreate{config: uu.config, mutation: newFriendshipMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedFriendsIDs(); len(nodes) > 0 && !uu.mutation.FriendsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.FriendsTable,
			Columns: user.FriendsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &FriendshipCreate{config: uu.config, mutation: newFriendshipMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.FriendsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.FriendsTable,
			Columns: user.FriendsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &FriendshipCreate{config: uu.config, mutation: newFriendshipMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.HiddenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HiddenTable,
			Columns: []string{user.HiddenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: hidden.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedHiddenIDs(); len(nodes) > 0 && !uu.mutation.HiddenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HiddenTable,
			Columns: []string{user.HiddenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: hidden.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.HiddenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HiddenTable,
			Columns: []string{user.HiddenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: hidden.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.HistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HistoryTable,
			Columns: []string{user.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user_history.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedHistoryIDs(); len(nodes) > 0 && !uu.mutation.HistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HistoryTable,
			Columns: []string{user.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user_history.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.HistoryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HistoryTable,
			Columns: []string{user.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user_history.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.TokenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TokenTable,
			Columns: []string{user.TokenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: agora_token.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedTokenIDs(); len(nodes) > 0 && !uu.mutation.TokenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TokenTable,
			Columns: []string{user.TokenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: agora_token.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.TokenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TokenTable,
			Columns: []string{user.TokenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: agora_token.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.CreationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreationTable,
			Columns: []string{user.CreationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: creation.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedCreationIDs(); len(nodes) > 0 && !uu.mutation.CreationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreationTable,
			Columns: []string{user.CreationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: creation.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.CreationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreationTable,
			Columns: []string{user.CreationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: creation.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.ContactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ContactTable,
			Columns: []string{user.ContactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: contact.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedContactIDs(); len(nodes) > 0 && !uu.mutation.ContactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ContactTable,
			Columns: []string{user.ContactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: contact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.ContactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ContactTable,
			Columns: []string{user.ContactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: contact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.SettingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SettingTable,
			Columns: []string{user.SettingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: setting.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedSettingIDs(); len(nodes) > 0 && !uu.mutation.SettingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SettingTable,
			Columns: []string{user.SettingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: setting.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.SettingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SettingTable,
			Columns: []string{user.SettingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: setting.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.NftCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.NftTable,
			Columns: []string{user.NftColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: nft.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedNftIDs(); len(nodes) > 0 && !uu.mutation.NftCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.NftTable,
			Columns: []string{user.NftColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: nft.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.NftIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.NftTable,
			Columns: []string{user.NftColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: nft.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.StreamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.StreamTable,
			Columns: []string{user.StreamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: stream.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedStreamIDs(); len(nodes) > 0 && !uu.mutation.StreamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.StreamTable,
			Columns: []string{user.StreamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: stream.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.StreamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.StreamTable,
			Columns: []string{user.StreamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: stream.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.MaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MaskTable,
			Columns: []string{user.MaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: mask.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedMaskIDs(); len(nodes) > 0 && !uu.mutation.MaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MaskTable,
			Columns: []string{user.MaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: mask.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.MaskIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MaskTable,
			Columns: []string{user.MaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: mask.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.TimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TimedewTable,
			Columns: []string{user.TimedewColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedTimedewIDs(); len(nodes) > 0 && !uu.mutation.TimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TimedewTable,
			Columns: []string{user.TimedewColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.TimedewIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TimedewTable,
			Columns: []string{user.TimedewColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.CollectionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CollectionTable,
			Columns: []string{user.CollectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: collection.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedCollectionIDs(); len(nodes) > 0 && !uu.mutation.CollectionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CollectionTable,
			Columns: []string{user.CollectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.CollectionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CollectionTable,
			Columns: []string{user.CollectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.InviteCodeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.InviteCodeTable,
			Columns: []string{user.InviteCodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: invite_code.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedInviteCodeIDs(); len(nodes) > 0 && !uu.mutation.InviteCodeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.InviteCodeTable,
			Columns: []string{user.InviteCodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: invite_code.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.InviteCodeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.InviteCodeTable,
			Columns: []string{user.InviteCodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: invite_code.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.FeedbackCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.FeedbackTable,
			Columns: []string{user.FeedbackColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: feedback.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedFeedbackIDs(); len(nodes) > 0 && !uu.mutation.FeedbackCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.FeedbackTable,
			Columns: []string{user.FeedbackColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: feedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.FeedbackIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.FeedbackTable,
			Columns: []string{user.FeedbackColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: feedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.ReactionTimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.ReactionTimedewTable,
			Columns: user.ReactionTimedewPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		createE := &ReactionCreate{config: uu.config, mutation: newReactionMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedReactionTimedewIDs(); len(nodes) > 0 && !uu.mutation.ReactionTimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.ReactionTimedewTable,
			Columns: user.ReactionTimedewPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: uu.config, mutation: newReactionMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.ReactionTimedewIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.ReactionTimedewTable,
			Columns: user.ReactionTimedewPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: uu.config, mutation: newReactionMutation(uu.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.JoinsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.JoinsTable,
			Columns: []string{user.JoinsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: join.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedJoinsIDs(); len(nodes) > 0 && !uu.mutation.JoinsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.JoinsTable,
			Columns: []string{user.JoinsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: join.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.JoinsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.JoinsTable,
			Columns: []string{user.JoinsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: join.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.FriendshipsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.FriendshipsTable,
			Columns: []string{user.FriendshipsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: friendship.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedFriendshipsIDs(); len(nodes) > 0 && !uu.mutation.FriendshipsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.FriendshipsTable,
			Columns: []string{user.FriendshipsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: friendship.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.FriendshipsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.FriendshipsTable,
			Columns: []string{user.FriendshipsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: friendship.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uu.mutation.ReactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.ReactionsTable,
			Columns: []string{user.ReactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: reaction.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.RemovedReactionsIDs(); len(nodes) > 0 && !uu.mutation.ReactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.ReactionsTable,
			Columns: []string{user.ReactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: reaction.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uu.mutation.ReactionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.ReactionsTable,
			Columns: []string{user.ReactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: reaction.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, uu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	return n, nil
}

// UserUpdateOne is the builder for updating a single User entity.
type UserUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *UserMutation
}

// SetUpdateTime sets the "update_time" field.
func (uuo *UserUpdateOne) SetUpdateTime(t time.Time) *UserUpdateOne {
	uuo.mutation.SetUpdateTime(t)
	return uuo
}

// SetOpenID sets the "open_id" field.
func (uuo *UserUpdateOne) SetOpenID(s string) *UserUpdateOne {
	uuo.mutation.SetOpenID(s)
	return uuo
}

// SetNillableOpenID sets the "open_id" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableOpenID(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetOpenID(*s)
	}
	return uuo
}

// ClearOpenID clears the value of the "open_id" field.
func (uuo *UserUpdateOne) ClearOpenID() *UserUpdateOne {
	uuo.mutation.ClearOpenID()
	return uuo
}

// SetName sets the "name" field.
func (uuo *UserUpdateOne) SetName(s string) *UserUpdateOne {
	uuo.mutation.SetName(s)
	return uuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableName(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetName(*s)
	}
	return uuo
}

// ClearName clears the value of the "name" field.
func (uuo *UserUpdateOne) ClearName() *UserUpdateOne {
	uuo.mutation.ClearName()
	return uuo
}

// SetNickName sets the "nick_name" field.
func (uuo *UserUpdateOne) SetNickName(s string) *UserUpdateOne {
	uuo.mutation.SetNickName(s)
	return uuo
}

// SetNillableNickName sets the "nick_name" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableNickName(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetNickName(*s)
	}
	return uuo
}

// ClearNickName clears the value of the "nick_name" field.
func (uuo *UserUpdateOne) ClearNickName() *UserUpdateOne {
	uuo.mutation.ClearNickName()
	return uuo
}

// SetSystemName sets the "system_name" field.
func (uuo *UserUpdateOne) SetSystemName(s string) *UserUpdateOne {
	uuo.mutation.SetSystemName(s)
	return uuo
}

// SetNillableSystemName sets the "system_name" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableSystemName(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetSystemName(*s)
	}
	return uuo
}

// ClearSystemName clears the value of the "system_name" field.
func (uuo *UserUpdateOne) ClearSystemName() *UserUpdateOne {
	uuo.mutation.ClearSystemName()
	return uuo
}

// SetAvatar sets the "avatar" field.
func (uuo *UserUpdateOne) SetAvatar(s string) *UserUpdateOne {
	uuo.mutation.SetAvatar(s)
	return uuo
}

// SetNillableAvatar sets the "avatar" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableAvatar(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetAvatar(*s)
	}
	return uuo
}

// ClearAvatar clears the value of the "avatar" field.
func (uuo *UserUpdateOne) ClearAvatar() *UserUpdateOne {
	uuo.mutation.ClearAvatar()
	return uuo
}

// SetThumbnailURL sets the "thumbnail_url" field.
func (uuo *UserUpdateOne) SetThumbnailURL(s string) *UserUpdateOne {
	uuo.mutation.SetThumbnailURL(s)
	return uuo
}

// SetNillableThumbnailURL sets the "thumbnail_url" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableThumbnailURL(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetThumbnailURL(*s)
	}
	return uuo
}

// SetSex sets the "sex" field.
func (uuo *UserUpdateOne) SetSex(s string) *UserUpdateOne {
	uuo.mutation.SetSex(s)
	return uuo
}

// SetNillableSex sets the "sex" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableSex(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetSex(*s)
	}
	return uuo
}

// ClearSex clears the value of the "sex" field.
func (uuo *UserUpdateOne) ClearSex() *UserUpdateOne {
	uuo.mutation.ClearSex()
	return uuo
}

// SetMobileNo sets the "mobile_no" field.
func (uuo *UserUpdateOne) SetMobileNo(s string) *UserUpdateOne {
	uuo.mutation.SetMobileNo(s)
	return uuo
}

// SetNillableMobileNo sets the "mobile_no" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableMobileNo(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetMobileNo(*s)
	}
	return uuo
}

// ClearMobileNo clears the value of the "mobile_no" field.
func (uuo *UserUpdateOne) ClearMobileNo() *UserUpdateOne {
	uuo.mutation.ClearMobileNo()
	return uuo
}

// SetRegionCode sets the "region_code" field.
func (uuo *UserUpdateOne) SetRegionCode(s string) *UserUpdateOne {
	uuo.mutation.SetRegionCode(s)
	return uuo
}

// SetNillableRegionCode sets the "region_code" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableRegionCode(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetRegionCode(*s)
	}
	return uuo
}

// ClearRegionCode clears the value of the "region_code" field.
func (uuo *UserUpdateOne) ClearRegionCode() *UserUpdateOne {
	uuo.mutation.ClearRegionCode()
	return uuo
}

// SetEmailAddress sets the "email_address" field.
func (uuo *UserUpdateOne) SetEmailAddress(s string) *UserUpdateOne {
	uuo.mutation.SetEmailAddress(s)
	return uuo
}

// SetNillableEmailAddress sets the "email_address" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableEmailAddress(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetEmailAddress(*s)
	}
	return uuo
}

// ClearEmailAddress clears the value of the "email_address" field.
func (uuo *UserUpdateOne) ClearEmailAddress() *UserUpdateOne {
	uuo.mutation.ClearEmailAddress()
	return uuo
}

// SetBirthday sets the "birthday" field.
func (uuo *UserUpdateOne) SetBirthday(s string) *UserUpdateOne {
	uuo.mutation.SetBirthday(s)
	return uuo
}

// SetNillableBirthday sets the "birthday" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableBirthday(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetBirthday(*s)
	}
	return uuo
}

// ClearBirthday clears the value of the "birthday" field.
func (uuo *UserUpdateOne) ClearBirthday() *UserUpdateOne {
	uuo.mutation.ClearBirthday()
	return uuo
}

// SetSchoolName sets the "school_name" field.
func (uuo *UserUpdateOne) SetSchoolName(s string) *UserUpdateOne {
	uuo.mutation.SetSchoolName(s)
	return uuo
}

// SetNillableSchoolName sets the "school_name" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableSchoolName(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetSchoolName(*s)
	}
	return uuo
}

// ClearSchoolName clears the value of the "school_name" field.
func (uuo *UserUpdateOne) ClearSchoolName() *UserUpdateOne {
	uuo.mutation.ClearSchoolName()
	return uuo
}

// SetBio sets the "bio" field.
func (uuo *UserUpdateOne) SetBio(s string) *UserUpdateOne {
	uuo.mutation.SetBio(s)
	return uuo
}

// SetNillableBio sets the "bio" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableBio(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetBio(*s)
	}
	return uuo
}

// ClearBio clears the value of the "bio" field.
func (uuo *UserUpdateOne) ClearBio() *UserUpdateOne {
	uuo.mutation.ClearBio()
	return uuo
}

// SetStatus sets the "status" field.
func (uuo *UserUpdateOne) SetStatus(u user.Status) *UserUpdateOne {
	uuo.mutation.SetStatus(u)
	return uuo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableStatus(u *user.Status) *UserUpdateOne {
	if u != nil {
		uuo.SetStatus(*u)
	}
	return uuo
}

// SetRole sets the "role" field.
func (uuo *UserUpdateOne) SetRole(u user.Role) *UserUpdateOne {
	uuo.mutation.SetRole(u)
	return uuo
}

// SetNillableRole sets the "role" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableRole(u *user.Role) *UserUpdateOne {
	if u != nil {
		uuo.SetRole(*u)
	}
	return uuo
}

// SetIsOnline sets the "is_online" field.
func (uuo *UserUpdateOne) SetIsOnline(b bool) *UserUpdateOne {
	uuo.mutation.SetIsOnline(b)
	return uuo
}

// SetNillableIsOnline sets the "is_online" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableIsOnline(b *bool) *UserUpdateOne {
	if b != nil {
		uuo.SetIsOnline(*b)
	}
	return uuo
}

// ClearIsOnline clears the value of the "is_online" field.
func (uuo *UserUpdateOne) ClearIsOnline() *UserUpdateOne {
	uuo.mutation.ClearIsOnline()
	return uuo
}

// SetIsShowCollections sets the "is_show_collections" field.
func (uuo *UserUpdateOne) SetIsShowCollections(b bool) *UserUpdateOne {
	uuo.mutation.SetIsShowCollections(b)
	return uuo
}

// SetNillableIsShowCollections sets the "is_show_collections" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableIsShowCollections(b *bool) *UserUpdateOne {
	if b != nil {
		uuo.SetIsShowCollections(*b)
	}
	return uuo
}

// SetIsInvited sets the "is_invited" field.
func (uuo *UserUpdateOne) SetIsInvited(b bool) *UserUpdateOne {
	uuo.mutation.SetIsInvited(b)
	return uuo
}

// SetNillableIsInvited sets the "is_invited" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableIsInvited(b *bool) *UserUpdateOne {
	if b != nil {
		uuo.SetIsInvited(*b)
	}
	return uuo
}

// SetNeedPrivacyConfirm sets the "need_privacy_confirm" field.
func (uuo *UserUpdateOne) SetNeedPrivacyConfirm(b bool) *UserUpdateOne {
	uuo.mutation.SetNeedPrivacyConfirm(b)
	return uuo
}

// SetNillableNeedPrivacyConfirm sets the "need_privacy_confirm" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableNeedPrivacyConfirm(b *bool) *UserUpdateOne {
	if b != nil {
		uuo.SetNeedPrivacyConfirm(*b)
	}
	return uuo
}

// SetCurrentCsFieldID sets the "current_cs_field_id" field.
func (uuo *UserUpdateOne) SetCurrentCsFieldID(u uint64) *UserUpdateOne {
	uuo.mutation.ResetCurrentCsFieldID()
	uuo.mutation.SetCurrentCsFieldID(u)
	return uuo
}

// SetNillableCurrentCsFieldID sets the "current_cs_field_id" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableCurrentCsFieldID(u *uint64) *UserUpdateOne {
	if u != nil {
		uuo.SetCurrentCsFieldID(*u)
	}
	return uuo
}

// AddCurrentCsFieldID adds u to the "current_cs_field_id" field.
func (uuo *UserUpdateOne) AddCurrentCsFieldID(u int64) *UserUpdateOne {
	uuo.mutation.AddCurrentCsFieldID(u)
	return uuo
}

// ClearCurrentCsFieldID clears the value of the "current_cs_field_id" field.
func (uuo *UserUpdateOne) ClearCurrentCsFieldID() *UserUpdateOne {
	uuo.mutation.ClearCurrentCsFieldID()
	return uuo
}

// SetCurrentCsFieldName sets the "current_cs_field_name" field.
func (uuo *UserUpdateOne) SetCurrentCsFieldName(s string) *UserUpdateOne {
	uuo.mutation.SetCurrentCsFieldName(s)
	return uuo
}

// SetNillableCurrentCsFieldName sets the "current_cs_field_name" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableCurrentCsFieldName(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetCurrentCsFieldName(*s)
	}
	return uuo
}

// ClearCurrentCsFieldName clears the value of the "current_cs_field_name" field.
func (uuo *UserUpdateOne) ClearCurrentCsFieldName() *UserUpdateOne {
	uuo.mutation.ClearCurrentCsFieldName()
	return uuo
}

// SetPrivateCsFieldID sets the "private_cs_field_id" field.
func (uuo *UserUpdateOne) SetPrivateCsFieldID(u uint64) *UserUpdateOne {
	uuo.mutation.ResetPrivateCsFieldID()
	uuo.mutation.SetPrivateCsFieldID(u)
	return uuo
}

// SetNillablePrivateCsFieldID sets the "private_cs_field_id" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillablePrivateCsFieldID(u *uint64) *UserUpdateOne {
	if u != nil {
		uuo.SetPrivateCsFieldID(*u)
	}
	return uuo
}

// AddPrivateCsFieldID adds u to the "private_cs_field_id" field.
func (uuo *UserUpdateOne) AddPrivateCsFieldID(u int64) *UserUpdateOne {
	uuo.mutation.AddPrivateCsFieldID(u)
	return uuo
}

// ClearPrivateCsFieldID clears the value of the "private_cs_field_id" field.
func (uuo *UserUpdateOne) ClearPrivateCsFieldID() *UserUpdateOne {
	uuo.mutation.ClearPrivateCsFieldID()
	return uuo
}

// SetPrivateCsFieldName sets the "private_cs_field_name" field.
func (uuo *UserUpdateOne) SetPrivateCsFieldName(s string) *UserUpdateOne {
	uuo.mutation.SetPrivateCsFieldName(s)
	return uuo
}

// SetNillablePrivateCsFieldName sets the "private_cs_field_name" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillablePrivateCsFieldName(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetPrivateCsFieldName(*s)
	}
	return uuo
}

// ClearPrivateCsFieldName clears the value of the "private_cs_field_name" field.
func (uuo *UserUpdateOne) ClearPrivateCsFieldName() *UserUpdateOne {
	uuo.mutation.ClearPrivateCsFieldName()
	return uuo
}

// SetRegisterIP sets the "register_ip" field.
func (uuo *UserUpdateOne) SetRegisterIP(s string) *UserUpdateOne {
	uuo.mutation.SetRegisterIP(s)
	return uuo
}

// SetNillableRegisterIP sets the "register_ip" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableRegisterIP(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetRegisterIP(*s)
	}
	return uuo
}

// ClearRegisterIP clears the value of the "register_ip" field.
func (uuo *UserUpdateOne) ClearRegisterIP() *UserUpdateOne {
	uuo.mutation.ClearRegisterIP()
	return uuo
}

// SetConstellation sets the "constellation" field.
func (uuo *UserUpdateOne) SetConstellation(s string) *UserUpdateOne {
	uuo.mutation.SetConstellation(s)
	return uuo
}

// SetNillableConstellation sets the "constellation" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableConstellation(s *string) *UserUpdateOne {
	if s != nil {
		uuo.SetConstellation(*s)
	}
	return uuo
}

// ClearConstellation clears the value of the "constellation" field.
func (uuo *UserUpdateOne) ClearConstellation() *UserUpdateOne {
	uuo.mutation.ClearConstellation()
	return uuo
}

// SetTotalConnections sets the "total_connections" field.
func (uuo *UserUpdateOne) SetTotalConnections(i int) *UserUpdateOne {
	uuo.mutation.ResetTotalConnections()
	uuo.mutation.SetTotalConnections(i)
	return uuo
}

// SetNillableTotalConnections sets the "total_connections" field if the given value is not nil.
func (uuo *UserUpdateOne) SetNillableTotalConnections(i *int) *UserUpdateOne {
	if i != nil {
		uuo.SetTotalConnections(*i)
	}
	return uuo
}

// AddTotalConnections adds i to the "total_connections" field.
func (uuo *UserUpdateOne) AddTotalConnections(i int) *UserUpdateOne {
	uuo.mutation.AddTotalConnections(i)
	return uuo
}

// ClearTotalConnections clears the value of the "total_connections" field.
func (uuo *UserUpdateOne) ClearTotalConnections() *UserUpdateOne {
	uuo.mutation.ClearTotalConnections()
	return uuo
}

// AddUserAuthIDs adds the "user_auth" edge to the User_auth entity by IDs.
func (uuo *UserUpdateOne) AddUserAuthIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddUserAuthIDs(ids...)
	return uuo
}

// AddUserAuth adds the "user_auth" edges to the User_auth entity.
func (uuo *UserUpdateOne) AddUserAuth(u ...*User_auth) *UserUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.AddUserAuthIDs(ids...)
}

// AddCardIDs adds the "card" edge to the Card entity by IDs.
func (uuo *UserUpdateOne) AddCardIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddCardIDs(ids...)
	return uuo
}

// AddCard adds the "card" edges to the Card entity.
func (uuo *UserUpdateOne) AddCard(c ...*Card) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.AddCardIDs(ids...)
}

// AddMessageIDs adds the "message" edge to the Message entity by IDs.
func (uuo *UserUpdateOne) AddMessageIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddMessageIDs(ids...)
	return uuo
}

// AddMessage adds the "message" edges to the Message entity.
func (uuo *UserUpdateOne) AddMessage(m ...*Message) *UserUpdateOne {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uuo.AddMessageIDs(ids...)
}

// AddDeviceIDs adds the "device" edge to the Device entity by IDs.
func (uuo *UserUpdateOne) AddDeviceIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddDeviceIDs(ids...)
	return uuo
}

// AddDevice adds the "device" edges to the Device entity.
func (uuo *UserUpdateOne) AddDevice(d ...*Device) *UserUpdateOne {
	ids := make([]uint64, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return uuo.AddDeviceIDs(ids...)
}

// AddJoinedCsfieldIDs adds the "joined_csfield" edge to the CSField entity by IDs.
func (uuo *UserUpdateOne) AddJoinedCsfieldIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddJoinedCsfieldIDs(ids...)
	return uuo
}

// AddJoinedCsfield adds the "joined_csfield" edges to the CSField entity.
func (uuo *UserUpdateOne) AddJoinedCsfield(c ...*CSField) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.AddJoinedCsfieldIDs(ids...)
}

// AddFriendIDs adds the "friends" edge to the User entity by IDs.
func (uuo *UserUpdateOne) AddFriendIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddFriendIDs(ids...)
	return uuo
}

// AddFriends adds the "friends" edges to the User entity.
func (uuo *UserUpdateOne) AddFriends(u ...*User) *UserUpdateOne {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.AddFriendIDs(ids...)
}

// AddHiddenIDs adds the "hidden" edge to the Hidden entity by IDs.
func (uuo *UserUpdateOne) AddHiddenIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddHiddenIDs(ids...)
	return uuo
}

// AddHidden adds the "hidden" edges to the Hidden entity.
func (uuo *UserUpdateOne) AddHidden(h ...*Hidden) *UserUpdateOne {
	ids := make([]int, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return uuo.AddHiddenIDs(ids...)
}

// AddHistoryIDs adds the "history" edge to the User_history entity by IDs.
func (uuo *UserUpdateOne) AddHistoryIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddHistoryIDs(ids...)
	return uuo
}

// AddHistory adds the "history" edges to the User_history entity.
func (uuo *UserUpdateOne) AddHistory(u ...*User_history) *UserUpdateOne {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.AddHistoryIDs(ids...)
}

// AddTokenIDs adds the "token" edge to the Agora_token entity by IDs.
func (uuo *UserUpdateOne) AddTokenIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddTokenIDs(ids...)
	return uuo
}

// AddToken adds the "token" edges to the Agora_token entity.
func (uuo *UserUpdateOne) AddToken(a ...*Agora_token) *UserUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uuo.AddTokenIDs(ids...)
}

// AddCreationIDs adds the "creation" edge to the Creation entity by IDs.
func (uuo *UserUpdateOne) AddCreationIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddCreationIDs(ids...)
	return uuo
}

// AddCreation adds the "creation" edges to the Creation entity.
func (uuo *UserUpdateOne) AddCreation(c ...*Creation) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.AddCreationIDs(ids...)
}

// AddContactIDs adds the "contact" edge to the Contact entity by IDs.
func (uuo *UserUpdateOne) AddContactIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddContactIDs(ids...)
	return uuo
}

// AddContact adds the "contact" edges to the Contact entity.
func (uuo *UserUpdateOne) AddContact(c ...*Contact) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.AddContactIDs(ids...)
}

// AddSettingIDs adds the "setting" edge to the Setting entity by IDs.
func (uuo *UserUpdateOne) AddSettingIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddSettingIDs(ids...)
	return uuo
}

// AddSetting adds the "setting" edges to the Setting entity.
func (uuo *UserUpdateOne) AddSetting(s ...*Setting) *UserUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uuo.AddSettingIDs(ids...)
}

// AddNftIDs adds the "nft" edge to the NFT entity by IDs.
func (uuo *UserUpdateOne) AddNftIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddNftIDs(ids...)
	return uuo
}

// AddNft adds the "nft" edges to the NFT entity.
func (uuo *UserUpdateOne) AddNft(n ...*NFT) *UserUpdateOne {
	ids := make([]uint64, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return uuo.AddNftIDs(ids...)
}

// AddStreamIDs adds the "stream" edge to the Stream entity by IDs.
func (uuo *UserUpdateOne) AddStreamIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddStreamIDs(ids...)
	return uuo
}

// AddStream adds the "stream" edges to the Stream entity.
func (uuo *UserUpdateOne) AddStream(s ...*Stream) *UserUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uuo.AddStreamIDs(ids...)
}

// AddMaskIDs adds the "mask" edge to the Mask entity by IDs.
func (uuo *UserUpdateOne) AddMaskIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddMaskIDs(ids...)
	return uuo
}

// AddMask adds the "mask" edges to the Mask entity.
func (uuo *UserUpdateOne) AddMask(m ...*Mask) *UserUpdateOne {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uuo.AddMaskIDs(ids...)
}

// AddTimedewIDs adds the "timedew" edge to the TimeDew entity by IDs.
func (uuo *UserUpdateOne) AddTimedewIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddTimedewIDs(ids...)
	return uuo
}

// AddTimedew adds the "timedew" edges to the TimeDew entity.
func (uuo *UserUpdateOne) AddTimedew(t ...*TimeDew) *UserUpdateOne {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.AddTimedewIDs(ids...)
}

// AddCollectionIDs adds the "collection" edge to the Collection entity by IDs.
func (uuo *UserUpdateOne) AddCollectionIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddCollectionIDs(ids...)
	return uuo
}

// AddCollection adds the "collection" edges to the Collection entity.
func (uuo *UserUpdateOne) AddCollection(c ...*Collection) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.AddCollectionIDs(ids...)
}

// AddInviteCodeIDs adds the "invite_code" edge to the Invite_Code entity by IDs.
func (uuo *UserUpdateOne) AddInviteCodeIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddInviteCodeIDs(ids...)
	return uuo
}

// AddInviteCode adds the "invite_code" edges to the Invite_Code entity.
func (uuo *UserUpdateOne) AddInviteCode(i ...*Invite_Code) *UserUpdateOne {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return uuo.AddInviteCodeIDs(ids...)
}

// AddFeedbackIDs adds the "feedback" edge to the Feedback entity by IDs.
func (uuo *UserUpdateOne) AddFeedbackIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddFeedbackIDs(ids...)
	return uuo
}

// AddFeedback adds the "feedback" edges to the Feedback entity.
func (uuo *UserUpdateOne) AddFeedback(f ...*Feedback) *UserUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uuo.AddFeedbackIDs(ids...)
}

// AddReactionTimedewIDs adds the "reaction_timedew" edge to the TimeDew entity by IDs.
func (uuo *UserUpdateOne) AddReactionTimedewIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.AddReactionTimedewIDs(ids...)
	return uuo
}

// AddReactionTimedew adds the "reaction_timedew" edges to the TimeDew entity.
func (uuo *UserUpdateOne) AddReactionTimedew(t ...*TimeDew) *UserUpdateOne {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.AddReactionTimedewIDs(ids...)
}

// AddJoinIDs adds the "joins" edge to the Join entity by IDs.
func (uuo *UserUpdateOne) AddJoinIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddJoinIDs(ids...)
	return uuo
}

// AddJoins adds the "joins" edges to the Join entity.
func (uuo *UserUpdateOne) AddJoins(j ...*Join) *UserUpdateOne {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return uuo.AddJoinIDs(ids...)
}

// AddFriendshipIDs adds the "friendships" edge to the Friendship entity by IDs.
func (uuo *UserUpdateOne) AddFriendshipIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddFriendshipIDs(ids...)
	return uuo
}

// AddFriendships adds the "friendships" edges to the Friendship entity.
func (uuo *UserUpdateOne) AddFriendships(f ...*Friendship) *UserUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uuo.AddFriendshipIDs(ids...)
}

// AddReactionIDs adds the "reactions" edge to the Reaction entity by IDs.
func (uuo *UserUpdateOne) AddReactionIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.AddReactionIDs(ids...)
	return uuo
}

// AddReactions adds the "reactions" edges to the Reaction entity.
func (uuo *UserUpdateOne) AddReactions(r ...*Reaction) *UserUpdateOne {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return uuo.AddReactionIDs(ids...)
}

// Mutation returns the UserMutation object of the builder.
func (uuo *UserUpdateOne) Mutation() *UserMutation {
	return uuo.mutation
}

// ClearUserAuth clears all "user_auth" edges to the User_auth entity.
func (uuo *UserUpdateOne) ClearUserAuth() *UserUpdateOne {
	uuo.mutation.ClearUserAuth()
	return uuo
}

// RemoveUserAuthIDs removes the "user_auth" edge to User_auth entities by IDs.
func (uuo *UserUpdateOne) RemoveUserAuthIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveUserAuthIDs(ids...)
	return uuo
}

// RemoveUserAuth removes "user_auth" edges to User_auth entities.
func (uuo *UserUpdateOne) RemoveUserAuth(u ...*User_auth) *UserUpdateOne {
	ids := make([]int, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.RemoveUserAuthIDs(ids...)
}

// ClearCard clears all "card" edges to the Card entity.
func (uuo *UserUpdateOne) ClearCard() *UserUpdateOne {
	uuo.mutation.ClearCard()
	return uuo
}

// RemoveCardIDs removes the "card" edge to Card entities by IDs.
func (uuo *UserUpdateOne) RemoveCardIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveCardIDs(ids...)
	return uuo
}

// RemoveCard removes "card" edges to Card entities.
func (uuo *UserUpdateOne) RemoveCard(c ...*Card) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.RemoveCardIDs(ids...)
}

// ClearMessage clears all "message" edges to the Message entity.
func (uuo *UserUpdateOne) ClearMessage() *UserUpdateOne {
	uuo.mutation.ClearMessage()
	return uuo
}

// RemoveMessageIDs removes the "message" edge to Message entities by IDs.
func (uuo *UserUpdateOne) RemoveMessageIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveMessageIDs(ids...)
	return uuo
}

// RemoveMessage removes "message" edges to Message entities.
func (uuo *UserUpdateOne) RemoveMessage(m ...*Message) *UserUpdateOne {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uuo.RemoveMessageIDs(ids...)
}

// ClearDevice clears all "device" edges to the Device entity.
func (uuo *UserUpdateOne) ClearDevice() *UserUpdateOne {
	uuo.mutation.ClearDevice()
	return uuo
}

// RemoveDeviceIDs removes the "device" edge to Device entities by IDs.
func (uuo *UserUpdateOne) RemoveDeviceIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveDeviceIDs(ids...)
	return uuo
}

// RemoveDevice removes "device" edges to Device entities.
func (uuo *UserUpdateOne) RemoveDevice(d ...*Device) *UserUpdateOne {
	ids := make([]uint64, len(d))
	for i := range d {
		ids[i] = d[i].ID
	}
	return uuo.RemoveDeviceIDs(ids...)
}

// ClearJoinedCsfield clears all "joined_csfield" edges to the CSField entity.
func (uuo *UserUpdateOne) ClearJoinedCsfield() *UserUpdateOne {
	uuo.mutation.ClearJoinedCsfield()
	return uuo
}

// RemoveJoinedCsfieldIDs removes the "joined_csfield" edge to CSField entities by IDs.
func (uuo *UserUpdateOne) RemoveJoinedCsfieldIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveJoinedCsfieldIDs(ids...)
	return uuo
}

// RemoveJoinedCsfield removes "joined_csfield" edges to CSField entities.
func (uuo *UserUpdateOne) RemoveJoinedCsfield(c ...*CSField) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.RemoveJoinedCsfieldIDs(ids...)
}

// ClearFriends clears all "friends" edges to the User entity.
func (uuo *UserUpdateOne) ClearFriends() *UserUpdateOne {
	uuo.mutation.ClearFriends()
	return uuo
}

// RemoveFriendIDs removes the "friends" edge to User entities by IDs.
func (uuo *UserUpdateOne) RemoveFriendIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveFriendIDs(ids...)
	return uuo
}

// RemoveFriends removes "friends" edges to User entities.
func (uuo *UserUpdateOne) RemoveFriends(u ...*User) *UserUpdateOne {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.RemoveFriendIDs(ids...)
}

// ClearHidden clears all "hidden" edges to the Hidden entity.
func (uuo *UserUpdateOne) ClearHidden() *UserUpdateOne {
	uuo.mutation.ClearHidden()
	return uuo
}

// RemoveHiddenIDs removes the "hidden" edge to Hidden entities by IDs.
func (uuo *UserUpdateOne) RemoveHiddenIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveHiddenIDs(ids...)
	return uuo
}

// RemoveHidden removes "hidden" edges to Hidden entities.
func (uuo *UserUpdateOne) RemoveHidden(h ...*Hidden) *UserUpdateOne {
	ids := make([]int, len(h))
	for i := range h {
		ids[i] = h[i].ID
	}
	return uuo.RemoveHiddenIDs(ids...)
}

// ClearHistory clears all "history" edges to the User_history entity.
func (uuo *UserUpdateOne) ClearHistory() *UserUpdateOne {
	uuo.mutation.ClearHistory()
	return uuo
}

// RemoveHistoryIDs removes the "history" edge to User_history entities by IDs.
func (uuo *UserUpdateOne) RemoveHistoryIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveHistoryIDs(ids...)
	return uuo
}

// RemoveHistory removes "history" edges to User_history entities.
func (uuo *UserUpdateOne) RemoveHistory(u ...*User_history) *UserUpdateOne {
	ids := make([]uint64, len(u))
	for i := range u {
		ids[i] = u[i].ID
	}
	return uuo.RemoveHistoryIDs(ids...)
}

// ClearToken clears all "token" edges to the Agora_token entity.
func (uuo *UserUpdateOne) ClearToken() *UserUpdateOne {
	uuo.mutation.ClearToken()
	return uuo
}

// RemoveTokenIDs removes the "token" edge to Agora_token entities by IDs.
func (uuo *UserUpdateOne) RemoveTokenIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveTokenIDs(ids...)
	return uuo
}

// RemoveToken removes "token" edges to Agora_token entities.
func (uuo *UserUpdateOne) RemoveToken(a ...*Agora_token) *UserUpdateOne {
	ids := make([]uint64, len(a))
	for i := range a {
		ids[i] = a[i].ID
	}
	return uuo.RemoveTokenIDs(ids...)
}

// ClearCreation clears all "creation" edges to the Creation entity.
func (uuo *UserUpdateOne) ClearCreation() *UserUpdateOne {
	uuo.mutation.ClearCreation()
	return uuo
}

// RemoveCreationIDs removes the "creation" edge to Creation entities by IDs.
func (uuo *UserUpdateOne) RemoveCreationIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveCreationIDs(ids...)
	return uuo
}

// RemoveCreation removes "creation" edges to Creation entities.
func (uuo *UserUpdateOne) RemoveCreation(c ...*Creation) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.RemoveCreationIDs(ids...)
}

// ClearContact clears all "contact" edges to the Contact entity.
func (uuo *UserUpdateOne) ClearContact() *UserUpdateOne {
	uuo.mutation.ClearContact()
	return uuo
}

// RemoveContactIDs removes the "contact" edge to Contact entities by IDs.
func (uuo *UserUpdateOne) RemoveContactIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveContactIDs(ids...)
	return uuo
}

// RemoveContact removes "contact" edges to Contact entities.
func (uuo *UserUpdateOne) RemoveContact(c ...*Contact) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.RemoveContactIDs(ids...)
}

// ClearSetting clears all "setting" edges to the Setting entity.
func (uuo *UserUpdateOne) ClearSetting() *UserUpdateOne {
	uuo.mutation.ClearSetting()
	return uuo
}

// RemoveSettingIDs removes the "setting" edge to Setting entities by IDs.
func (uuo *UserUpdateOne) RemoveSettingIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveSettingIDs(ids...)
	return uuo
}

// RemoveSetting removes "setting" edges to Setting entities.
func (uuo *UserUpdateOne) RemoveSetting(s ...*Setting) *UserUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uuo.RemoveSettingIDs(ids...)
}

// ClearNft clears all "nft" edges to the NFT entity.
func (uuo *UserUpdateOne) ClearNft() *UserUpdateOne {
	uuo.mutation.ClearNft()
	return uuo
}

// RemoveNftIDs removes the "nft" edge to NFT entities by IDs.
func (uuo *UserUpdateOne) RemoveNftIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveNftIDs(ids...)
	return uuo
}

// RemoveNft removes "nft" edges to NFT entities.
func (uuo *UserUpdateOne) RemoveNft(n ...*NFT) *UserUpdateOne {
	ids := make([]uint64, len(n))
	for i := range n {
		ids[i] = n[i].ID
	}
	return uuo.RemoveNftIDs(ids...)
}

// ClearStream clears all "stream" edges to the Stream entity.
func (uuo *UserUpdateOne) ClearStream() *UserUpdateOne {
	uuo.mutation.ClearStream()
	return uuo
}

// RemoveStreamIDs removes the "stream" edge to Stream entities by IDs.
func (uuo *UserUpdateOne) RemoveStreamIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveStreamIDs(ids...)
	return uuo
}

// RemoveStream removes "stream" edges to Stream entities.
func (uuo *UserUpdateOne) RemoveStream(s ...*Stream) *UserUpdateOne {
	ids := make([]uint64, len(s))
	for i := range s {
		ids[i] = s[i].ID
	}
	return uuo.RemoveStreamIDs(ids...)
}

// ClearMask clears all "mask" edges to the Mask entity.
func (uuo *UserUpdateOne) ClearMask() *UserUpdateOne {
	uuo.mutation.ClearMask()
	return uuo
}

// RemoveMaskIDs removes the "mask" edge to Mask entities by IDs.
func (uuo *UserUpdateOne) RemoveMaskIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveMaskIDs(ids...)
	return uuo
}

// RemoveMask removes "mask" edges to Mask entities.
func (uuo *UserUpdateOne) RemoveMask(m ...*Mask) *UserUpdateOne {
	ids := make([]uint64, len(m))
	for i := range m {
		ids[i] = m[i].ID
	}
	return uuo.RemoveMaskIDs(ids...)
}

// ClearTimedew clears all "timedew" edges to the TimeDew entity.
func (uuo *UserUpdateOne) ClearTimedew() *UserUpdateOne {
	uuo.mutation.ClearTimedew()
	return uuo
}

// RemoveTimedewIDs removes the "timedew" edge to TimeDew entities by IDs.
func (uuo *UserUpdateOne) RemoveTimedewIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveTimedewIDs(ids...)
	return uuo
}

// RemoveTimedew removes "timedew" edges to TimeDew entities.
func (uuo *UserUpdateOne) RemoveTimedew(t ...*TimeDew) *UserUpdateOne {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.RemoveTimedewIDs(ids...)
}

// ClearCollection clears all "collection" edges to the Collection entity.
func (uuo *UserUpdateOne) ClearCollection() *UserUpdateOne {
	uuo.mutation.ClearCollection()
	return uuo
}

// RemoveCollectionIDs removes the "collection" edge to Collection entities by IDs.
func (uuo *UserUpdateOne) RemoveCollectionIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveCollectionIDs(ids...)
	return uuo
}

// RemoveCollection removes "collection" edges to Collection entities.
func (uuo *UserUpdateOne) RemoveCollection(c ...*Collection) *UserUpdateOne {
	ids := make([]uint64, len(c))
	for i := range c {
		ids[i] = c[i].ID
	}
	return uuo.RemoveCollectionIDs(ids...)
}

// ClearInviteCode clears all "invite_code" edges to the Invite_Code entity.
func (uuo *UserUpdateOne) ClearInviteCode() *UserUpdateOne {
	uuo.mutation.ClearInviteCode()
	return uuo
}

// RemoveInviteCodeIDs removes the "invite_code" edge to Invite_Code entities by IDs.
func (uuo *UserUpdateOne) RemoveInviteCodeIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveInviteCodeIDs(ids...)
	return uuo
}

// RemoveInviteCode removes "invite_code" edges to Invite_Code entities.
func (uuo *UserUpdateOne) RemoveInviteCode(i ...*Invite_Code) *UserUpdateOne {
	ids := make([]int, len(i))
	for j := range i {
		ids[j] = i[j].ID
	}
	return uuo.RemoveInviteCodeIDs(ids...)
}

// ClearFeedback clears all "feedback" edges to the Feedback entity.
func (uuo *UserUpdateOne) ClearFeedback() *UserUpdateOne {
	uuo.mutation.ClearFeedback()
	return uuo
}

// RemoveFeedbackIDs removes the "feedback" edge to Feedback entities by IDs.
func (uuo *UserUpdateOne) RemoveFeedbackIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveFeedbackIDs(ids...)
	return uuo
}

// RemoveFeedback removes "feedback" edges to Feedback entities.
func (uuo *UserUpdateOne) RemoveFeedback(f ...*Feedback) *UserUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uuo.RemoveFeedbackIDs(ids...)
}

// ClearReactionTimedew clears all "reaction_timedew" edges to the TimeDew entity.
func (uuo *UserUpdateOne) ClearReactionTimedew() *UserUpdateOne {
	uuo.mutation.ClearReactionTimedew()
	return uuo
}

// RemoveReactionTimedewIDs removes the "reaction_timedew" edge to TimeDew entities by IDs.
func (uuo *UserUpdateOne) RemoveReactionTimedewIDs(ids ...uint64) *UserUpdateOne {
	uuo.mutation.RemoveReactionTimedewIDs(ids...)
	return uuo
}

// RemoveReactionTimedew removes "reaction_timedew" edges to TimeDew entities.
func (uuo *UserUpdateOne) RemoveReactionTimedew(t ...*TimeDew) *UserUpdateOne {
	ids := make([]uint64, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return uuo.RemoveReactionTimedewIDs(ids...)
}

// ClearJoins clears all "joins" edges to the Join entity.
func (uuo *UserUpdateOne) ClearJoins() *UserUpdateOne {
	uuo.mutation.ClearJoins()
	return uuo
}

// RemoveJoinIDs removes the "joins" edge to Join entities by IDs.
func (uuo *UserUpdateOne) RemoveJoinIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveJoinIDs(ids...)
	return uuo
}

// RemoveJoins removes "joins" edges to Join entities.
func (uuo *UserUpdateOne) RemoveJoins(j ...*Join) *UserUpdateOne {
	ids := make([]int, len(j))
	for i := range j {
		ids[i] = j[i].ID
	}
	return uuo.RemoveJoinIDs(ids...)
}

// ClearFriendships clears all "friendships" edges to the Friendship entity.
func (uuo *UserUpdateOne) ClearFriendships() *UserUpdateOne {
	uuo.mutation.ClearFriendships()
	return uuo
}

// RemoveFriendshipIDs removes the "friendships" edge to Friendship entities by IDs.
func (uuo *UserUpdateOne) RemoveFriendshipIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveFriendshipIDs(ids...)
	return uuo
}

// RemoveFriendships removes "friendships" edges to Friendship entities.
func (uuo *UserUpdateOne) RemoveFriendships(f ...*Friendship) *UserUpdateOne {
	ids := make([]int, len(f))
	for i := range f {
		ids[i] = f[i].ID
	}
	return uuo.RemoveFriendshipIDs(ids...)
}

// ClearReactions clears all "reactions" edges to the Reaction entity.
func (uuo *UserUpdateOne) ClearReactions() *UserUpdateOne {
	uuo.mutation.ClearReactions()
	return uuo
}

// RemoveReactionIDs removes the "reactions" edge to Reaction entities by IDs.
func (uuo *UserUpdateOne) RemoveReactionIDs(ids ...int) *UserUpdateOne {
	uuo.mutation.RemoveReactionIDs(ids...)
	return uuo
}

// RemoveReactions removes "reactions" edges to Reaction entities.
func (uuo *UserUpdateOne) RemoveReactions(r ...*Reaction) *UserUpdateOne {
	ids := make([]int, len(r))
	for i := range r {
		ids[i] = r[i].ID
	}
	return uuo.RemoveReactionIDs(ids...)
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (uuo *UserUpdateOne) Select(field string, fields ...string) *UserUpdateOne {
	uuo.fields = append([]string{field}, fields...)
	return uuo
}

// Save executes the query and returns the updated User entity.
func (uuo *UserUpdateOne) Save(ctx context.Context) (*User, error) {
	var (
		err  error
		node *User
	)
	uuo.defaults()
	if len(uuo.hooks) == 0 {
		if err = uuo.check(); err != nil {
			return nil, err
		}
		node, err = uuo.sqlSave(ctx)
	} else {
		var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
			mutation, ok := m.(*UserMutation)
			if !ok {
				return nil, fmt.Errorf("unexpected mutation type %T", m)
			}
			if err = uuo.check(); err != nil {
				return nil, err
			}
			uuo.mutation = mutation
			node, err = uuo.sqlSave(ctx)
			mutation.done = true
			return node, err
		})
		for i := len(uuo.hooks) - 1; i >= 0; i-- {
			if uuo.hooks[i] == nil {
				return nil, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
			}
			mut = uuo.hooks[i](mut)
		}
		v, err := mut.Mutate(ctx, uuo.mutation)
		if err != nil {
			return nil, err
		}
		nv, ok := v.(*User)
		if !ok {
			return nil, fmt.Errorf("unexpected node type %T returned from UserMutation", v)
		}
		node = nv
	}
	return node, err
}

// SaveX is like Save, but panics if an error occurs.
func (uuo *UserUpdateOne) SaveX(ctx context.Context) *User {
	node, err := uuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (uuo *UserUpdateOne) Exec(ctx context.Context) error {
	_, err := uuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (uuo *UserUpdateOne) ExecX(ctx context.Context) {
	if err := uuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (uuo *UserUpdateOne) defaults() {
	if _, ok := uuo.mutation.UpdateTime(); !ok {
		v := user.UpdateDefaultUpdateTime()
		uuo.mutation.SetUpdateTime(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (uuo *UserUpdateOne) check() error {
	if v, ok := uuo.mutation.Status(); ok {
		if err := user.StatusValidator(v); err != nil {
			return &ValidationError{Name: "status", err: fmt.Errorf(`ent: validator failed for field "User.status": %w`, err)}
		}
	}
	if v, ok := uuo.mutation.Role(); ok {
		if err := user.RoleValidator(v); err != nil {
			return &ValidationError{Name: "role", err: fmt.Errorf(`ent: validator failed for field "User.role": %w`, err)}
		}
	}
	return nil
}

func (uuo *UserUpdateOne) sqlSave(ctx context.Context) (_node *User, err error) {
	_spec := &sqlgraph.UpdateSpec{
		Node: &sqlgraph.NodeSpec{
			Table:   user.Table,
			Columns: user.Columns,
			ID: &sqlgraph.FieldSpec{
				Type:   field.TypeUint64,
				Column: user.FieldID,
			},
		},
	}
	id, ok := uuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "User.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := uuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for _, f := range fields {
			if !user.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := uuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := uuo.mutation.UpdateTime(); ok {
		_spec.SetField(user.FieldUpdateTime, field.TypeTime, value)
	}
	if value, ok := uuo.mutation.OpenID(); ok {
		_spec.SetField(user.FieldOpenID, field.TypeString, value)
	}
	if uuo.mutation.OpenIDCleared() {
		_spec.ClearField(user.FieldOpenID, field.TypeString)
	}
	if value, ok := uuo.mutation.Name(); ok {
		_spec.SetField(user.FieldName, field.TypeString, value)
	}
	if uuo.mutation.NameCleared() {
		_spec.ClearField(user.FieldName, field.TypeString)
	}
	if value, ok := uuo.mutation.NickName(); ok {
		_spec.SetField(user.FieldNickName, field.TypeString, value)
	}
	if uuo.mutation.NickNameCleared() {
		_spec.ClearField(user.FieldNickName, field.TypeString)
	}
	if value, ok := uuo.mutation.SystemName(); ok {
		_spec.SetField(user.FieldSystemName, field.TypeString, value)
	}
	if uuo.mutation.SystemNameCleared() {
		_spec.ClearField(user.FieldSystemName, field.TypeString)
	}
	if value, ok := uuo.mutation.Avatar(); ok {
		_spec.SetField(user.FieldAvatar, field.TypeString, value)
	}
	if uuo.mutation.AvatarCleared() {
		_spec.ClearField(user.FieldAvatar, field.TypeString)
	}
	if value, ok := uuo.mutation.ThumbnailURL(); ok {
		_spec.SetField(user.FieldThumbnailURL, field.TypeString, value)
	}
	if value, ok := uuo.mutation.Sex(); ok {
		_spec.SetField(user.FieldSex, field.TypeString, value)
	}
	if uuo.mutation.SexCleared() {
		_spec.ClearField(user.FieldSex, field.TypeString)
	}
	if value, ok := uuo.mutation.MobileNo(); ok {
		_spec.SetField(user.FieldMobileNo, field.TypeString, value)
	}
	if uuo.mutation.MobileNoCleared() {
		_spec.ClearField(user.FieldMobileNo, field.TypeString)
	}
	if value, ok := uuo.mutation.RegionCode(); ok {
		_spec.SetField(user.FieldRegionCode, field.TypeString, value)
	}
	if uuo.mutation.RegionCodeCleared() {
		_spec.ClearField(user.FieldRegionCode, field.TypeString)
	}
	if value, ok := uuo.mutation.EmailAddress(); ok {
		_spec.SetField(user.FieldEmailAddress, field.TypeString, value)
	}
	if uuo.mutation.EmailAddressCleared() {
		_spec.ClearField(user.FieldEmailAddress, field.TypeString)
	}
	if value, ok := uuo.mutation.Birthday(); ok {
		_spec.SetField(user.FieldBirthday, field.TypeString, value)
	}
	if uuo.mutation.BirthdayCleared() {
		_spec.ClearField(user.FieldBirthday, field.TypeString)
	}
	if value, ok := uuo.mutation.SchoolName(); ok {
		_spec.SetField(user.FieldSchoolName, field.TypeString, value)
	}
	if uuo.mutation.SchoolNameCleared() {
		_spec.ClearField(user.FieldSchoolName, field.TypeString)
	}
	if value, ok := uuo.mutation.Bio(); ok {
		_spec.SetField(user.FieldBio, field.TypeString, value)
	}
	if uuo.mutation.BioCleared() {
		_spec.ClearField(user.FieldBio, field.TypeString)
	}
	if value, ok := uuo.mutation.Status(); ok {
		_spec.SetField(user.FieldStatus, field.TypeEnum, value)
	}
	if value, ok := uuo.mutation.Role(); ok {
		_spec.SetField(user.FieldRole, field.TypeEnum, value)
	}
	if value, ok := uuo.mutation.IsOnline(); ok {
		_spec.SetField(user.FieldIsOnline, field.TypeBool, value)
	}
	if uuo.mutation.IsOnlineCleared() {
		_spec.ClearField(user.FieldIsOnline, field.TypeBool)
	}
	if value, ok := uuo.mutation.IsShowCollections(); ok {
		_spec.SetField(user.FieldIsShowCollections, field.TypeBool, value)
	}
	if value, ok := uuo.mutation.IsInvited(); ok {
		_spec.SetField(user.FieldIsInvited, field.TypeBool, value)
	}
	if value, ok := uuo.mutation.NeedPrivacyConfirm(); ok {
		_spec.SetField(user.FieldNeedPrivacyConfirm, field.TypeBool, value)
	}
	if value, ok := uuo.mutation.CurrentCsFieldID(); ok {
		_spec.SetField(user.FieldCurrentCsFieldID, field.TypeUint64, value)
	}
	if value, ok := uuo.mutation.AddedCurrentCsFieldID(); ok {
		_spec.AddField(user.FieldCurrentCsFieldID, field.TypeUint64, value)
	}
	if uuo.mutation.CurrentCsFieldIDCleared() {
		_spec.ClearField(user.FieldCurrentCsFieldID, field.TypeUint64)
	}
	if value, ok := uuo.mutation.CurrentCsFieldName(); ok {
		_spec.SetField(user.FieldCurrentCsFieldName, field.TypeString, value)
	}
	if uuo.mutation.CurrentCsFieldNameCleared() {
		_spec.ClearField(user.FieldCurrentCsFieldName, field.TypeString)
	}
	if value, ok := uuo.mutation.PrivateCsFieldID(); ok {
		_spec.SetField(user.FieldPrivateCsFieldID, field.TypeUint64, value)
	}
	if value, ok := uuo.mutation.AddedPrivateCsFieldID(); ok {
		_spec.AddField(user.FieldPrivateCsFieldID, field.TypeUint64, value)
	}
	if uuo.mutation.PrivateCsFieldIDCleared() {
		_spec.ClearField(user.FieldPrivateCsFieldID, field.TypeUint64)
	}
	if value, ok := uuo.mutation.PrivateCsFieldName(); ok {
		_spec.SetField(user.FieldPrivateCsFieldName, field.TypeString, value)
	}
	if uuo.mutation.PrivateCsFieldNameCleared() {
		_spec.ClearField(user.FieldPrivateCsFieldName, field.TypeString)
	}
	if value, ok := uuo.mutation.RegisterIP(); ok {
		_spec.SetField(user.FieldRegisterIP, field.TypeString, value)
	}
	if uuo.mutation.RegisterIPCleared() {
		_spec.ClearField(user.FieldRegisterIP, field.TypeString)
	}
	if value, ok := uuo.mutation.Constellation(); ok {
		_spec.SetField(user.FieldConstellation, field.TypeString, value)
	}
	if uuo.mutation.ConstellationCleared() {
		_spec.ClearField(user.FieldConstellation, field.TypeString)
	}
	if value, ok := uuo.mutation.TotalConnections(); ok {
		_spec.SetField(user.FieldTotalConnections, field.TypeInt, value)
	}
	if value, ok := uuo.mutation.AddedTotalConnections(); ok {
		_spec.AddField(user.FieldTotalConnections, field.TypeInt, value)
	}
	if uuo.mutation.TotalConnectionsCleared() {
		_spec.ClearField(user.FieldTotalConnections, field.TypeInt)
	}
	if uuo.mutation.UserAuthCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserAuthTable,
			Columns: []string{user.UserAuthColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user_auth.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedUserAuthIDs(); len(nodes) > 0 && !uuo.mutation.UserAuthCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserAuthTable,
			Columns: []string{user.UserAuthColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user_auth.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.UserAuthIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.UserAuthTable,
			Columns: []string{user.UserAuthColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: user_auth.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.CardCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CardTable,
			Columns: []string{user.CardColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: card.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedCardIDs(); len(nodes) > 0 && !uuo.mutation.CardCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CardTable,
			Columns: []string{user.CardColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: card.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.CardIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CardTable,
			Columns: []string{user.CardColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: card.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.MessageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MessageTable,
			Columns: []string{user.MessageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: message.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedMessageIDs(); len(nodes) > 0 && !uuo.mutation.MessageCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MessageTable,
			Columns: []string{user.MessageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.MessageIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MessageTable,
			Columns: []string{user.MessageColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: message.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.DeviceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceTable,
			Columns: []string{user.DeviceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: device.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedDeviceIDs(); len(nodes) > 0 && !uuo.mutation.DeviceCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceTable,
			Columns: []string{user.DeviceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: device.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.DeviceIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.DeviceTable,
			Columns: []string{user.DeviceColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: device.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.JoinedCsfieldCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.JoinedCsfieldTable,
			Columns: user.JoinedCsfieldPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: csfield.FieldID,
				},
			},
		}
		createE := &JoinCreate{config: uuo.config, mutation: newJoinMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedJoinedCsfieldIDs(); len(nodes) > 0 && !uuo.mutation.JoinedCsfieldCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.JoinedCsfieldTable,
			Columns: user.JoinedCsfieldPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: csfield.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &JoinCreate{config: uuo.config, mutation: newJoinMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.JoinedCsfieldIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.JoinedCsfieldTable,
			Columns: user.JoinedCsfieldPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: csfield.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &JoinCreate{config: uuo.config, mutation: newJoinMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.FriendsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.FriendsTable,
			Columns: user.FriendsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user.FieldID,
				},
			},
		}
		createE := &FriendshipCreate{config: uuo.config, mutation: newFriendshipMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedFriendsIDs(); len(nodes) > 0 && !uuo.mutation.FriendsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.FriendsTable,
			Columns: user.FriendsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &FriendshipCreate{config: uuo.config, mutation: newFriendshipMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.FriendsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: false,
			Table:   user.FriendsTable,
			Columns: user.FriendsPrimaryKey,
			Bidi:    true,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &FriendshipCreate{config: uuo.config, mutation: newFriendshipMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.HiddenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HiddenTable,
			Columns: []string{user.HiddenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: hidden.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedHiddenIDs(); len(nodes) > 0 && !uuo.mutation.HiddenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HiddenTable,
			Columns: []string{user.HiddenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: hidden.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.HiddenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HiddenTable,
			Columns: []string{user.HiddenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: hidden.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.HistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HistoryTable,
			Columns: []string{user.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user_history.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedHistoryIDs(); len(nodes) > 0 && !uuo.mutation.HistoryCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HistoryTable,
			Columns: []string{user.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user_history.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.HistoryIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.HistoryTable,
			Columns: []string{user.HistoryColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: user_history.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.TokenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TokenTable,
			Columns: []string{user.TokenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: agora_token.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedTokenIDs(); len(nodes) > 0 && !uuo.mutation.TokenCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TokenTable,
			Columns: []string{user.TokenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: agora_token.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.TokenIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TokenTable,
			Columns: []string{user.TokenColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: agora_token.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.CreationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreationTable,
			Columns: []string{user.CreationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: creation.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedCreationIDs(); len(nodes) > 0 && !uuo.mutation.CreationCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreationTable,
			Columns: []string{user.CreationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: creation.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.CreationIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CreationTable,
			Columns: []string{user.CreationColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: creation.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.ContactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ContactTable,
			Columns: []string{user.ContactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: contact.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedContactIDs(); len(nodes) > 0 && !uuo.mutation.ContactCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ContactTable,
			Columns: []string{user.ContactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: contact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.ContactIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.ContactTable,
			Columns: []string{user.ContactColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: contact.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.SettingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SettingTable,
			Columns: []string{user.SettingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: setting.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedSettingIDs(); len(nodes) > 0 && !uuo.mutation.SettingCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SettingTable,
			Columns: []string{user.SettingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: setting.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.SettingIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.SettingTable,
			Columns: []string{user.SettingColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: setting.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.NftCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.NftTable,
			Columns: []string{user.NftColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: nft.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedNftIDs(); len(nodes) > 0 && !uuo.mutation.NftCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.NftTable,
			Columns: []string{user.NftColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: nft.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.NftIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.NftTable,
			Columns: []string{user.NftColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: nft.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.StreamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.StreamTable,
			Columns: []string{user.StreamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: stream.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedStreamIDs(); len(nodes) > 0 && !uuo.mutation.StreamCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.StreamTable,
			Columns: []string{user.StreamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: stream.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.StreamIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.StreamTable,
			Columns: []string{user.StreamColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: stream.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.MaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MaskTable,
			Columns: []string{user.MaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: mask.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedMaskIDs(); len(nodes) > 0 && !uuo.mutation.MaskCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MaskTable,
			Columns: []string{user.MaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: mask.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.MaskIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.MaskTable,
			Columns: []string{user.MaskColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: mask.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.TimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TimedewTable,
			Columns: []string{user.TimedewColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedTimedewIDs(); len(nodes) > 0 && !uuo.mutation.TimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TimedewTable,
			Columns: []string{user.TimedewColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.TimedewIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.TimedewTable,
			Columns: []string{user.TimedewColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.CollectionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CollectionTable,
			Columns: []string{user.CollectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: collection.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedCollectionIDs(); len(nodes) > 0 && !uuo.mutation.CollectionCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CollectionTable,
			Columns: []string{user.CollectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.CollectionIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.CollectionTable,
			Columns: []string{user.CollectionColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: collection.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.InviteCodeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.InviteCodeTable,
			Columns: []string{user.InviteCodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: invite_code.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedInviteCodeIDs(); len(nodes) > 0 && !uuo.mutation.InviteCodeCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.InviteCodeTable,
			Columns: []string{user.InviteCodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: invite_code.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.InviteCodeIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.InviteCodeTable,
			Columns: []string{user.InviteCodeColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: invite_code.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.FeedbackCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.FeedbackTable,
			Columns: []string{user.FeedbackColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: feedback.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedFeedbackIDs(); len(nodes) > 0 && !uuo.mutation.FeedbackCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.FeedbackTable,
			Columns: []string{user.FeedbackColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: feedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.FeedbackIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   user.FeedbackTable,
			Columns: []string{user.FeedbackColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: feedback.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.ReactionTimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.ReactionTimedewTable,
			Columns: user.ReactionTimedewPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		createE := &ReactionCreate{config: uuo.config, mutation: newReactionMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedReactionTimedewIDs(); len(nodes) > 0 && !uuo.mutation.ReactionTimedewCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.ReactionTimedewTable,
			Columns: user.ReactionTimedewPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: uuo.config, mutation: newReactionMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.ReactionTimedewIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2M,
			Inverse: true,
			Table:   user.ReactionTimedewTable,
			Columns: user.ReactionTimedewPrimaryKey,
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeUint64,
					Column: timedew.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		createE := &ReactionCreate{config: uuo.config, mutation: newReactionMutation(uuo.config, OpCreate)}
		createE.defaults()
		_, specE := createE.createSpec()
		edge.Target.Fields = specE.Fields
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.JoinsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.JoinsTable,
			Columns: []string{user.JoinsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: join.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedJoinsIDs(); len(nodes) > 0 && !uuo.mutation.JoinsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.JoinsTable,
			Columns: []string{user.JoinsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: join.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.JoinsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.JoinsTable,
			Columns: []string{user.JoinsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: join.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.FriendshipsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.FriendshipsTable,
			Columns: []string{user.FriendshipsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: friendship.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedFriendshipsIDs(); len(nodes) > 0 && !uuo.mutation.FriendshipsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.FriendshipsTable,
			Columns: []string{user.FriendshipsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: friendship.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.FriendshipsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.FriendshipsTable,
			Columns: []string{user.FriendshipsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: friendship.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if uuo.mutation.ReactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.ReactionsTable,
			Columns: []string{user.ReactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: reaction.FieldID,
				},
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.RemovedReactionsIDs(); len(nodes) > 0 && !uuo.mutation.ReactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.ReactionsTable,
			Columns: []string{user.ReactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: reaction.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := uuo.mutation.ReactionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: true,
			Table:   user.ReactionsTable,
			Columns: []string{user.ReactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: &sqlgraph.FieldSpec{
					Type:   field.TypeInt,
					Column: reaction.FieldID,
				},
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &User{config: uuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, uuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{user.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	return _node, nil
}
